<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue.js设计与实现 | 似若秋叶</title>
    <meta name="description" content="专注写作前端博客，记录日常所得。">
    <meta name="generator" content="VitePress v1.1.4">
    <link rel="preload stylesheet" href="/blog/assets/style.XTcW6pvw.css" as="style">
    
    <script type="module" src="/blog/assets/app.DHq-0ClI.js"></script>
    <link rel="preload" href="/blog/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/blog/assets/chunks/theme.B52Oz0HS.js">
    <link rel="modulepreload" href="/blog/assets/chunks/framework.47i9LX9H.js">
    <link rel="modulepreload" href="/blog/assets/前端笔记_Vue.js设计与实现.md.Bm9ioqNK.lean.js">
    <script>var _hmt=_hmt||[];(function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?87e6dfa24d2735e29aae05a54966e81f";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})();</script>
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0f60ec36></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0f60ec36> Skip to content </a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar top" data-v-ae24b3ad data-v-ccf7ddec><div class="wrapper" data-v-ccf7ddec><div class="container" data-v-ccf7ddec><div class="title" data-v-ccf7ddec><div class="VPNavBarTitle" data-v-ccf7ddec data-v-ab179fa1><a class="title" href="/blog/" data-v-ab179fa1><!--[--><!--]--><!----><span data-v-ab179fa1>似若秋叶</span><!--[--><!--]--></a></div></div><div class="content" data-v-ccf7ddec><div class="content-body" data-v-ccf7ddec><!--[--><!--]--><div class="VPNavBarSearch search" data-v-ccf7ddec><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-ccf7ddec data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/blog/index.html" tabindex="0" data-v-7f418b0f data-v-9c663999><!--[--><span data-v-9c663999>首页</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b6c34ac9><span class="text" data-v-b6c34ac9><!----><span data-v-b6c34ac9>常用代码片段</span><span class="vpi-chevron-down text-icon" data-v-b6c34ac9></span></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/CSS%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5.html" data-v-43f1e123><!--[-->CSS常用代码片段<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/JS%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5.html" data-v-43f1e123><!--[-->JS常用代码片段<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup active" data-v-7f418b0f data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b6c34ac9><span class="text" data-v-b6c34ac9><!----><span data-v-b6c34ac9>前端笔记</span><span class="vpi-chevron-down text-icon" data-v-b6c34ac9></span></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/vue%E4%BD%BF%E7%94%A8.html" data-v-43f1e123><!--[-->Vue使用<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/Git.html" data-v-43f1e123><!--[-->Git<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F.html" data-v-43f1e123><!--[-->微信小程序<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20ES6.html" data-v-43f1e123><!--[-->深入理解ES6<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" data-v-43f1e123><!--[-->正则表达式<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/JavaScript%E6%AD%A3%E5%88%99%E8%BF%B7%E4%BD%A0%E4%B9%A6.html" data-v-43f1e123><!--[-->JavaScript正则迷你书<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/JavaScript%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A0%B8%E2%BC%BC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E2%BD%A4%E5%AE%9E%E8%B7%B5.html" data-v-43f1e123><!--[-->JavaScript 设计模式核⼼原理与应⽤实践<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/Webpack.html" data-v-43f1e123><!--[-->Webpack<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/TypeScript.html" data-v-43f1e123><!--[-->TypeScript<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/Node.js%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%8F%91WebServer%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE,%E5%89%8D%E7%AB%AF%E6%99%8B%E5%8D%87%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E5%A4%87.html" data-v-43f1e123><!--[-->Node.js从零开发Web Server博客项目<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/Node.js+KOA2%E4%BB%8E0%E5%88%B01%E6%89%93%E9%80%A0%E8%B6%85%E5%A5%BD%E7%94%A8Web%E6%A1%86%E6%9E%B6%E4%B8%80%E6%AD%A5%E5%88%B0%E4%BD%8D,%E6%8E%8C%E6%8F%A1KOA2%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91.html" data-v-43f1e123><!--[-->Node.js+KOA2 从0到1打造超好用Web框架一步到位<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6+SSR+Koa2%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E7%BE%8E%E5%9B%A2%E7%BD%91.html" data-v-43f1e123><!--[-->Vue全家桶+SSR+Koa2全栈开发美团网<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/Koa2%E6%96%B0%E6%B5%AA%E5%8D%9A%E5%AE%A2.html" data-v-43f1e123><!--[-->Koa2新浪博客<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/linux%E5%91%BD%E4%BB%A4.html" data-v-43f1e123><!--[-->linux命令<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3HTTP.html" data-v-43f1e123><!--[-->图解HTTP<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/HTTP%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86+%E5%AE%9E%E8%B7%B5%20Web%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E5%AD%A6.html" data-v-43f1e123><!--[-->HTTP协议原理<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E5%85%B329%E8%AE%B2.html" data-v-43f1e123><!--[-->计算机网络通关29讲<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/%E5%90%8E%E5%8F%B0%E9%80%9A%E7%94%A8%E6%8F%90%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html" data-v-43f1e123><!--[-->后台通用提效解决方案<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/Electron+Vue3+AI+%E4%BA%91%E5%AD%98%E5%82%A8--%E5%AE%9E%E6%88%98%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8.html" data-v-43f1e123><!--[-->Electron+Vue3+AI+云存储--实战跨平台桌面应用<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link active" href="/blog/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.html" data-v-43f1e123><!--[-->Vue.js设计与实现<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b6c34ac9><span class="text" data-v-b6c34ac9><!----><span data-v-b6c34ac9>Vue源码</span><span class="vpi-chevron-down text-icon" data-v-b6c34ac9></span></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/vue%E6%BA%90%E7%A0%81/vue%E6%BA%90%E7%A0%81day1.html" data-v-43f1e123><!--[-->Vue源码day1<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/vue%E6%BA%90%E7%A0%81/vue%E6%BA%90%E7%A0%81day2.html" data-v-43f1e123><!--[-->Vue源码day2<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/vue%E6%BA%90%E7%A0%81/vue%E6%BA%90%E7%A0%81day3.html" data-v-43f1e123><!--[-->Vue源码day3<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/vue%E6%BA%90%E7%A0%81/vue%E6%BA%90%E7%A0%81day4.html" data-v-43f1e123><!--[-->Vue源码day4<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/vue%E6%BA%90%E7%A0%81/vue%E6%BA%90%E7%A0%81day5.html" data-v-43f1e123><!--[-->Vue源码day5<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b6c34ac9><span class="text" data-v-b6c34ac9><!----><span data-v-b6c34ac9>珠峰架构</span><span class="vpi-chevron-down text-icon" data-v-b6c34ac9></span></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/zhufeng/Node.js%E6%A0%B8%E5%BF%83.html" data-v-43f1e123><!--[-->Node.js核心<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/zhufeng/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.html" data-v-43f1e123><!--[-->前端工程化<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b6c34ac9><span class="text" data-v-b6c34ac9><!----><span data-v-b6c34ac9>面试题库</span><span class="vpi-chevron-down text-icon" data-v-b6c34ac9></span></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E9%80%9A%E4%BF%A1%E7%B1%BB.html" data-v-43f1e123><!--[-->通信类<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/HTML.html" data-v-43f1e123><!--[-->HTML<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/CSS.html" data-v-43f1e123><!--[-->CSS<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/JavaScript.html" data-v-43f1e123><!--[-->JavaScript<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E7%AC%94%E8%AF%95%E9%A2%98.html" data-v-43f1e123><!--[-->笔试题<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/Vue.html" data-v-43f1e123><!--[-->Vue<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/Vue3.html" data-v-43f1e123><!--[-->Vue3<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/Node.js.html" data-v-43f1e123><!--[-->Node.js<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E5%85%B6%E5%AE%83.html" data-v-43f1e123><!--[-->其它<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/vue%E7%9A%84diff%E7%AE%97%E6%B3%95.html" data-v-43f1e123><!--[-->vue的diff算法<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/vue%E5%85%A8%E5%AE%B6%E6%A1%B6.html" data-v-43f1e123><!--[-->Vue全家桶<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%982022.html" data-v-43f1e123><!--[-->面试真题2022<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/blog/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%862025.html" data-v-43f1e123><!--[-->面试题合集2025<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-ccf7ddec data-v-e6aabb21><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-e6aabb21 data-v-d1f28634 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-d1f28634></span><span class="vpi-moon moon" data-v-d1f28634></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-ccf7ddec data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/544402029/blog" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-ccf7ddec data-v-d0bd9dde data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-b6c34ac9><span class="vpi-more-horizontal icon" data-v-b6c34ac9></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-d0bd9dde><div class="item appearance" data-v-d0bd9dde><p class="label" data-v-d0bd9dde>Appearance</p><div class="appearance-action" data-v-d0bd9dde><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-d0bd9dde data-v-d1f28634 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-d1f28634></span><span class="vpi-moon moon" data-v-d1f28634></span><!--]--></span></span></button></div></div></div><div class="group" data-v-d0bd9dde><div class="item social-links" data-v-d0bd9dde><div class="VPSocialLinks social-links-list" data-v-d0bd9dde data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/544402029/blog" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-ccf7ddec data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-ccf7ddec><div class="divider-line" data-v-ccf7ddec></div></div></div><!----></header><div class="VPLocalNav empty fixed" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><!----><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-17a5e62e><button data-v-17a5e62e>Return to top</button><!----></div></div></div><!----><div class="VPContent" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" role="navigation" data-v-3f215769 data-v-269c27a6><div class="content" data-v-269c27a6><div class="outline-marker" data-v-269c27a6></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-269c27a6>On this page</div><ul class="VPDocOutlineItem root" data-v-269c27a6 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _blog_%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0_Vue_js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0" data-v-39a288b8><div><h1 id="vue-js设计与实现" tabindex="-1">Vue.js设计与实现 <a class="header-anchor" href="#vue-js设计与实现" aria-label="Permalink to &quot;Vue.js设计与实现&quot;">​</a></h1><blockquote><p>本篇为看《Vue.js设计与实现》的记录笔记。</p></blockquote><h2 id="第-1-章-权衡的艺术" tabindex="-1">第 1 章　权衡的艺术 <a class="header-anchor" href="#第-1-章-权衡的艺术" aria-label="Permalink to &quot;第 1 章　权衡的艺术&quot;">​</a></h2><h3 id="_1-1-命令式和声明式" tabindex="-1">1.1　命令式和声明式 <a class="header-anchor" href="#_1-1-命令式和声明式" aria-label="Permalink to &quot;1.1　命令式和声明式&quot;">​</a></h3><p>命令式特点式关注过程，声明式更加关注结果。</p><p><em>声明式框架内部一定也是命令式的，只不过Vue.js 帮我们封装了<strong>过程</strong>，而暴漏给用户的更加<strong>声明式</strong>。</em></p><h3 id="_1-2-性能与可维护性的权衡" tabindex="-1">1.2　性能与可维护性的权衡 <a class="header-anchor" href="#_1-2-性能与可维护性的权衡" aria-label="Permalink to &quot;1.2　性能与可维护性的权衡&quot;">​</a></h3><p><strong>声明式代码的性能不优于命令式代码的性能</strong>。</p><p><strong>命令式</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>div.textContent = &#39;hello vue3&#39; // 直接修改</span></span></code></pre></div><p>性能最好</p><p><strong>声明式</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&lt;!-- 之前： --&gt;</span></span>
<span class="line"><span>&lt;div @click=&quot;() =&gt; alert(&#39;ok&#39;)&quot;&gt;hello world&lt;/div&gt;</span></span>
<span class="line"><span>&lt;!-- 之后： --&gt;</span></span>
<span class="line"><span>&lt;div @click=&quot;() =&gt; alert(&#39;ok&#39;)&quot;&gt;hello vue3&lt;/div&gt;</span></span></code></pre></div><p>对于框架来说，为了实现最优的更新性能，它需要找到前后的差异并只更新变化的地方，但是最终完成这次更新的代码仍然是：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>div.textContent = &#39;hello vue3&#39; // 直接修改</span></span></code></pre></div><p>如果我们把直接修改的性能消耗定义为 A，把找出差异的性能消耗定义为 B，那么有：</p><ul><li>命令式代码的更新性能消耗 = A</li><li>声明式代码的更新性能消耗 = B + A</li></ul><p>当找出差异的性能消耗为 0 时，声明式代码与命令式代码的性能相同，但是无法做到超越，<strong>毕竟框架本身就是封装了命令式代码才实现了面向用户的声明式</strong>。这符合前文中给出的性能结论：<strong>声明式代码的性能不优于命令式代码的性能</strong>。</p><p><strong>命令式优于声明式，为什么选择声明式设计方案？</strong></p><p><em>原因在于声明式代码可维护性更强。命令式代码开发时，我们要手动完成DOM的创建、更新、删除等工作，维护实现目标的整个过程。而声明式代码展示的是我们要的<strong>结果</strong>，看上去更加直观。至于过程，由框架内部为我们封装好，让代码<strong>在保持可维护性的同时让性能损失最小化</strong>。</em></p><h3 id="_1-3-虚拟-dom-的性能到底如何" tabindex="-1">1.3　虚拟 DOM 的性能到底如何 <a class="header-anchor" href="#_1-3-虚拟-dom-的性能到底如何" aria-label="Permalink to &quot;1.3　虚拟 DOM 的性能到底如何&quot;">​</a></h3><p>前文说到，<strong>声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗</strong>，因此，如果我们能够最小化<strong>找出差异的性能消耗</strong>，就可以让声明式代码的性能无限接近命令式代码的性能。而所谓的虚拟 DOM，就是为了<strong>最小化</strong>找出差异这一步的性能消耗而出现的。</p><p>在大部分情况下，<strong>我们很难写出绝对优化的命令式代码</strong>，尤其是当应用程序的规模很大的时候，即使你写出了极致优化的代码，也一定耗费了巨大的精力，这时的投入产出比其实并不高。</p><p><em>命令式代码理论上限很高，下限很低。上限也需要大量精力。</em></p><p><em>声明式下限很高，性能不会太差。</em></p><p><strong>怎么逼近命令式代码的性能呢？这其实就是虚拟 DOM 要解决的问题。</strong></p><p><strong>比较 <code>innerHTML</code> 和虚拟 DOM 的性能</strong></p><ul><li>创建页面时：</li></ul><p><code>innerHTML</code> 创建页面的性能：<strong>HTML 字符串拼接的计算量 + <code>innerHTML</code> 的 DOM 计算量</strong>。</p><p>虚拟 DOM 在创建页面时的性能：<strong>创建 JavaScript 对象的计算量 + 创建真实 DOM 的计算量</strong>。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20230508172857597.png" alt="image-20230508172857597"></p><ul><li>更新页面时：</li></ul><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20230508173135884.png" alt="image-20230508173135884"></p><p>可以发现，在更新页面时，虚拟 DOM 在 JavaScript 层面的运算要比创建页面时多出一个 Diff 的性能消耗，然而它毕竟也是 JavaScript 层面的运算，所以不会产生数量级的差异。再观察 DOM 层面的运算，可以发现虚拟 DOM 在更新页面时只会更新必要的元素，但 <code>innerHTML</code> 需要全量更新。这时虚拟 DOM 的优势就体现出来了。</p><p>另外，我们发现，当更新页面时，影响虚拟 DOM 的性能因素与影响 <code>innerHTML</code> 的性能因素不同。对于虚拟 DOM 来说，无论页面多大，都只会更新变化的内容，而对于 <code>innerHTML</code> 来说，页面越大，就意味着更新时的性能消耗越大。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20230508173346867.png" alt="图 1-5"></p><p><strong>图 1-5　<code>innerHTML</code>、虚拟 DOM 以及原生 JavaScript 在更新页面时的性能</strong></p><p>有没有办法做到，既声明式地描述 UI，又具备原生 JavaScript 的性能呢？看上去有点儿鱼与熊掌兼得的意思，我们会在下一章中继续讨论。</p><h3 id="_1-4-运行时和编译时" tabindex="-1">1.4　运行时和编译时 <a class="header-anchor" href="#_1-4-运行时和编译时" aria-label="Permalink to &quot;1.4　运行时和编译时&quot;">​</a></h3><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20250306115858666.png" alt="image-20250306115858666"></p><p><strong>图 1-6　把 HTML 标签编译成树型结构的数据对象</strong></p><p>​ 首先是纯运行时的框架。由于它没有编译的过程，因此我们没办法分析用户提供的内容，但是如果加入编译步骤，可能就大不一样了，我们可以分析用户提供的内容，看看哪些内容未来可能会改变，哪些内容永远不会改变，这样我们就可以在编译的时候提取这些信息，然后将其传递给 <code>Render</code> 函数，<code>Render</code> 函数得到这些信息之后，就可以做进一步的优化了。然而，假如我们设计的框架是纯编译时的，那么它也可以分析用户提供的内容。由于不需要任何运行时，而是直接编译成可执行的 JavaScript 代码，因此性能可能会更好，但是这种做法有损灵活性，即用户提供的内容必须编译后才能用。</p><h2 id="第-2-章-框架设计的核心要素" tabindex="-1">第 2 章　框架设计的核心要素 <a class="header-anchor" href="#第-2-章-框架设计的核心要素" aria-label="Permalink to &quot;第 2 章　框架设计的核心要素&quot;">​</a></h2><h3 id="_2-5-特性开关" tabindex="-1">2.5　特性开关 <a class="header-anchor" href="#_2-5-特性开关" aria-label="Permalink to &quot;2.5　特性开关&quot;">​</a></h3><p>为了兼容 Vue.js 2，在 Vue.js 3 中仍然可以使用选项 API 的方式编写代码。但是如果明确知道自己不会使用选项 API，用户就可以使用 <code>__VUE_OPTIONS_API__</code> 开关来关闭该特性，这样在打包的时候 Vue.js 的这部分代码就不会包含在最终的资源中，从而<strong>减小资源体积</strong>。</p><p><em>性能优化时可讲。</em></p><h3 id="_2-6-错误处理" tabindex="-1">2.6　错误处理 <a class="header-anchor" href="#_2-6-错误处理" aria-label="Permalink to &quot;2.6　错误处理&quot;">​</a></h3><p>可以看到，代码变得简洁多了。但简洁不是目的，这么做真正的好处是，我们能为用户提供统一的错误处理接口，如以下代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // utils.js</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> handleError </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   foo(fn) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     callWithErrorHandling</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fn)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 用户可以调用该函数注册统一的错误处理函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   registerErrorHandler(fn) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     handleError </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fn</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callWithErrorHandling</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     fn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 将捕获到的错误传递给用户的错误处理程序</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     handleError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>我们提供了 <code>registerErrorHandler</code> 函数，用户可以使用它注册错误处理程序，然后在 <code>callWithErrorHandling</code> 函数内部捕获错误后，把错误传递给用户注册的错误处理程序。</p><p>这样用户侧的代码就会非常简洁且健壮：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> utils </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;utils.js&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 注册错误处理程序</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> utils.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">registerErrorHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> utils.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*...*/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> utils.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*...*/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>这时错误处理的能力完全由用户控制，用户既可以选择忽略错误，也可以调用上报程序将错误上报给监控系统。</p><p>实际上，这就是 Vue.js 错误处理的原理，你可以在源码中搜索到 <code>callWithErrorHandling</code> 函数。另外，在 Vue.js 中，我们也可以注册统一的错误处理函数：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> App </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;App.vue&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> app</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createApp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(App)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> app.config.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">errorHandler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 错误处理程序</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><h2 id="第-3-章-vue-js-3-的设计思路" tabindex="-1">第 3 章　Vue.js 3 的设计思路 <a class="header-anchor" href="#第-3-章-vue-js-3-的设计思路" aria-label="Permalink to &quot;第 3 章　Vue.js 3 的设计思路&quot;">​</a></h2><h3 id="_3-1-声明式地描述-ui" tabindex="-1">3.1　声明式地描述 UI <a class="header-anchor" href="#_3-1-声明式地描述-ui" aria-label="Permalink to &quot;3.1　声明式地描述 UI&quot;">​</a></h3><p>那么，使用模板和 JavaScript 对象描述 UI 有何不同呢？答案是：使用 JavaScript 对象描述 UI 更加灵活。举个例子，假如我们要表示一个标题，根据标题级别的不同，会分别采用 <code>h1</code>~<code>h6</code> 这几个标签，如果用 JavaScript 对象来描述，我们只需要使用一个变量来代表 <code>h</code> 标签即可：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // h 标签的级别</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> level </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> title</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`h${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">level</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// h3 标签</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><h3 id="_3-2-初识渲染器" tabindex="-1">3.2　初识渲染器 <a class="header-anchor" href="#_3-2-初识渲染器" aria-label="Permalink to &quot;3.2　初识渲染器&quot;">​</a></h3><p>现在我们已经了解了什么是虚拟 DOM，它其实就是用 JavaScript 对象来描述真实的 DOM 结构。那么，虚拟 DOM 是如何变成真实 DOM 并渲染到浏览器页面中的呢？这就用到了我们接下来要介绍的：渲染器。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20250306150342362.png" alt="image-20250306150342362"></p><p><strong>图 3-1　渲染器的作用</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> vnode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   props: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     onClick: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click me&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>接下来，我们需要编写一个<strong>渲染器</strong>，把上面这段虚拟 DOM 渲染为真实 DOM：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> renderer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vnode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 使用 vnode.tag 作为标签名称创建 DOM 元素</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vnode.tag)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 遍历 vnode.props，将属性、事件添加到 DOM 元素</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vnode.props) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">on</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key)) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 如果 key 以 on 开头，说明它是事件</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       el.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         key.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">substr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toLowerCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 事件名称 onClick ---&gt; click</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         vnode.props[key] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 事件处理函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       )</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 处理 children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vnode.children </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;string&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 如果 children 是字符串，说明它是元素的文本子节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     el.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createTextNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vnode.children))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vnode.children)) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 递归地调用 renderer 函数渲染子节点，使用当前元素 el 作为挂载点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     vnode.children.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">child</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> renderer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(child, el))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 将元素添加到挂载点下</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   container.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(el)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>现在我们回过头来分析渲染器 <code>renderer</code> 的实现思路，总体来说分为三步。</p><ul><li>创建元素：把 <code>vnode.tag</code> 作为标签名称来创建 DOM 元素。</li><li>为元素添加属性和事件：遍历 <code>vnode.props</code> 对象，如果 <code>key</code> 以 <code>on</code> 字符开头，说明它是一个事件，把字符 <code>on</code> 截取掉后再调用 <code>toLowerCase</code> 函数将事件名称小写化，最终得到合法的事件名称，例如 <code>onClick</code> 会变成 <code>click</code>，最后调用 <code>addEventListener</code> 绑定事件处理函数。</li><li>处理 <code>children</code>：如果 <code>children</code> 是一个数组，就递归地调用 <code>renderer</code> 继续渲染，注意，此时我们要把刚刚创建的元素作为挂载点（父节点）；如果 <code>children</code> 是字符串，则使用 <code>createTextNode</code> 函数创建一个文本节点，并将其添加到新创建的元素内。</li></ul><h3 id="_3-3-组件的本质" tabindex="-1">3.3　组件的本质 <a class="header-anchor" href="#_3-3-组件的本质" aria-label="Permalink to &quot;3.3　组件的本质&quot;">​</a></h3><p>其实虚拟 DOM 除了能够描述真实 DOM 之外，还能够描述组件。例如使用 <code>{ tag: &#39;div&#39; }</code> 来描述 <code>&lt;div&gt;</code> 标签，但是组件并不是真实的 DOM 元素，那么如何使用虚拟 DOM 来描述呢？想要弄明白这个问题，就需要先搞清楚组件的本质是什么。一句话总结：<strong>组件就是一组 DOM 元素的封装</strong>，这组 DOM 元素就是组件要渲染的内容，因此我们可以定义一个函数来代表组件，而函数的返回值就代表组件要渲染的内容：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     props: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       onClick: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click me&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>可以看到，组件的返回值也是虚拟 DOM，它代表组件要渲染的内容。搞清楚了组件的本质，我们就可以定义用虚拟 DOM 来描述组件了。很简单，我们可以让虚拟 DOM 对象中的 <code>tag</code> 属性来存储组件函数：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> vnode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   tag: MyComponent</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> renderer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vnode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vnode.tag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;string&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 说明 vnode 描述的是标签元素</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     mountElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vnode, container)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vnode.tag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;function&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 说明 vnode 描述的是组件</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     mountComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vnode, container)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>再来看 <code>mountComponent</code> 函数是如何实现的：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mountComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vnode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 调用组件函数，获取组件要渲染的内容（虚拟 DOM）</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> subtree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vnode.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 递归地调用 renderer 渲染 subtree</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   renderer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(subtree, container)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><h3 id="_3-4-模板的工作原理" tabindex="-1">3.4　模板的工作原理 <a class="header-anchor" href="#_3-4-模板的工作原理" aria-label="Permalink to &quot;3.4　模板的工作原理&quot;">​</a></h3><p>无论是手写虚拟 DOM（渲染函数）还是使用模板，都属于声明式地描述 UI，并且 Vue.js 同时支持这两种描述 UI 的方式。上文中我们讲解了虚拟 DOM 是如何渲染成真实 DOM 的，那么模板是如何工作的呢？这就要提到 Vue.js 框架中的另外一个重要组成部分：<strong>编译器</strong>。</p><p>以我们熟悉的 .vue 文件为例，一个 .vue 文件就是一个组件，如下所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">template</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div @click</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;handler&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     click me</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   &lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">template</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">script</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   data() {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   methods: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     handler: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">script</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>其中 <code>&lt;template&gt;</code> 标签里的内容就是模板内容，编译器会把模板内容编译成渲染函数并添加到 <code>&lt;script&gt;</code> 标签块的组件对象上，所以最终在浏览器里运行的代码就是：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   data() {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   methods: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     handler: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   render() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { onClick: handler }, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click me&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>所以，无论是使用模板还是直接手写渲染函数，对于一个组件来说，它要渲染的内容最终都是通过渲染函数产生的，然后<strong>渲染器</strong>再把渲染函数返回的虚拟 DOM 渲染为真实 DOM，这就是模板的工作原理，也是 Vue.js 渲染页面的流程。</p><p><strong>编译器</strong>是一个比较大的话题，后面我们会着重讲解，这里大家只需要清楚编译器的作用及角色即可。</p><h3 id="_3-5-vue-js-是各个模块组成的有机整体" tabindex="-1">3.5　Vue.js 是各个模块组成的有机整体 <a class="header-anchor" href="#_3-5-vue-js-是各个模块组成的有机整体" aria-label="Permalink to &quot;3.5　Vue.js 是各个模块组成的有机整体&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     props: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       id: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       class: cls</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     patchFlags: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 假设数字 1 代表 class 是动态的</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>如上面的代码所示，在生成的虚拟 DOM 对象中多出了一个 <code>patchFlags</code> 属性，我们假设数字 <code>1</code> 代表“ <code>class</code> 是动态的”，这样渲染器看到这个标志时就知道：“哦，原来只有 <code>class</code> 属性会发生改变。”对于渲染器来说，就相当于省去了寻找变更点的工作量，性能自然就提升了。</p><p><em>性能优化时可讲。</em></p><h3 id="_3-6-总结" tabindex="-1">3.6　总结 <a class="header-anchor" href="#_3-6-总结" aria-label="Permalink to &quot;3.6　总结&quot;">​</a></h3><p>虚拟 DOM 要比模板更加灵活，但模板要比虚拟 DOM 更加直观。</p><p>渲染器的作用是，把虚拟 DOM 对象渲染为真实 DOM 元素。它的工作原理是，递归地遍历虚拟 DOM 对象，并调用原生 DOM API 来完成真实 DOM 的创建。渲染器的精髓在于后续的更新，它会通过 Diff 算法找出变更点，并且只会更新需要更新的内容。</p><p>组件其实就是一组虚拟 DOM 元素的封装，会先获取组件要渲染的内容，即执行组件的渲染函数并得到其返回值，我们称之为 <code>subtree</code>，最后再递归地调用渲染器将 <code>subtree</code> 渲染出来即可。</p><p>Vue.js 的模板会被一个叫作编译器的程序编译为渲染函数。</p><h2 id="第-4-章-响应系统的作用与实现" tabindex="-1">第 4 章　响应系统的作用与实现 <a class="header-anchor" href="#第-4-章-响应系统的作用与实现" aria-label="Permalink to &quot;第 4 章　响应系统的作用与实现&quot;">​</a></h2><h3 id="_4-2-响应式数据的基本实现" tabindex="-1">4.2　响应式数据的基本实现 <a class="header-anchor" href="#_4-2-响应式数据的基本实现" aria-label="Permalink to &quot;4.2　响应式数据的基本实现&quot;">​</a></h3><ul><li>当副作用函数 <code>effect</code> 执行时，会触发字段 <code>obj.text</code> 的<strong>读取</strong>操作；</li><li>当修改 <code>obj.text</code> 的值时，会触发字段 <code>obj.text</code> 的<strong>设置</strong>操作。</li></ul><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20230510153331414.png" alt="image-20230510153331414"></p><p>接着，当设置 <code>obj.text</code> 时，再把副作用函数 <code>effect</code> 从“桶”里取出并执行即可</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20230510153443975.png" alt="image-20230510153443975"></p><p><strong>把副作用函数从“桶”内取出并执行</strong></p><h3 id="_4-3-设计一个完善的响应系统" tabindex="-1">4.3　设计一个完善的响应系统 <a class="header-anchor" href="#_4-3-设计一个完善的响应系统" aria-label="Permalink to &quot;4.3　设计一个完善的响应系统&quot;">​</a></h3><p>接下来我们就根据如上思路，采用 <code>Proxy</code> 来实现：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 用一个全局变量存储被注册的副作用函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> activeEffect</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // effect 函数用于注册副作用函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 当调用 effect 注册副作用函数时，将副作用函数 fn 赋值给 activeEffect</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   activeEffect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fn</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 执行副作用函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 一个匿名的副作用函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     document.body.innerText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj.text</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   get(target, key) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 将 activeEffect 中存储的副作用函数收集到“桶”中</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (activeEffect) {  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新增</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       bucket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(activeEffect)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新增</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新增</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target[key]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   set(target, key, newVal) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     target[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVal</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     bucket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 匿名副作用函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;effect run&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 会打印 2 次</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     document.body.innerText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj.text</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 副作用函数中并没有读取 notExist 属性的值</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   obj.notExist </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;hello vue3&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effectFn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   document.body.innerText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj.text</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p>在这段代码中存在三个角色：</p><ul><li>被操作（读取）的代理对象 <code>obj</code>；</li><li>被操作（读取）的字段名 <code>text</code>；</li><li>使用 <code>effect</code> 函数注册的副作用函数 <code>effectFn</code>。</li></ul><p>如果在不同的副作用函数中读取了两个不同对象的不同属性：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effectFn1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   obj1.text1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effectFn2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   obj2.text2</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p>那么关系如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     └── text1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         └── effectFn1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target2</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     └── text2</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         └── effectFn2</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 存储副作用函数的桶</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bucket</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WeakMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 拦截读取操作</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   get(target, key) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 没有 activeEffect，直接 return</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">activeEffect) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target[key]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 根据 target 从“桶”中取得 depsMap，它也是一个 Map 类型：key --&gt; effects</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> depsMap </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bucket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 如果不存在 depsMap，那么新建一个 Map 并与 target 关联</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">depsMap) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       bucket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, (depsMap </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型，</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 里面存储着所有与当前 key 相关联的副作用函数：effects</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deps </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> depsMap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 如果 deps 不存在，同样新建一个 Set 并与 key 关联</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">deps) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       depsMap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, (deps </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 最后将当前激活的副作用函数添加到“桶”里</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     deps.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(activeEffect)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 返回属性值</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target[key]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 拦截设置操作</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   set(target, key, newVal) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 设置属性值</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     target[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVal</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 根据 target 从桶中取得 depsMap，它是 key --&gt; effects</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> depsMap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bucket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">31</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">depsMap) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 根据 key 取得所有副作用函数 effects</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">33</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> effects</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> depsMap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">34</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 执行副作用函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">35</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     effects </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> effects.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">36</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">37</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p>从这段代码可以看出构建数据结构的方式，我们分别使用了 <code>WeakMap</code>、<code>Map</code> 和 <code>Set</code>：</p><ul><li><code>WeakMap</code> 由 <code>target --&gt; Map</code> 构成；</li><li><code>Map</code> 由 <code>key --&gt; Set</code> 构成。</li></ul><p>其中 <code>WeakMap</code> 的键是原始对象 <code>target</code>，<code>WeakMap</code> 的值是一个 <code>Map</code> 实例，而 <code>Map</code> 的键是原始对象 <code>target</code> 的 <code>key</code>，<code>Map</code> 的值是一个由副作用函数组成的 <code>Set</code></p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20230510155659664.png" alt="图 4-3"></p><p><strong>图 4-3　<code>WeakMap</code>、<code>Map</code> 和 <code>Set</code> 之间的关系</strong></p><p>为了方便描述，我们把图 4-3 中的 <code>Set</code> 数据结构所存储的副作用函数集合称为 <code>key</code> 的<strong>依赖集合</strong>。</p><p>搞清了它们之间的关系，我们有必要解释一下这里为什么要使用 <code>WeakMap</code>，这其实涉及 <code>WeakMap</code> 和 <code>Map</code> 的区别，我们用一段代码来讲解：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const map = new Map();</span></span>
<span class="line"><span>02 const weakmap = new WeakMap();</span></span>
<span class="line"><span>03</span></span>
<span class="line"><span>04 (function(){</span></span>
<span class="line"><span>05     const foo = {foo: 1};</span></span>
<span class="line"><span>06     const bar = {bar: 2};</span></span>
<span class="line"><span>07</span></span>
<span class="line"><span>08     map.set(foo, 1);</span></span>
<span class="line"><span>09     weakmap.set(bar, 2);</span></span>
<span class="line"><span>10 })()</span></span></code></pre></div><p>首先，我们定义了 <code>map</code> 和 <code>weakmap</code> 常量，分别对应 <code>Map</code> 和 <code>WeakMap</code> 的实例。接着定义了一个立即执行的函数表达式（IIFE），在函数表达式内部定义了两个对象：<code>foo</code> 和 <code>bar</code>，这两个对象分别作为 <code>map</code> 和 <code>weakmap</code> 的 <code>key</code>。当该函数表达式执行完毕后，对于对象 <code>foo</code> 来说，它仍然作为 <code>map</code> 的 <code>key</code> 被引用着，因此<strong>垃圾回收器</strong>（grabage collector）不会把它从内存中移除，我们仍然可以通过 <code>map.keys</code> 打印出对象 <code>foo</code>。然而对于对象 <code>bar</code> 来说，由于 <code>WeakMap</code> 的 <code>key</code> 是弱引用，它不影响垃圾回收器的工作，所以一旦表达式执行完毕，垃圾回收器就会把对象 <code>bar</code> 从内存中移除，并且我们无法获取 <code>weakmap</code> 的 <code>key</code> 值，也就无法通过 <code>weakmap</code> 取得对象 <code>bar</code>。</p><p>简单地说，<code>WeakMap</code> 对 <code>key</code> 是弱引用，不影响垃圾回收器的工作。据这个特性可知，一旦 <code>key</code> 被垃圾回收器回收，那么对应的键和值就访问不到了。所以 <code>WeakMap</code> 经常用于存储那些只有当 <code>key</code> 所引用的对象存在时（没有被回收）才有价值的信息，例如上面的场景中，如果 <code>target</code> 对象没有任何引用了，说明用户侧不再需要它了，这时垃圾回收器会完成回收任务。但如果使用 <code>Map</code> 来代替 <code>WeakMap</code>，那么即使用户侧的代码对 <code>target</code> 没有任何引用，这个 <code>target</code> 也不会被回收，最终可能导致内存溢出。</p><h3 id="_4-4-分支切换与-cleanup" tabindex="-1">4.4　分支切换与 <code>cleanup</code> <a class="header-anchor" href="#_4-4-分支切换与-cleanup" aria-label="Permalink to &quot;4.4　分支切换与 `cleanup`&quot;">​</a></h3><p>首先，我们需要明确分支切换的定义，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const data = { ok: true, text: &#39;hello world&#39; }</span></span>
<span class="line"><span>02 const obj = new Proxy(data, { /* ... */ })</span></span>
<span class="line"><span>03</span></span>
<span class="line"><span>04 effect(function effectFn() {</span></span>
<span class="line"><span>05   document.body.innerText = obj.ok ? obj.text : &#39;not&#39;</span></span>
<span class="line"><span>06 })</span></span></code></pre></div><p>在 <code>effectFn</code> 函数内部存在一个三元表达式，根据字段 <code>obj.ok</code> 值的不同会执行不同的代码分支。当字段 <code>obj.ok</code> 的值发生变化时，代码执行的分支会跟着变化，这就是所谓的分支切换。</p><p>分支切换可能会产生遗留的副作用函数。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20250306163705874.png" alt="图 4-6"></p><p><strong>图 4-6　断开副作用函数与响应式数据之间的联系</strong></p><p>当副作用函数执行完毕后，会重新建立联系，但在新的联系中不会包含遗留的副作用函数，即图 4-5 所描述的那样。所以，如果我们能做到每次副作用函数执行前，将其从相关联的依赖集合中移除，那么问题就迎刃而解了。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20250306163941074.png" alt="图 4-7"></p><p><strong>图 4-7　对依赖集合的收集</strong></p><p>有了这个联系后，我们就可以在每次副作用函数执行时，根据 <code>effectFn.deps</code> 获取所有相关联的依赖集合，进而将副作用函数从依赖集合中移除</p><h3 id="_4-5-嵌套的-effect-与-effect-栈" tabindex="-1">4.5　嵌套的 <code>effect</code> 与 <code>effect</code> 栈 <a class="header-anchor" href="#_4-5-嵌套的-effect-与-effect-栈" aria-label="Permalink to &quot;4.5　嵌套的 `effect` 与 `effect` 栈&quot;">​</a></h3><p><code>effect</code> 是可以发生嵌套的，例如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effectFn1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effectFn2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   /* ... */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p>在上面这段代码中，<code>effectFn1</code> 内部嵌套了 <code>effectFn2</code>，<code>effectFn1</code> 的执行会导致 <code>effectFn2</code> 的执行。那么，什么场景下会出现嵌套的 <code>effect</code> 呢？拿 Vue.js 来说，实际上 Vue.js 的渲染函数就是在一个 <code>effect</code> 中执行的：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Foo 组件</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   render() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     return</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* ... */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>在一个 <code>effect</code> 中执行 <code>Foo</code> 组件的渲染函数：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   Foo.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p>当组件发生嵌套时，例如 <code>Foo</code> 组件渲染了 <code>Bar</code> 组件：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Bar 组件</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Bar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   render() { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Foo 组件渲染了 Bar 组件</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   render() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// jsx 语法</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>此时就发生了 <code>effect</code> 嵌套，它相当于：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   Foo.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 嵌套</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     Bar.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   })</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p></p><p>这个例子说明了为什么 <code>effect</code> 要设计成可嵌套的。接下来，我们需要搞清楚，如果 <code>effect</code> 不支持嵌套会发生什么？实际上，按照前文的介绍与实现来看，我们所实现的响应系统并不支持 <code>effect</code> 嵌套，可以用下面的代码来测试一下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 原始数据</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { foo: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, bar: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 代理对象</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 全局变量</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> temp1, temp2</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // effectFn1 嵌套了 effectFn2</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effectFn1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;effectFn1 执行&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effectFn2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;effectFn2 执行&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 在 effectFn2 中读取 obj.bar 属性</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     temp2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj.bar</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   })</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 在 effectFn1 中读取 obj.foo 属性</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   temp1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj.foo</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p>在上面这段代码中，<code>effectFn1</code> 内部嵌套了 <code>effectFn2</code>，很明显，<code>effectFn1</code> 的执行会导致 <code>effectFn2</code> 的执行。需要注意的是，我们在 <code>effectFn2</code> 中读取了字段 <code>obj.bar</code>，在 <code>effectFn1</code> 中读取了字段 <code>obj.foo</code>，并且 <code>effectFn2</code> 的执行先于对字段 <code>obj.foo</code> 的读取操作。在理想情况下，我们希望副作用函数与对象属性之间的联系如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   └── foo</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     └── effectFn1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   └── bar</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     └── effectFn2</span></span></code></pre></div><p>在这种情况下，我们希望当修改 <code>obj.foo</code> 时会触发 <code>effectFn1</code> 执行。由于 <code>effectFn2</code> 嵌套在 <code>effectFn1</code> 里，所以会间接触发 <code>effectFn2</code> 执行，而当修改 <code>obj.bar</code> 时，只会触发 <code>effectFn2</code> 执行。但结果不是这样的，我们尝试修改 <code>obj.foo</code> 的值，会发现输出为：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;effectFn1 执行&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;effectFn2 执行&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;effectFn2 执行&#39;</span></span></code></pre></div><p>一共打印三次，前两次分别是副作用函数 <code>effectFn1</code> 与 <code>effectFn2</code> 初始执行的打印结果，到这一步是正常的，问题出在第三行打印。我们修改了字段 <code>obj.foo</code> 的值，发现 <code>effectFn1</code> 并没有重新执行，反而使得 <code>effectFn2</code> 重新执行了，这显然不符合预期。</p><p>问题出在哪里呢？其实就出在我们实现的 <code>effect</code> 函数与 <code>activeEffect</code> 上。观察下面这段代码：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 用一个全局变量存储当前激活的 effect 函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> activeEffect</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effectFn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     cleanup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(effectFn)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 当调用 effect 注册副作用函数时，将副作用函数赋值给 activeEffect</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     activeEffect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> effectFn</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   effectFn.deps </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 执行副作用函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   effectFn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>我们用全局变量 <code>activeEffect</code> 来存储通过 <code>effect</code> 函数注册的副作用函数，这意味着同一时刻 <code>activeEffect</code> 所存储的副作用函数只能有一个。当副作用函数发生嵌套时，内层副作用函数的执行会覆盖 <code>activeEffect</code> 的值，并且永远不会恢复到原来的值。这时如果再有响应式数据进行依赖收集，即使这个响应式数据是在外层副作用函数中读取的，它们收集到的副作用函数也都会是内层副作用函数，这就是问题所在。</p><p>为了解决这个问题，我们需要一个副作用函数栈 <code>effectStack</code>，在副作用函数执行时，将当前副作用函数压入栈中，待副作用函数执行完毕后将其从栈中弹出，并始终让 <code>activeEffect</code> 指向栈顶的副作用函数。这样就能做到一个响应式数据只会收集直接读取其值的副作用函数，而不会出现互相影响的情况，如以下代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 用一个全局变量存储当前激活的 effect 函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> activeEffect</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // effect 栈</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> effectStack</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新增</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effectFn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     cleanup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(effectFn)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 当调用 effect 注册副作用函数时，将副作用函数赋值给 activeEffect</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     activeEffect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> effectFn</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 在调用副作用函数之前将当前副作用函数压入栈中</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     effectStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(effectFn)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新增</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把 activeEffect 还原为之前的值</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     effectStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新增</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     activeEffect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> effectStack[effectStack.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新增</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   effectFn.deps </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 执行副作用函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   effectFn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>我们定义了 <code>effectStack</code> 数组，用它来模拟栈，<code>activeEffect</code> 没有变化，它仍然指向当前正在执行的副作用函数。不同的是，当前执行的副作用函数会被压入栈顶，这样当副作用函数发生嵌套时，栈底存储的就是外层副作用函数，而栈顶存储的则是内层副作用函数，如图所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20230511145505231.png" alt="image-20230511145505231"></p><p>当内层副作用函数 <code>effectFn2</code> 执行完毕后，它会被弹出栈，并将副作用函数 <code>effectFn1</code> 设置为 <code>activeEffect</code>，如图 4-9 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20250306213932688.png" alt="图 4-9"></p><p>如此一来，响应式数据就只会收集直接读取其值的副作用函数作为依赖，从而避免发生错乱。</p><h3 id="_4-6-避免无限递归循环" tabindex="-1">4.6　避免无限递归循环 <a class="header-anchor" href="#_4-6-避免无限递归循环" aria-label="Permalink to &quot;4.6　避免无限递归循环&quot;">​</a></h3><p>​ 实现一个完善的响应系统要考虑诸多细节。而本节要介绍的无限递归循环就是其中之一，还是举个例子：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { foo: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*...*/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj.foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p></p><p>​ 可以看到，在 <code>effect</code> 注册的副作用函数内有一个自增操作 <code>obj.foo++</code>，该操作会引起栈溢出：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Uncaught </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RangeError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Maximum call stack size exceeded</span></span></code></pre></div><p>为什么会这样呢？接下来我们就尝试搞清楚这个问题，并提供解决方案。</p><p>实际上，我们可以把 <code>obj.foo++</code> 这个自增操作分开来看，它相当于：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 语句</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   obj.foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj.foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p>在这个语句中，既会读取 <code>obj.foo</code> 的值，又会设置 <code>obj.foo</code> 的值，而这就是导致问题的根本原因。我们可以尝试推理一下代码的执行流程：首先读取 <code>obj.foo</code> 的值，这会触发 <code>track</code> 操作，将当前副作用函数收集到“桶”中，接着将其加 <code>1</code> 后再赋值给 <code>obj.foo</code>，此时会触发 <code>trigger</code> 操作，即把“桶”中的副作用函数取出并执行。但问题是该副作用函数正在执行中，还没有执行完毕，就要开始下一次的执行。这样会导致无限递归地调用自己，于是就产生了栈溢出。</p><p>解决办法并不难。通过分析这个问题我们能够发现，读取和设置操作是在同一个副作用函数内进行的。此时无论是 <code>track</code> 时收集的副作用函数，还是 <code>trigger</code> 时要触发执行的副作用函数，都是 <code>activeEffect</code>。基于此，我们可以在 <code>trigger</code> 动作发生时增加守卫条件：<strong>如果 <code>trigger</code> 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行</strong>，如以下代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> trigger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> depsMap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bucket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">depsMap) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> effects</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> depsMap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> effectsToRun</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   effects </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> effects.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">effectFn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (effectFn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> activeEffect) {  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新增</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       effectsToRun.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(effectFn)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   })</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   effectsToRun.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">effectFn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effectFn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // effects &amp;&amp; effects.forEach(effectFn =&gt; effectFn())</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>这样我们就能够避免无限递归调用，从而避免栈溢出。</p><h3 id="_4-8-计算属性-computed-与-lazy" tabindex="-1">4.8　计算属性 <code>computed</code> 与 <code>lazy</code> <a class="header-anchor" href="#_4-8-计算属性-computed-与-lazy" aria-label="Permalink to &quot;4.8　计算属性 `computed` 与 `lazy`&quot;">​</a></h3><p>当读取计算属性的值时，我们可以手动调用 <code>track</code> 函数进行追踪；当计算属性依赖的响应式数据发生变化时，我们可以手动调用 <code>trigger</code> 函数触发响应：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> computed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">getter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dirty </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> effectFn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(getter, {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     lazy: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     scheduler() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dirty) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         dirty </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 当计算属性依赖的响应式数据变化时，手动调用 trigger 函数触发响应</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         trigger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;value&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   })</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     get value() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (dirty) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effectFn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         dirty </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 当读取 value 时，手动调用 track 函数进行追踪</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       track</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;value&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>如以上代码所示，当读取一个计算属性的 <code>value</code> 值时，我们手动调用 <code>track</code> 函数，把计算属性返回的对象 <code>obj</code> 作为 <code>target</code>，同时作为第一个参数传递给 <code>track</code> 函数。当计算属性所依赖的响应式数据变化时，会执行调度器函数，在调度器函数内手动调用 <code>trigger</code> 函数触发响应即可。</p><h3 id="_4-9-watch-的实现原理" tabindex="-1">4.9　<code>watch</code> 的实现原理 <a class="header-anchor" href="#_4-9-watch-的实现原理" aria-label="Permalink to &quot;4.9　`watch` 的实现原理&quot;">​</a></h3><p>那么如何获得新值与旧值呢？这需要充分利用 <code>effect</code> 函数的 <code>lazy</code> 选项，如以下代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">source</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> getter</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;function&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     getter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     getter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> traverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(source)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 定义旧值与新值</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldValue, newValue</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到 effectFn 中以便后续手动调用</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> effectFn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       lazy: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       scheduler() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 在 scheduler 中重新执行副作用函数，得到的是新值</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         newValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effectFn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 将旧值和新值作为回调函数的参数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         cb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newValue, oldValue)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 更新旧值，不然下一次会得到错误的旧值</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         oldValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newValue</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   )</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 手动调用副作用函数，拿到的值就是旧值</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   oldValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> effectFn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>在这段代码中，最核心的改动是使用 <code>lazy</code> 选项创建了一个懒执行的 <code>effect</code>。注意上面代码中最下面的部分，我们手动调用 <code>effectFn</code> 函数得到的返回值就是旧值，即第一次执行得到的值。当变化发生并触发 <code>scheduler</code> 调度函数执行时，会重新调用 <code>effectFn</code> 函数并得到新值，这样我们就拿到了旧值与新值，接着将它们作为参数传递给回调函数 <code>cb</code> 就可以了。最后一件非常重要的事情是，不要忘记使用新值更新旧值：<code>oldValue = newValue</code>，否则在下一次变更发生时会得到错误的旧值。</p><h3 id="_4-11-过期的副作用" tabindex="-1">4.11　过期的副作用 <a class="header-anchor" href="#_4-11-过期的副作用" aria-label="Permalink to &quot;4.11　过期的副作用&quot;">​</a></h3><p>竞态问题通常在多进程或多线程编程中被提及，前端工程师可能很少讨论它，但在日常工作中你可能早就遇到过与竞态问题相似的场景，举个例子：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> finalData</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 发送并等待网络请求</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/path/to/request&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 将请求结果赋值给 data</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   finalData </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20250307013051705.png" alt="图 4-12"><strong>图 4-12　请求过期</strong></p><p><strong>图 4-12　请求过期</strong></p><h2 id="第-7-章-渲染器的设计" tabindex="-1">第 7 章　渲染器的设计 <a class="header-anchor" href="#第-7-章-渲染器的设计" aria-label="Permalink to &quot;第 7 章　渲染器的设计&quot;">​</a></h2><h3 id="_7-3-自定义渲染器" tabindex="-1">7.3　自定义渲染器 <a class="header-anchor" href="#_7-3-自定义渲染器" aria-label="Permalink to &quot;7.3　自定义渲染器&quot;">​</a></h3><p>自定义渲染器并不是“黑魔法”，它只是通过抽象的手段，让核心代码不再依赖平台特有的 API，再通过支持个性化配置的能力来实现跨平台。</p><h3 id="_7-4-总结" tabindex="-1">7.4　总结 <a class="header-anchor" href="#_7-4-总结" aria-label="Permalink to &quot;7.4　总结&quot;">​</a></h3><p>在本章中，我们首先介绍了渲染器与响应系统的关系。利用响应系统的能力，我们可以做到，当响应式数据变化时自动完成页面更新（或重新渲染）。同时我们注意到，这与渲染器的具体实现无关。我们实现了一个极简的渲染器，它只能利用 <code>innerHTML</code> 属性将给定的 HTML 字符串内容设置到容器中。</p><p>接着，我们讨论了与渲染器相关的基本名词和概念。渲染器的作用是把虚拟 DOM 渲染为特定平台上的真实元素，我们用英文 renderer 来表达渲染器。虚拟 DOM 通常用英文 virtual DOM 来表达，有时会简写成 <code>vdom</code> 或 <code>vnode</code>。渲染器会执行挂载和打补丁操作，对于新的元素，渲染器会将它挂载到容器内；对于新旧 <code>vnode</code> 都存在的情况，渲染器则会执行打补丁操作，即对比新旧 <code>vnode</code>，只更新变化的内容。</p><p>最后，我们讨论了自定义渲染器的实现。在浏览器平台上，渲染器可以利用 DOM API 完成 DOM 元素的创建、修改和删除。为了让渲染器不直接依赖浏览器平台特有的 API，我们将这些用来创建、修改和删除元素的操作抽象成可配置的对象。用户可以在调用 <code>createRenderer</code> 函数创建渲染器的时候指定自定义的配置对象，从而实现自定义的行为。我们还实现了一个用来打印渲染器操作流程的自定义渲染器，它不仅可以在浏览器中运行，还可以在 Node.js 中运行。</p><h2 id="第-8-章-挂载与更新" tabindex="-1">第 8 章　挂载与更新 <a class="header-anchor" href="#第-8-章-挂载与更新" aria-label="Permalink to &quot;第 8 章　挂载与更新&quot;">​</a></h2><h3 id="_8-1-挂载子节点和元素的属性" tabindex="-1">8.1　挂载子节点和元素的属性 <a class="header-anchor" href="#_8-1-挂载子节点和元素的属性" aria-label="Permalink to &quot;8.1　挂载子节点和元素的属性&quot;">​</a></h3><h3 id="_8-2-html-attributes-与-dom-properties" tabindex="-1">8.2　HTML Attributes 与 DOM Properties <a class="header-anchor" href="#_8-2-html-attributes-与-dom-properties" aria-label="Permalink to &quot;8.2　HTML Attributes 与 DOM Properties&quot;">​</a></h3><p>理解 HTML Attributes 和 DOM Properties 之间的差异和关联非常重要，这能够帮助我们合理地设计虚拟节点的结构，更是正确地为元素设置属性的关键。</p><p>我们从最基本的 HTML 说起。给出如下 HTML 代码：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;input id=&quot;my-input&quot; type=&quot;text&quot; value=&quot;foo&quot; /&gt;</span></span></code></pre></div><p>HTML Attributes 指的就是定义在 HTML 标签上的属性，这里指的就是 <code>id=&quot;my-input&quot;</code>、<code>type=&quot;text&quot;</code> 和 <code>value=&quot;foo&quot;</code>。当浏览器解析这段 HTML 代码后，会创建一个与之相符的 <code>DOM</code> 元素对象，我们可以通过 JavaScript 代码来读取该 DOM 对象：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const el = document.querySelector(&#39;#my-input&#39;)</span></span></code></pre></div><p>这个 DOM 对象会包含很多<strong>属性</strong>（properties），如图 8-1 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20250309132305234.png" alt="图 8-1"></p><p><strong>图 8-1　DOM 对象下的属性</strong></p><p>这些属性就是所谓的 DOM Properties。很多 HTML Attributes 在 DOM 对象上有与之同名的 DOM Properties，例如 <code>id=&quot;my-input&quot;</code> 对应 <code>el.id</code>，<code>type=&quot;text&quot;</code> 对应 <code>el.type</code>，<code>value=&quot;foo&quot;</code> 对应 <code>el.value</code> 等。但 DOM Properties 与 HTML Attributes 的名字不总是一模一样的，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div class=&quot;foo&quot;&gt;&lt;/div&gt;</span></span></code></pre></div><p><code>class=&quot;foo&quot;</code> 对应的 DOM Properties 则是 <code>el.className</code>。另外，并不是所有 HTML Attributes 都有与之对应的 DOM Properties，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div aria-valuenow=&quot;75&quot;&gt;&lt;/div&gt;</span></span></code></pre></div><p><code>aria-*</code> 类的 HTML Attributes 就没有与之对应的 DOM Properties。</p><p>类似地，也不是所有 DOM Properties 都有与之对应的 HTML Attributes，例如可以用 <code>el.textContent</code> 来设置元素的文本内容，但并没有与之对应的 HTML Attributes 来完成同样的工作。</p><p>HTML Attributes 的值与 DOM Properties 的值之间是有关联的，例如下面的 HTML 片段：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;</span></span></code></pre></div><p>这个片段描述了一个具有 <code>id</code> 属性的 <code>div</code> 标签。其中，<code>id=&quot;foo&quot;</code> 对应的 DOM Properties 是 <code>el.id</code>，并且值为字符串 <code>&#39;foo&#39;</code>。我们把这种 HTML Attributes 与 DOM Properties 具有相同名称（即 <code>id</code>）的属性看作直接映射。但并不是所有 HTML Attributes 与 DOM Properties 之间都是直接映射的关系，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;input value=&quot;foo&quot; /&gt;</span></span></code></pre></div><p>这是一个具有 <code>value</code> 属性的 <code>input</code> 标签。如果用户没有修改文本框的内容，那么通过 <code>el.value</code> 读取对应的 DOM Properties 的值就是字符串 <code>&#39;foo&#39;</code>。而如果用户修改了文本框的值，那么 <code>el.value</code> 的值就是当前文本框的值。例如，用户将文本框的内容修改为 <code>&#39;bar&#39;</code>，那么：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 console.log(el.value) // &#39;bar&#39;</span></span></code></pre></div><p>但如果运行下面的代码，会发生“奇怪”的现象：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 console.log(el.getAttribute(&#39;value&#39;)) // 仍然是 &#39;foo&#39;</span></span>
<span class="line"><span>02 console.log(el.value) // &#39;bar&#39;</span></span></code></pre></div><p>可以发现，用户对文本框内容的修改并不会影响 <code>el.getAttribute(&#39;value&#39;)</code> 的返回值，这个现象蕴含着 HTML Attributes 所代表的意义。实际上，HTML Attributes 的作用是设置与之对应的 DOM Properties 的初始值。一旦值改变，那么 DOM Properties 始终存储着当前值，而通过 <code>getAttribute</code> 函数得到的仍然是初始值。</p><p>但我们仍然可以通过 <code>el.defaultValue</code> 来访问初始值，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 el.getAttribute(&#39;value&#39;) // 仍然是 &#39;foo&#39;</span></span>
<span class="line"><span>02 el.value // &#39;bar&#39;</span></span>
<span class="line"><span>03 el.defaultValue // &#39;foo&#39;</span></span></code></pre></div><p>这说明一个 HTML Attributes 可能关联多个 DOM Properties。例如在上例中，<code>value=&quot;foo&quot;</code> 与 <code>el.value</code> 和 <code>el.defaultValue</code> 都有关联。</p><p>虽然我们可以认为 HTML Attributes 是用来设置与之对应的 DOM Properties 的初始值的，但有些值是受限制的，就好像浏览器内部做了默认值校验。如果你通过 HTML Attributes 提供的默认值不合法，那么浏览器会使用内建的合法值作为对应 DOM Properties 的默认值，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;input type=&quot;foo&quot; /&gt;</span></span></code></pre></div><p>我们知道，为 <code>&lt;input/&gt;</code> 标签的 <code>type</code> 属性指定字符串 <code>&#39;foo&#39;</code> 是不合法的，因此浏览器会矫正这个不合法的值。所以当我们尝试读取 <code>el.type</code> 时，得到的其实是矫正后的值，即字符串 <code>&#39;text&#39;</code>，而非字符串 <code>&#39;foo&#39;</code>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 console.log(el.type) // &#39;text&#39;</span></span></code></pre></div><p>从上述分析来看，HTML Attributes 与 DOM Properties 之间的关系很复杂，但其实我们只需要记住一个核心原则即可：<strong>HTML Attributes 的作用是设置与之对应的 DOM Properties 的初始值</strong>。</p><h3 id="_8-12-总结" tabindex="-1">8.12　总结 <a class="header-anchor" href="#_8-12-总结" aria-label="Permalink to &quot;8.12　总结&quot;">​</a></h3><p>在本章中，我们首先讨论了如何挂载子节点，以及节点的属性。对于子节点，只需要递归地调用 <code>patch</code> 函数完成挂载即可。而节点的属性比想象中的复杂，它涉及两个重要的概念：HTML Attributes 和 DOM Properties。为元素设置属性时，我们不能总是使用 <code>setAttribute</code> 函数，也不能总是通过元素的 DOM Properties 来设置。至于如何正确地为元素设置属性，取决于被设置属性的特点。例如，表单元素的 <code>el.form</code> 属性是只读的，因此只能使用 <code>setAttribute</code> 函数来设置。</p><p>接着，我们讨论了特殊属性的处理。以 <code>class</code> 为例，Vue.js 对 <code>class</code> 属性做了增强，它允许我们为 <code>class</code> 指定不同类型的值。但在把这些值设置给 DOM 元素之前，要对值进行正常化。我们还讨论了为元素设置 <code>class</code> 的三种方式及其性能情况。其中，<code>el.className</code> 的性能最优，所以我们选择在 <code>patchProps</code> 函数中使用 <code>el.className</code> 来完成 <code>class</code> 属性的设置。除了 <code>class</code> 属性之外，Vue.js 也对 <code>style</code> 属性做了增强，所以 <code>style</code> 属性也需要做类似的处理。</p><p>然后，我们讨论了卸载操作。一开始，我们直接使用 <code>innerHTML</code> 来清空容器元素，但是这样存在诸多问题。</p><ul><li>容器的内容可能是由某个或多个组件渲染的，当卸载操作发生时，应该正确地调用这些组件的 <code>beforeUnmount</code>、<code>unmounted</code> 等生命周期函数。</li><li>即使内容不是由组件渲染的，有的元素存在自定义指令，我们应该在卸载操作发生时正确地执行对应的指令钩子函数。</li><li>使用 <code>innerHTML</code> 清空容器元素内容的另一个缺陷是，它不会移除绑定在 DOM 元素上的事件处理函数。</li></ul><p>因此，我们不能直接使用 <code>innerHTML</code> 来完成卸载任务。为了解决这些问题，我们封装了 <code>unmount</code> 函数。该函数是以一个 <code>vnode</code> 的维度来完成卸载的，它会根据 <code>vnode.el</code> 属性取得该虚拟节点对应的真实 DOM，然后调用原生 DOM API 完成 DOM 元素的卸载。这样做还有两点额外的好处。</p><ul><li>在 <code>unmount</code> 函数内，我们有机会调用绑定在 DOM 元素上的指令钩子函数，例如 <code>beforeUnmount</code>、<code>unmounted</code> 等。</li><li>当 <code>unmount</code> 函数执行时，我们有机会检测虚拟节点 <code>vnode</code> 的类型。如果该虚拟节点描述的是组件，则我们也有机会调用组件相关的生命周期函数。</li></ul><p>而后，我们讨论了 <code>vnode</code> 类型的区分。渲染器在执行更新时，需要优先检查新旧 <code>vnode</code> 所描述的内容是否相同。只有当它们所描述的内容相同时，才有打补丁的必要。另外，即使它们描述的内容相同，我们也需要进一步检查它们的类型，即检查 <code>vnode.type</code> 属性值的类型，据此判断它描述的具体内容是什么。如果类型是字符串，则它描述的是普通标签元素，这时我们会调用 <code>mountElement</code> 和 <code>patchElement</code> 来完成挂载和打补丁；如果类型是对象，则它描述的是组件，这时需要调用 <code>mountComponent</code> 和 <code>patchComponent</code> 来完成挂载和打补丁。</p><p>我们还讲解了事件的处理。首先介绍了如何在虚拟节点中描述事件，我们把 <code>vnode.props</code> 对象中以字符串 <code>on</code> 开头的属性当作事件对待。接着，我们讲解了如何绑定和更新事件。在更新事件的时候，为了提升性能，我们伪造了 <code>invoker</code> 函数，并把真正的事件处理函数存储在 <code>invoker.value</code> 属性中，当事件需要更新时，只更新 <code>invoker.value</code> 的值即可，这样可以避免一次 <code>removeEventListener</code> 函数的调用。</p><p>我们还讲解了如何处理事件与更新时机的问题。解决方案是，利用事件处理函数被绑定到 DOM 元素的时间与事件触发时间之间的差异。我们需要<strong>屏蔽所有绑定时间晚于事件触发时间的事件处理函数的执行</strong>。</p><p>之后，我们讨论了子节点的更新。我们对虚拟节点中的 <code>children</code> 属性进行了规范化，规定 <code>vnode.children</code> 属性只能有如下三种类型。</p><ul><li>字符串类型：代表元素具有文本子节点。</li><li>数组类型：代表元素具有一组子节点。</li><li><code>null</code>：代表元素没有子节点。</li></ul><p>在更新时，新旧 <code>vnode</code> 的子节点都有可能是以上三种情况之一，所以在执行更新时一共要考虑九种可能，即图 8-5 所展示的那样。但落实到代码中，我们并不需要罗列所有情况。另外，当新旧 <code>vnode</code> 都具有一组子节点时，我们采用了比较笨的方式来完成更新，即卸载所有旧子节点，再挂载所有新子节点。更好的做法是，通过 Diff 算法比较新旧两组子节点，试图最大程度复用 DOM 元素。我们会在后续章节中详细讲解 Diff 算法的工作原理。</p><p>我们还讨论了如何使用虚拟节点来描述文本节点和注释节点。我们利用了 <code>symbol</code> 类型值的唯一性，为文本节点和注释节点分别创建唯一标识，并将其作为 <code>vnode.type</code> 属性的值。</p><p>最后，我们讨论了 <code>Fragment</code> 及其用途。渲染器渲染 <code>Fragment</code> 的方式类似于渲染普通标签，不同的是，<code>Fragment</code> 本身并不会渲染任何 DOM 元素。所以，只需要渲染一个 <code>Fragment</code> 的所有子节点即可。</p><h2 id="第-9-章-简单-diff-算法" tabindex="-1">第 9 章　简单 Diff 算法 <a class="header-anchor" href="#第-9-章-简单-diff-算法" aria-label="Permalink to &quot;第 9 章　简单 Diff 算法&quot;">​</a></h2><h3 id="_9-1-减少-dom-操作的性能开销" tabindex="-1">9.1　减少 DOM 操作的性能开销 <a class="header-anchor" href="#_9-1-减少-dom-操作的性能开销" aria-label="Permalink to &quot;9.1　减少 DOM 操作的性能开销&quot;">​</a></h3><p>图 9-1 是整个更新过程的示意图，其中<strong>菱形</strong>代表新子节点，<strong>矩形</strong>代表旧子节点，<strong>圆形</strong>代表真实 DOM 节点。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20250309170036467.png" alt="图 9-1"></p><p><strong>图 9-1　仅更新文本子节点</strong></p><p>这种做法虽然能够减少 DOM 操作次数，但问题也很明显。在上面的代码中，我们通过遍历旧的一组子节点，并假设新的一组子节点的数量与之相同，只有在这种情况下，这段代码才能正确地工作。但是，新旧两组子节点的数量未必相同。当新的一组子节点的数量少于旧的一组子节点的数量时，意味着有些节点在更新后应该被卸载，如图 9-2 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20250309170127137.png" alt="图 9-2"></p><p><strong>图 9-2　卸载已经不存在的节点</strong></p><p>在图 9-2 中，旧的一组子节点中一共有 4 个 <code>p</code> 标签，而新的一组子节点中只有 3 个 <code>p</code> 标签。这说明，在更新过程中，需要将不存在的 <code>p</code> 标签卸载。类似地，新的一组子节点的数量也可能比旧的一组子节点的数量多，如图 9-3 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20250309170304384.png" alt="图 9-3"></p><p><strong>图 9-3　挂载新的节点</strong></p><p>在图 9-3 中，新的一组子节点比旧的一组子节点多了一个 <code>p</code> 标签。在这种情况下，我们应该挂载新增节点。</p><p>通过上面的分析我们意识到，在进行新旧两组子节点的更新时，不应该总是遍历旧的一组子节点或遍历新的一组子节点，而是应该遍历其中长度较短的那一组。这样，我们才能够尽可能多地调用 <code>patch</code> 函数进行更新。接着，再对比新旧两组子节点的长度，如果新的一组子节点更长，则说明有新子节点需要挂载，否则说明有旧子节点需要卸载。最终实现如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> patchChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n2.children </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;string&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n2.children)) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n1.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n2.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 旧的一组子节点的长度</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldLen</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 新的一组子节点的长度</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newLen</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 两组子节点的公共长度，即两者中较短的那一组子节点的长度</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> commonLength</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">min</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldLen, newLen)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 遍历 commonLength 次</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> commonLength; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldChildren[i], newChildren[i], container)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 如果 newLen &gt; oldLen，说明有新子节点需要挂载</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (newLen </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldLen) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> commonLength; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newLen; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, newChildren[i], container)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (oldLen </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newLen) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 如果 oldLen &gt; newLen，说明有旧子节点需要卸载</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> commonLength; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldLen; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         unmount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldChildren[i])</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>这样，无论新旧两组子节点的数量关系如何，渲染器都能够正确地挂载或卸载它们。</p><h3 id="_9-2-dom-复用与-key-的作用" tabindex="-1">9.2　DOM 复用与 <code>key</code> 的作用 <a class="header-anchor" href="#_9-2-dom-复用与-key-的作用" aria-label="Permalink to &quot;9.2　DOM 复用与 `key` 的作用&quot;">​</a></h3><p>在上一节中，我们通过减少 DOM 操作的次数，提升了更新性能。但这种方式仍然存在可优化的空间。举个例子，假设新旧两组子节点的内容如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 // oldChildren</span></span>
<span class="line"><span>02 [</span></span>
<span class="line"><span>03   { type: &#39;p&#39; },</span></span>
<span class="line"><span>04   { type: &#39;div&#39; },</span></span>
<span class="line"><span>05   { type: &#39;span&#39; }</span></span>
<span class="line"><span>06 ]</span></span>
<span class="line"><span>07</span></span>
<span class="line"><span>08 // newChildren</span></span>
<span class="line"><span>09 [</span></span>
<span class="line"><span>10   { type: &#39;span&#39; },</span></span>
<span class="line"><span>11   { type: &#39;p&#39; },</span></span>
<span class="line"><span>12   { type: &#39;div&#39; }</span></span>
<span class="line"><span>13 ]</span></span></code></pre></div><p>如果使用上一节介绍的算法来完成上述两组子节点的更新，则需要 6 次 DOM 操作。</p><ul><li>调用 <code>patch</code> 函数在旧子节点 <code>{ type: &#39;p&#39; }</code> 与新子节点 <code>{ type: &#39;span&#39; }</code> 之间打补丁，由于两者是不同的标签，所以 <code>patch</code> 函数会卸载 <code>{ type: &#39;p&#39; }</code>，然后再挂载 <code>{ type: &#39;span&#39; }</code>，这需要执行 2 次 DOM 操作。</li><li>与第 1 步类似，卸载旧子节点 <code>{ type: &#39;div&#39; }</code>，然后再挂载新子节点 <code>{ type: &#39;p&#39; }</code>，这也需要执行 2 次 DOM 操作。</li><li>与第 1 步类似，卸载旧子节点 <code>{ type: &#39;span&#39; }</code>，然后再挂载新子节点 <code>{ type: &#39;div&#39; }</code>，同样需要执行 2 次 DOM 操作。</li></ul><p>因此，一共进行 6 次 DOM 操作才能完成上述案例的更新。但是，观察新旧两组子节点，很容易发现，二者只是顺序不同。所以最优的处理方式是，通过 DOM 的移动来完成子节点的更新，这要比不断地执行子节点的卸载和挂载性能更好。但是，想要通过 DOM 的移动来完成更新，必须要保证一个前提：新旧两组子节点中的确存在可复用的节点。这个很好理解，如果新的子节点没有在旧的一组子节点中出现，就无法通过移动节点的方式完成更新。所以现在问题变成了：应该如何确定新的子节点是否出现在旧的一组子节点中呢？拿上面的例子来说，怎么确定新的一组子节点中第 1 个子节点 <code>{ type: &#39;span&#39; }</code> 与旧的一组子节点中第 3 个子节点相同呢？一种解决方案是，通过 <code>vnode.type</code> 来判断，只要 <code>vnode.type</code> 的值相同，我们就认为两者是相同的节点。但这种方式并不可靠，思考如下例子：</p><div class="language-JS vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JS</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // oldChildren</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   { type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   { type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   { type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // newChildren</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   { type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   { type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   { type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ]</span></span></code></pre></div><p>观察上面两组子节点，我们发现，这个案例可以通过移动 DOM 的方式来完成更新。但是所有节点的 <code>vnode.type</code> 属性值都相同，这导致我们无法确定新旧两组子节点中节点的对应关系，也就无法得知应该进行怎样的 DOM 移动才能完成更新。这时，我们就需要引入额外的 <code>key</code> 来作为 <code>vnode</code> 的标识，如下面的代码所示：</p><div class="language-JS vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JS</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // oldChildren</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   { type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, key: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   { type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, key: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   { type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, key: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // newChildren</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   { type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, key: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   { type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, key: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   { type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, key: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ]</span></span></code></pre></div><p><code>key</code> 属性就像虚拟节点的“身份证”号，只要两个虚拟节点的 <code>type</code> 属性值和 <code>key</code> 属性值都相同，那么我们就认为它们是相同的，即可以进行 DOM 的复用。图 9-4 展示了有 <code>key</code> 和 无 <code>key</code> 时新旧两组子节点的映射情况。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20250309172633643.png" alt="图 9-4"></p><p><strong>图 9-4　有 <code>key</code> 与无 <code>key</code></strong></p><p>由图 9-4 可知，如果没有 <code>key</code>，我们无法知道新子节点与旧子节点间的映射关系，也就无法知道应该如何移动节点。有 <code>key</code> 的话情况则不同，我们根据子节点的 <code>key</code> 属性，能够明确知道新子节点在旧子节点中的位置，这样就可以进行相应的 DOM 移动操作了。</p><h3 id="_9-3-找到需要移动的元素" tabindex="-1">9.3　找到需要移动的元素 <a class="header-anchor" href="#_9-3-找到需要移动的元素" aria-label="Permalink to &quot;9.3　找到需要移动的元素&quot;">​</a></h3><p>我们再来看看另外一个例子，如图 9-6 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/050.jpg" alt="图 9-6"></p><p><strong>图 9-6　节点顺序变化</strong></p><p>同样，我们根据图 9-6 中给出的例子再次执行更新算法，看看这一次会有什么不同。</p><ul><li><p>第一步：取新的一组子节点中的第一个节点 <code>p-3</code>，它的 <code>key</code> 为 3。尝试在旧的一组子节点中找到具有相同 <code>key</code> 值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为 <code>2</code>。</p></li><li><p>第二步：取新的一组子节点中的第二个节点 <code>p-1</code>，它的 <code>key</code> 为 1。尝试在旧的一组子节点中找到具有相同 <code>key</code> 值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为 <code>0</code>。</p><p>到了这一步我们发现，索引值递增的顺序被打破了。节点 <code>p-1</code> 在旧 <code>children</code> 中的索引是 <code>0</code>，它小于节点 <code>p-3</code> 在旧 <code>children</code> 中的索引 <code>2</code>。这说明<strong>节点</strong> <code>p-1</code> <strong>在旧</strong> <code>children</code> <strong>中排在节点</strong> <code>p-3</code> <strong>前面，但在新的</strong> <code>children</code> <strong>中，它排在节点</strong> <code>p-3</code> <strong>后面</strong>。因此，我们能够得出一个结论：<strong>节点</strong> <code>p-1</code> <strong>对应的真实</strong> DOM <strong>需要移动</strong>。</p></li><li><p>第三步：取新的一组子节点中的第三个节点 <code>p-2</code>，它的 <code>key</code> 为 2。尝试在旧的一组子节点中找到具有相同 <code>key</code> 值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为 <code>1</code>。</p><p>到了这一步我们发现，节点 <code>p-2</code> 在旧 <code>children</code> 中的索引 <code>1</code> 要小于节点 <code>p-3</code> 在旧 <code>children</code> 中的索引 <code>2</code>。这说明，<strong>节点</strong> <code>p-2</code> <strong>在旧</strong> <code>children</code> <strong>中排在节点</strong> <code>p-3</code> <strong>前面，但在新的</strong> <code>children</code> <strong>中，它排在节点</strong> <code>p-3</code> <strong>后面。因此，节点</strong> <code>p-2</code> <strong>对应的真实</strong> DOM <strong>也需要移动</strong>。</p></li></ul><p>以上就是 Diff 算法在执行更新的过程中，判断节点是否需要移动的方式。在上面的例子中，我们得出了节点 <code>p-1</code> 和节点 <code>p-2</code> 需要移动的结论。这是因为它们在旧 <code>children</code> 中的索引要小于节点 <code>p-3</code> 在旧 <code>children</code> 中的索引。如果我们按照先后顺序记录在寻找节点过程中所遇到的位置索引，将会得到序列：<code>2</code>、<code>0</code>、<code>1</code>。可以发现，这个序列不具有递增的趋势。</p><p>其实我们可以将节点 <code>p-3</code> 在旧 <code>children</code> 中的索引定义为：<strong>在旧</strong> <code>children</code> <strong>中寻找具有相同</strong> <code>key</code> <strong>值节点的过程中，遇到的最大索引值</strong>。如果在后续寻找的过程中，存在索引值比当前遇到的最大索引值还要小的节点，则意味着该节点需要移动。</p><p>我们可以用 <code>lastIndex</code> 变量存储整个寻找过程中遇到的最大索引值，如下面的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> patchChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n2.children </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;string&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n2.children)) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n1.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n2.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 用来存储寻找过程中遇到的最大索引值</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newVNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[i]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldVNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren[j]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (newVNode.key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldVNode.key) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">           patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVNode, newVNode, container)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">           if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastIndex) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             // 如果当前找到的节点在旧 children 中的索引小于最大索引值 lastIndex，</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             // 说明该节点对应的真实 DOM 需要移动</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             // 如果当前找到的节点在旧 children 中的索引不小于最大索引值，</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             // 则更新 lastIndex 的值</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             lastIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">           break</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 这里需要 break</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>如以上代码及注释所示，如果新旧节点的 <code>key</code> 值相同，说明我们在旧 <code>children</code> 中找到了可复用 DOM 的节点。此时我们用该节点在旧 <code>children</code> 中的索引 <code>j</code> 与 <code>lastIndex</code> 进行比较，如果 <code>j</code> 小于 <code>lastIndex</code>，说明当前 <code>oldVNode</code> 对应的真实 DOM 需要移动，否则说明不需要移动。但此时应该将变量 <code>j</code> 的值赋给变量 <code>lastIndex</code>，以保证寻找节点的过程中，变量 <code>lastIndex</code> 始终存储着当前遇到的最大索引值。</p><p>现在，我们已经找到了需要移动的节点，下一节我们将讨论如何移动节点，从而完成节点顺序的更新。</p><h3 id="_9-4-如何移动元素" tabindex="-1">9.4　如何移动元素 <a class="header-anchor" href="#_9-4-如何移动元素" aria-label="Permalink to &quot;9.4　如何移动元素&quot;">​</a></h3><p>当更新操作发生时，渲染器会调用 <code>patchElement</code> 函数在新旧虚拟节点之间进行打补丁。回顾一下 <code>patchElement</code> 函数的代码，如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function patchElement(n1, n2) {</span></span>
<span class="line"><span>02   // 新的 vnode 也引用了真实 DOM 元素</span></span>
<span class="line"><span>03   const el = n2.el = n1.el</span></span>
<span class="line"><span>04   // 省略部分代码</span></span>
<span class="line"><span>05 }</span></span></code></pre></div><p>可以看到，<code>patchElement</code> 函数首先将旧节点的 <code>n1.el</code> 属性赋值给新节点的 <code>n2.el</code> 属性。这个赋值语句的真正含义其实就是 DOM 元素的<strong>复用</strong>。在复用了 DOM 元素之后，新节点也将持有对真实 DOM 的引用，如图 9-8 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/052.jpg" alt="img"></p><p><strong>图 9-8　使新的子节点也引用真实 DOM 元素</strong></p><p>可以看到，无论是新子节点还是旧子节点，都存在对真实 DOM 的引用，在此基础上，我们就可以进行 DOM 移动操作了。</p><p>为了阐述具体应该怎样移动 DOM 节点，我们仍然引用上一节的更新案例，如图 9-9 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/053.jpg" alt="图 9-9 "><strong>图 9-9　新旧子节点的关系</strong></p><p>它的更新步骤如下。</p><ul><li><p>第一步：取新的一组子节点中第一个节点 <code>p-3</code>，它的 <code>key</code> 为 3，尝试在旧的一组子节点中找到具有相同 <code>key</code> 值的可复用节点。发现能够找到，并且该节点在旧的一组子节点中的索引为 <code>2</code>。此时变量 <code>lastIndex</code> 的值为 <code>0</code>，索引 <code>2</code> 不小于 <code>0</code>，所以节点 <code>p-3</code> 对应的真实 DOM 不需要移动，但需要更新变量 <code>lastIndex</code> 的值为 <code>2</code>。</p></li><li><p>第二步：取新的一组子节点中第二个节点 <code>p-1</code>，它的 <code>key</code> 为 1，尝试在旧的一组子节点中找到具有相同 <code>key</code> 值的可复用节点。发现能够找到，并且该节点在旧的一组子节点中的索引为 <code>0</code>。此时变量 <code>lastIndex</code> 的值为 <code>2</code>，索引 <code>0</code> 小于 <code>2</code>，所以节点 <code>p-1</code> 对应的真实 DOM 需要移动。</p><p>到了这一步，我们发现，节点 <code>p-1</code> 对应的真实 DOM 需要移动，但应该移动到哪里呢？我们知道，<strong>新</strong> <code>children</code> <strong>的顺序其实就是更新后真实 DOM 节点应有的顺序</strong>。所以节点 <code>p-1</code> 在新 <code>children</code> 中的位置就代表了真实 DOM 更新后的位置。由于节点 <code>p-1</code> 在新 <code>children</code> 中排在节点 <code>p-3</code> 后面，所以我们应该<strong>把节点</strong> <code>p-1</code> <strong>所对应的真实</strong> DOM <strong>移动到节点</strong> <code>p-3</code> <strong>所对应的真实</strong> DOM <strong>后面</strong>。移动后的结果如图 9-10 所示。</p><p>可以看到，这样操作之后，此时真实 DOM 的顺序为 <code>p-2</code>、<code>p-3</code>、<code>p-1</code>。</p></li><li><p>第三步：取新的一组子节点中第三个节点 <code>p-2</code>，它的 <code>key</code> 为 2。尝试在旧的一组子节点中找到具有相同 <code>key</code> 值的可复用节点。发现能够找到，并且该节点在旧的一组子节点中的索引为 <code>1</code>。此时变量 <code>lastIndex</code> 的值为 <code>2</code>，索引 <code>1</code> 小于 <code>2</code>，所以节点 <code>p-2</code> 对应的真实 DOM 需要移动。</p></li></ul><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/054.jpg" alt="图 9-10"></p><p><strong>图 9-10　把节点 <code>p-1</code> 对应的真实 DOM 移动到节点 <code>p-3</code> 对应的真实 DOM 后面</strong></p><p>第三步与第二步类似，节点 <code>p-2</code> 对应的真实 DOM 也需要移动。同样，由于节点 <code>p-2</code> 在新 <code>children</code> 中排在节点 <code>p-1</code> 后面，所以我们应该把节点 <code>p-2</code> 对应的真实 DOM 移动到节点 <code>p-1</code> 对应的真实 DOM 后面。移动后的结果如图 9-11 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/055.jpg" alt="图 9-11 "></p><p><strong>图 9-11　把节点 <code>p-2</code> 对应的真实 DOM 移动到节点 <code>p-1</code> 对应的真实 DOM 后面</strong></p><p>经过这一步移动操作之后，我们发现，真实 DOM 的顺序与新的一组子节点的顺序相同了：<code>p-3</code>、<code>p-1</code>、<code>p-2</code>。至此，更新操作完成。</p><p>接下来，我们着手实现代码。其实并不复杂，如下面 <code>patchChildren</code> 函数的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> patchChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n2.children </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;string&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n2.children)) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n1.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n2.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newVNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[i]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j; j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldVNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren[j]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (newVNode.key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldVNode.key) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">           patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVNode, newVNode, container)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">           if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastIndex) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             // 代码运行到这里，说明 newVNode 对应的真实 DOM 需要移动</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             // 先获取 newVNode 的前一个 vnode，即 prevVNode</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">             const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> prevVNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             // 如果 prevVNode 不存在，则说明当前 newVNode 是第一个节点，它不需要移动</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">             if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (prevVNode) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               // 由于我们要将 newVNode 对应的真实 DOM 移动到 prevVNode 所对应真实 DOM 后面，</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               // 所以我们需要获取 prevVNode 所对应真实 DOM 的下一个兄弟节点，并将其作为锚点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">               const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> anchor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prevVNode.el.nextSibling</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               // 调用 insert 方法将 newVNode 对应的真实 DOM 插入到锚点元素前面，</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               // 也就是 prevVNode 对应真实 DOM 的后面</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">               insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newVNode.el, container, anchor)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             lastIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">           break</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">33</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">34</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">35</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">36</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">37</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">38</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">39</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">40</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>在上面这段代码中，如果条件 <code>j &lt; lastIndex</code> 成立，则说明当前 <code>newVNode</code> 所对应的真实 DOM 需要移动。根据前文的分析可知，我们需要获取当前 <code>newVNode</code> 节点的前一个虚拟节点，即 <code>newChildren[i - 1]</code>，然后使用 <code>insert</code> 函数完成节点的移动，其中 <code>insert</code> 函数依赖浏览器原生的 <code>insertBefore</code> 函数，如下面的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> renderer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createRenderer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   insert(el, parent, anchor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // insertBefore 需要锚点元素 anchor</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     parent.insertBefore(el, anchor)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><h3 id="_9-5-添加新元素" tabindex="-1">9.5　添加新元素 <a class="header-anchor" href="#_9-5-添加新元素" aria-label="Permalink to &quot;9.5　添加新元素&quot;">​</a></h3><p>本节我们将讨论添加新节点的情况，如图 9-12 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/056.jpg" alt="图 9-12"></p><p><strong>图 9-12　新增节点 <code>p-4</code></strong></p><p>观察图 9-12 可知，在新的一组子节点中，多出来一个节点 <code>p-4</code>，它的 <code>key</code> 值为 <code>4</code>，该节点在旧的一组子节点不存在，因此应该将其视为新增节点。对于新增节点，在更新时我们应该正确地将它挂载，这主要分为两步：</p><ul><li>想办法找到新增节点；</li><li>将新增节点挂载到正确位置。</li></ul><p>首先，我们来看一下如何找到新增节点。为了搞清楚这个问题，我们需要根据图 9-12 中给出的例子模拟执行简单 Diff 算法的逻辑。在此之前，我们需要弄清楚新旧两组子节点与真实 DOM 元素的当前状态，如图 9-13 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/057.jpg" alt="图 9-13"></p><p><strong>图 9-13　新旧两组子节点与真实 DOM 元素的当前状态</strong></p><p>接着，我们开始模拟执行简单 Diff 算法的更新逻辑。</p><ul><li><p>第一步：取新的一组子节点中第一个节点 <code>p-3</code>，它的 <code>key</code> 值为 3，尝试在旧的一组子节点中寻找可复用的节点。发现能够找到，并且该节点在旧的一组子节点中的索引值为 <code>2</code>。此时，变量 <code>lastIndex</code> 的值为 <code>0</code>，索引值 <code>2</code> 不小于 <code>lastIndex</code> 的值 <code>0</code>，所以节点 <code>p-3</code> 对应的真实 DOM 不需要移动，但是需要将变量 <code>lastIndex</code> 的值更新为 <code>2</code>。</p></li><li><p>第二步：取新的一组子节点中第二个节点 <code>p-1</code>，它的 <code>key</code> 值为 1，尝试在旧的一组子节点中寻找可复用的节点。发现能够找到，并且该节点在旧的一组子节点中的索引值为 <code>0</code>。此时变量 <code>lastIndex</code> 的值为 <code>2</code>，索引值 <code>0</code> 小于 <code>lastIndex</code> 的值 <code>2</code>，所以节点 <code>p-1</code> 对应的真实 DOM 需要移动，并且应该移动到节点 <code>p-3</code> 对应的真实 DOM 后面。经过这一步的移动操作后，真实 DOM 的状态如图 9-14 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/058.jpg" alt="图 9-14 "></p><p><strong>图 9-14　真实 DOM 的当前状态</strong></p><p>此时真实 DOM 的顺序为 <code>p-2</code>、<code>p-3</code>、<code>p-1</code>。</p></li><li><p>第三步：取新的一组子节点中第三个节点 <code>p-4</code>，它的 <code>key</code> 值为 4，尝试在旧的一组子节点中寻找可复用的节点。由于在旧的一组子节点中，没有 <code>key</code> 值为 4 的节点，因此渲染器会把节点 <code>p-4</code> 看作新增节点并挂载它。那么，应该将它挂载到哪里呢？为了搞清楚这个问题，我们需要观察节点 <code>p-4</code> 在新的一组子节点中的位置。由于节点 <code>p-4</code> 出现在节点 <code>p-1</code> 后面，所以我们应该把节点 <code>p-4</code> 挂载到节点 <code>p-1</code> 所对应的真实 DOM 后面。在经过这一步挂载操作之后，真实 DOM 的状态如图 9-15 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/059.jpg" alt="图 9-15"></p><p><strong>图 9-15　真实 DOM 的当前状态</strong></p><p>此时真实 DOM 的顺序是：<code>p-2</code>、<code>p-3</code>、<code>p-1</code>、<code>p-4</code>，其中 <code>p-4</code> 是刚刚挂载的。</p></li><li><p>第四步：取新的一组子节点中第四个节点 <code>p-2</code>，它的 <code>key</code> 值为 2，尝试在旧的一组子节点中寻找可复用的节点。发现能够找到，并且该节点在旧的一组子节点中的索引值为 <code>1</code>。此时变量 <code>lastIndex</code> 的值为 <code>2</code>，索引值 <code>1</code> 小于 <code>lastIndex</code> 的值 <code>2</code>，所以节点 <code>p-2</code> 对应的真实 DOM 需要移动，并且应该移动到节点 <code>p-4</code> 对应的真实 DOM 后面。经过这一步移动操作后，真实 DOM 的状态如图 9-16 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/060.jpg" alt="图 9-16"></p><p><strong>图 9-16　真实 DOM 的当前状态</strong></p></li></ul><p>此时真实 DOM 的顺序是：<code>p-3</code>、<code>p-1</code>、<code>p-4</code>、<code>p-2</code>。至此，真实 DOM 的顺序已经与新的一组子节点的顺序相同了，更新完成。</p><p>接下来，我们着手实现代码，如下面 <code>patchChildren</code> 函数的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> patchChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n2.children </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;string&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n2.children)) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n1.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n2.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newVNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[i]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 在第一层循环中定义变量 find，代表是否在旧的一组子节点中找到可复用的节点，</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 初始值为 false，代表没找到</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> find </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j; j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldVNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren[j]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (newVNode.key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldVNode.key) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // 一旦找到可复用的节点，则将变量 find 的值设为 true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           find </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">           patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVNode, newVNode, container)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">           if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastIndex) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">             const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> prevVNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">             if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (prevVNode) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">               const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> anchor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prevVNode.el.nextSibling</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">               insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newVNode.el, container, anchor)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             lastIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">           break</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">33</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 如果代码运行到这里，find 仍然为 false，</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">34</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 说明当前 newVNode 没有在旧的一组子节点中找到可复用的节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">35</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 也就是说，当前 newVNode 是新增节点，需要挂载</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">36</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">find) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">37</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 为了将节点挂载到正确位置，我们需要先获取锚点元素</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">38</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 首先获取当前 newVNode 的前一个 vnode 节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">39</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> prevVNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">40</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> anchor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">41</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (prevVNode) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // 如果有前一个 vnode 节点，则使用它的下一个兄弟节点作为锚点元素</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">43</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           anchor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prevVNode.el.nextSibling</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">44</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">45</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // 如果没有前一个 vnode 节点，说明即将挂载的新节点是第一个子节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">46</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // 这时我们使用容器元素的 firstChild 作为锚点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">47</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           anchor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> container.firstChild</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">48</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">49</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 挂载 newVNode</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, newVNode, container, anchor)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">51</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">52</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">53</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">54</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">55</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">56</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">57</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>观察上面这段代码。首先，我们在外层循环中定义了名为 <code>find</code> 的变量，它代表渲染器能否在旧的一组子节点中找到可复用的节点。变量 <code>find</code> 的初始值为 <code>false</code>，一旦寻找到可复用的节点，则将变量 <code>find</code> 的值设置为 <code>true</code>。如果内层循环结束后，变量 <code>find</code> 的值仍然为 <code>false</code>，则说明当前 <code>newVNode</code> 是一个全新的节点，需要挂载它。为了将节点挂载到正确位置，我们需要先获取锚点元素：找到 <code>newVNode</code> 的前一个虚拟节点，即 <code>prevVNode</code>，如果存在，则使用它对应的真实 DOM 的下一个兄弟节点作为锚点元素；如果不存在，则说明即将挂载的 <code>newVNode</code> 节点是容器元素的第一个子节点，此时应该使用容器元素的 <code>container.firstChild</code> 作为锚点元素。最后，将锚点元素 <code>anchor</code> 作为 <code>patch</code> 函数的第四个参数，调用 <code>patch</code> 函数完成节点的挂载。</p><p>但由于目前实现的 <code>patch</code> 函数还不支持传递第四个参数，所以我们需要调整 <code>patch</code> 函数的代码，如下所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // patch 函数需要接收第四个参数，即锚点元素</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">anchor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;string&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n1) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 挂载时将锚点元素作为第三个参数传递给 mountElement 函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       mountElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n2, container, anchor)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       patchElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n1, n2)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Text) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Fragment) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // mountElement 函数需要增加第三个参数，即锚点元素</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mountElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vnode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">anchor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 在插入节点时，将锚点元素透传给 insert 函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(el, container, anchor)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><h3 id="_9-6-移除不存在的元素" tabindex="-1">9.6　移除不存在的元素 <a class="header-anchor" href="#_9-6-移除不存在的元素" aria-label="Permalink to &quot;9.6　移除不存在的元素&quot;">​</a></h3><p>在更新子节点时，不仅会遇到新增元素，还会出现元素被删除的情况，如图 9-17 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/061.jpg" alt="图 9-17"></p><p><strong>图 9-17　节点被删除的情况</strong></p><p>在新的一组子节点中，节点 <code>p-2</code> 已经不存在了，这说明该节点被删除了。渲染器应该能找到那些需要删除的节点并正确地将其删除。</p><p>具体要如何做呢？首先，我们来讨论如何找到需要删除的节点。以图 9-17 为例，我们来分析它的更新步骤。在模拟执行更新逻辑之前，我们需要清楚新旧两组子节点以及真实 DOM 节点的当前状态，如图 9-18 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/062.jpg" alt="图 9-18"></p><p><strong>图 9-18　新旧两组子节点与真实 DOM 节点的当前状态</strong></p><p>接着，我们开始模拟执行更新的过程。</p><ul><li>第一步：取新的一组子节点中的第一个节点 <code>p-3</code>，它的 <code>key</code> 值为 3。尝试在旧的一组子节点中寻找可复用的节点。发现能够找到，并且该节点在旧的一组子节点中的索引值为 <code>2</code>。此时变量 <code>lastIndex</code> 的值为 <code>0</code>，索引 <code>2</code> 不小于 <code>lastIndex</code> 的值 <code>0</code>，所以节点 <code>p-3</code> 对应的真实 DOM 不需要移动，但需要更新变量 <code>lastIndex</code> 的值为 <code>2</code>。</li><li>第二步：取新的一组子节点中的第二个节点 <code>p-1</code>，它的 <code>key</code> 值为 1。尝试在旧的一组子节点中寻找可复用的节点。发现能够找到，并且该节点在旧的一组子节点中的索引值为 <code>0</code>。此时变量 <code>lastIndex</code> 的值为 <code>2</code>，索引 <code>0</code> 小于 <code>lastIndex</code> 的值 <code>2</code>，所以节点 <code>p-1</code> 对应的真实 DOM 需要移动，并且应该移动到节点 <code>p-3</code> 对应的真实 DOM 后面。经过这一步的移动操作后，真实 DOM 的状态如图 9-19 所示。</li></ul><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/063.jpg" alt="图 9-19"></p><p><strong>图 9-19　真实 DOM 的当前状态</strong></p><p>至此，更新结束。我们发现，节点 <code>p-2</code> 对应的真实 DOM 仍然存在，所以需要增加额外的逻辑来删除遗留节点。思路很简单，当基本的更新结束时，我们需要遍历旧的一组子节点，然后去新的一组子节点中寻找具有相同 <code>key</code> 值的节点。如果找不到，则说明应该删除该节点，如下面 <code>patchChildren</code> 函数的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function patchChildren(n1, n2, container) {</span></span>
<span class="line"><span>02   if (typeof n2.children === &#39;string&#39;) {</span></span>
<span class="line"><span>03     // 省略部分代码</span></span>
<span class="line"><span>04   } else if (Array.isArray(n2.children)) {</span></span>
<span class="line"><span>05     const oldChildren = n1.children</span></span>
<span class="line"><span>06     const newChildren = n2.children</span></span>
<span class="line"><span>07</span></span>
<span class="line"><span>08     let lastIndex = 0</span></span>
<span class="line"><span>09     for (let i = 0; i &lt; newChildren.length; i++) {</span></span>
<span class="line"><span>10       // 省略部分代码</span></span>
<span class="line"><span>11     }</span></span>
<span class="line"><span>12</span></span>
<span class="line"><span>13     // 上一步的更新操作完成后</span></span>
<span class="line"><span>14     // 遍历旧的一组子节点</span></span>
<span class="line"><span>15     for (let i = 0; i &lt; oldChildren.length; i++) {</span></span>
<span class="line"><span>16       const oldVNode = oldChildren[i]</span></span>
<span class="line"><span>17       // 拿旧子节点 oldVNode 去新的一组子节点中寻找具有相同 key 值的节点</span></span>
<span class="line"><span>18       const has = newChildren.find(</span></span>
<span class="line"><span>19         vnode =&gt; vnode.key === oldVNode.key</span></span>
<span class="line"><span>20       )</span></span>
<span class="line"><span>21       if (!has) {</span></span>
<span class="line"><span>22         // 如果没有找到具有相同 key 值的节点，则说明需要删除该节点</span></span>
<span class="line"><span>23         // 调用 unmount 函数将其卸载</span></span>
<span class="line"><span>24         unmount(oldVNode)</span></span>
<span class="line"><span>25       }</span></span>
<span class="line"><span>26     }</span></span>
<span class="line"><span>27</span></span>
<span class="line"><span>28   } else {</span></span>
<span class="line"><span>29     // 省略部分代码</span></span>
<span class="line"><span>30   }</span></span>
<span class="line"><span>31 }</span></span></code></pre></div><p>如以上代码及注释所示，在上一步的更新操作完成之后，我们还需要遍历旧的一组子节点，目的是检查旧子节点在新的一组子节点中是否仍然存在，如果已经不存在了，则调用 <code>unmount</code> 函数将其卸载。</p><h3 id="_9-7-总结" tabindex="-1">9.7　总结 <a class="header-anchor" href="#_9-7-总结" aria-label="Permalink to &quot;9.7　总结&quot;">​</a></h3><p>在本章中，我们首先讨论了 Diff 算法的作用。Diff 算法用来计算两组子节点的差异，并试图最大程度地复用 DOM 元素。在上一章中，我们采用了一种简单的方式来更新子节点，即卸载所有旧子节点，再挂载所有新子节点。然而这种更新方式无法对 DOM 元素进行复用，需要大量的 DOM 操作才能完成更新，非常消耗性能。于是，我们对它进行了改进。改进后的方案是，遍历新旧两组子节点中数量较少的那一组，并逐个调用 <code>patch</code> 函数进行打补丁，然后比较新旧两组子节点的数量，如果新的一组子节点数量更多，说明有新子节点需要挂载；否则说明在旧的一组子节点中，有节点需要卸载。</p><p>然后，我们讨论了虚拟节点中 <code>key</code> 属性的作用，它就像虚拟节点的“身份证号”。在更新时，渲染器通过 <code>key</code> 属性找到可复用的节点，然后尽可能地通过 DOM 移动操作来完成更新，避免过多地对 DOM 元素进行销毁和重建。</p><p>接着，我们讨论了简单 Diff 算法是如何寻找需要移动的节点的。简单 Diff 算法的核心逻辑是，拿新的一组子节点中的节点去旧的一组子节点中寻找可复用的节点。如果找到了，则记录该节点的位置索引。我们把这个位置索引称为最大索引。在整个更新过程中，如果一个节点的索引值小于最大索引，则说明该节点对应的真实 DOM 元素需要移动。</p><p>最后，我们通过几个例子讲解了渲染器是如何移动、添加、删除虚拟节点所对应的 DOM 元素的。</p><h2 id="第-10-章-双端-diff-算法" tabindex="-1">第 10 章　双端 Diff 算法 <a class="header-anchor" href="#第-10-章-双端-diff-算法" aria-label="Permalink to &quot;第 10 章　双端 Diff 算法&quot;">​</a></h2><h3 id="_10-1-双端比较的原理" tabindex="-1">10.1　双端比较的原理 <a class="header-anchor" href="#_10-1-双端比较的原理" aria-label="Permalink to &quot;10.1　双端比较的原理&quot;">​</a></h3><p>简单 Diff 算法的问题在于，它对 DOM 的移动操作并不是最优的。我们拿上一章的例子来看，如图 10-1 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/064.jpg" alt="图 10-1"></p><p><strong>图 10-1　新旧两组子节点及索引</strong></p><p>在这个例子中，如果使用简单 Diff 算法来更新它，则会发生两次 DOM 移动操作，如图 10-2 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/065.jpg" alt="图 10-2"></p><p><strong>图 10-2　两次 DOM 移动操作完成更新</strong></p><p>第一次 DOM 移动操作会将真实 DOM 节点 <code>p-1</code> 移动到真实 DOM 节点 <code>p-3</code> 后面。第二次移动操作会将真实 DOM 节点 <code>p-2</code> 移动到真实 DOM 节点 <code>p-1</code> 后面。最终，真实 DOM 节点的顺序与新的一组子节点顺序一致：<code>p-3</code>、<code>p-1</code>、<code>p-2</code>。</p><p>然而，上述更新过程并非最优解。在这个例子中，其实只需要通过一步 DOM 节点的移动操作即可完成更新，即只需要把真实 DOM 节点 <code>p-3</code> 移动到真实 DOM 节点 <code>p-1</code> 前面，如图 10-3 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/066.jpg" alt="图 10-3 "></p><p><strong>图 10-3　把真实 DOM 节点 <code>p-3</code> 移动到真实 DOM 节点 <code>p-1</code> 前面</strong></p><p>可以看到，理论上只需要一次 DOM 移动操作即可完成更新。但简单 Diff 算法做不到这一点，不过本章我们要介绍的双端 Diff 算法可以做到。接下来，我们就来讨论双端 Diff 算法的原理。</p><p>顾名思义，双端 Diff 算法是一种同时对新旧两组子节点的两个端点进行比较的算法。因此，我们需要四个索引值，分别指向新旧两组子节点的端点，如图 10-4 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/067.jpg" alt="图 10-4"></p><p><strong>图 10-4　四个索引值，分别指向新旧两组子节点的端点</strong></p><p>用代码来表达四个端点，如下面 <code>patchChildren</code> 和 <code>patchKeyedChildren</code> 函数的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function patchChildren(n1, n2, container) {</span></span>
<span class="line"><span>02   if (typeof n2.children === &#39;string&#39;) {</span></span>
<span class="line"><span>03     // 省略部分代码</span></span>
<span class="line"><span>04   } else if (Array.isArray(n2.children)) {</span></span>
<span class="line"><span>05     // 封装 patchKeyedChildren 函数处理两组子节点</span></span>
<span class="line"><span>06     patchKeyedChildren(n1, n2, container)</span></span>
<span class="line"><span>07   } else {</span></span>
<span class="line"><span>08     // 省略部分代码</span></span>
<span class="line"><span>09   }</span></span>
<span class="line"><span>10 }</span></span>
<span class="line"><span>11</span></span>
<span class="line"><span>12 function patchKeyedChildren(n1, n2, container) {</span></span>
<span class="line"><span>13   const oldChildren = n1.children</span></span>
<span class="line"><span>14   const newChildren = n2.children</span></span>
<span class="line"><span>15   // 四个索引值</span></span>
<span class="line"><span>16   let oldStartIdx = 0</span></span>
<span class="line"><span>17   let oldEndIdx = oldChildren.length - 1</span></span>
<span class="line"><span>18   let newStartIdx = 0</span></span>
<span class="line"><span>19   let newEndIdx = newChildren.length - 1</span></span>
<span class="line"><span>20 }</span></span></code></pre></div><p>在上面这段代码中，我们将两组子节点的打补丁工作封装到了 <code>patchKeyedChildren</code> 函数中。在该函数内，首先获取新旧两组子节点 <code>oldChildren</code> 和 <code>newChildren</code>，接着创建四个索引值，分别指向新旧两组子节点的头和尾，即 <code>oldStartIdx</code>、<code>oldEndIdx</code>、<code>newStartIdx</code> 和 <code>newEndIdx</code>。有了索引后，就可以找到它所指向的虚拟节点了，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function patchKeyedChildren(n1, n2, container) {</span></span>
<span class="line"><span>02   const oldChildren = n1.children</span></span>
<span class="line"><span>03   const newChildren = n2.children</span></span>
<span class="line"><span>04   // 四个索引值</span></span>
<span class="line"><span>05   let oldStartIdx = 0</span></span>
<span class="line"><span>06   let oldEndIdx = oldChildren.length - 1</span></span>
<span class="line"><span>07   let newStartIdx = 0</span></span>
<span class="line"><span>08   let newEndIdx = newChildren.length - 1</span></span>
<span class="line"><span>09   // 四个索引指向的 vnode 节点</span></span>
<span class="line"><span>10   let oldStartVNode = oldChildren[oldStartIdx]</span></span>
<span class="line"><span>11   let oldEndVNode = oldChildren[oldEndIdx]</span></span>
<span class="line"><span>12   let newStartVNode = newChildren[newStartIdx]</span></span>
<span class="line"><span>13   let newEndVNode = newChildren[newEndIdx]</span></span>
<span class="line"><span>14 }</span></span></code></pre></div><p>其中，<code>oldStartVNode</code> 和 <code>oldEndVNode</code> 是旧的一组子节点中的第一个节点和最后一个节点，<code>newStartVNode</code> 和 <code>newEndVNode</code> 则是新的一组子节点的第一个节点和最后一个节点。有了这些信息之后，我们就可以开始进行双端比较了。怎么比较呢？如图 10-5 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/068.jpg" alt="图 10-5 "></p><p><strong>图 10-5　双端比较的方式</strong></p><p>在双端比较中，每一轮比较都分为四个步骤，如图 10-5 中的连线所示。</p><ul><li>第一步：比较旧的一组子节点中的第一个子节点 <code>p-1</code> 与新的一组子节点中的第一个子节点 <code>p-4</code>，看看它们是否相同。由于两者的 <code>key</code> 值不同，因此不相同，不可复用，于是什么都不做。</li><li>第二步：比较旧的一组子节点中的最后一个子节点 <code>p-4</code> 与新的一组子节点中的最后一个子节点 <code>p-3</code>，看看它们是否相同。由于两者的 <code>key</code> 值不同，因此不相同，不可复用，于是什么都不做。</li><li>第三步：比较旧的一组子节点中的第一个子节点 <code>p-1</code> 与新的一组子节点中的最后一个子节点 <code>p-3</code>，看看它们是否相同。由于两者的 <code>key</code> 值不同，因此不相同，不可复用，于是什么都不做。</li><li>第四步：比较旧的一组子节点中的最后一个子节点 <code>p-4</code> 与新的一组子节点中的第一个子节点 <code>p-4</code>。由于它们的 <code>key</code> 值相同，因此可以进行 DOM 复用。</li></ul><p>可以看到，我们在第四步时找到了相同的节点，这说明它们对应的真实 DOM 节点可以复用。对于可复用的 DOM 节点，我们只需要通过 DOM 移动操作完成更新即可。那么应该如何移动 DOM 元素呢？为了搞清楚这个问题，我们需要分析第四步比较过程中的细节。我们注意到，第四步是比较旧的一组子节点的最后一个子节点与新的一组子节点的第一个子节点，发现两者相同。这说明：<strong>节点</strong> <code>p-4</code> <strong>原本是最后一个子节点，但在新的顺序中，它变成了第一个子节点</strong>。换句话说，节点 <code>p-4</code> 在更新之后应该是第一个子节点。对应到程序的逻辑，可以将其翻译为：<strong>将索引</strong> <code>oldEndIdx</code> <strong>指向的虚拟节点所对应的真实 DOM 移动到索引</strong> <code>oldStartIdx</code> <strong>指向的虚拟节点所对应的真实 DOM 前面</strong>。如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function patchKeyedChildren(n1, n2, container) {</span></span>
<span class="line"><span>02   const oldChildren = n1.children</span></span>
<span class="line"><span>03   const newChildren = n2.children</span></span>
<span class="line"><span>04   // 四个索引值</span></span>
<span class="line"><span>05   let oldStartIdx = 0</span></span>
<span class="line"><span>06   let oldEndIdx = oldChildren.length - 1</span></span>
<span class="line"><span>07   let newStartIdx = 0</span></span>
<span class="line"><span>08   let newEndIdx = newChildren.length - 1</span></span>
<span class="line"><span>09   // 四个索引指向的 vnode 节点</span></span>
<span class="line"><span>10   let oldStartVNode = oldChildren[oldStartIdx]</span></span>
<span class="line"><span>11   let oldEndVNode = oldChildren[oldEndIdx]</span></span>
<span class="line"><span>12   let newStartVNode = newChildren[newStartIdx]</span></span>
<span class="line"><span>13   let newEndVNode = newChildren[newEndIdx]</span></span>
<span class="line"><span>14</span></span>
<span class="line"><span>15   if (oldStartVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>16     // 第一步：oldStartVNode 和 newStartVNode 比较</span></span>
<span class="line"><span>17   } else if (oldEndVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>18     // 第二步：oldEndVNode 和 newEndVNode 比较</span></span>
<span class="line"><span>19   } else if (oldStartVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>20     // 第三步：oldStartVNode 和 newEndVNode 比较</span></span>
<span class="line"><span>21   } else if (oldEndVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>22     // 第四步：oldEndVNode 和 newStartVNode 比较</span></span>
<span class="line"><span>23     // 仍然需要调用 patch 函数进行打补丁</span></span>
<span class="line"><span>24     patch(oldEndVNode, newStartVNode, container)</span></span>
<span class="line"><span>25     // 移动 DOM 操作</span></span>
<span class="line"><span>26     // oldEndVNode.el 移动到 oldStartVNode.el 前面</span></span>
<span class="line"><span>27     insert(oldEndVNode.el, container, oldStartVNode.el)</span></span>
<span class="line"><span>28</span></span>
<span class="line"><span>29     // 移动 DOM 完成后，更新索引值，并指向下一个位置</span></span>
<span class="line"><span>30     oldEndVNode = oldChildren[--oldEndIdx]</span></span>
<span class="line"><span>31     newStartVNode = newChildren[++newStartIdx]</span></span>
<span class="line"><span>32   }</span></span>
<span class="line"><span>33 }</span></span></code></pre></div><p>在这段代码中，我们增加了一系列的 <code>if...else if...</code> 语句，用来实现四个索引指向的虚拟节点之间的比较。拿上例来说，在第四步中，我们找到了具有相同 <code>key</code> 值的节点。这说明，原来处于尾部的节点在新的顺序中应该处于头部。于是，我们只需要以头部元素 <code>oldStartVNode.el</code> 作为锚点，将尾部元素 <code>oldEndVNode.el</code> 移动到锚点前面即可。但需要注意的是，在进行 DOM 的移动操作之前，仍然需要调用 <code>patch</code> 函数在新旧虚拟节点之间打补丁。</p><p>在这一步 DOM 的移动操作完成后，接下来是比较关键的步骤，即更新索引值。由于第四步中涉及的两个索引分别是 <code>oldEndIdx</code> 和 <code>newStartIdx</code>，所以我们需要更新两者的值，让它们各自朝正确的方向前进一步，并指向下一个节点。图 10-6 给出了更新前新旧两组子节点以及真实 DOM 节点的状态。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/069.jpg" alt="图 10-6"></p><p><strong>图 10-6　新旧两组子节点以及真实 DOM 节点的状态</strong></p><p>图 10-7 给出了在第四步的比较中，第一步 DOM 移动操作完成后，新旧两组子节点以及真实 DOM 节点的状态。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/070.jpg" alt="图 10-7"></p><p><strong>图 10-7　新旧两组子节点以及真实 DOM 节点的状态</strong></p><p>此时，真实 DOM 节点顺序为 <code>p-4</code>、<code>p-1</code>、<code>p-2</code>、<code>p-3</code>，这与新的一组子节点顺序不一致。这是因为 Diff 算法还没有结束，还需要进行下一轮更新。因此，我们需要将更新逻辑封装到一个 <code>while</code> 循环中，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {</span></span>
<span class="line"><span>02   if (oldStartVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>03     // 步骤一：oldStartVNode 和 newStartVNode 比较</span></span>
<span class="line"><span>04   } else if (oldEndVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>05     // 步骤二：oldEndVNode 和 newEndVNode 比较</span></span>
<span class="line"><span>06   } else if (oldStartVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>07     // 步骤三：oldStartVNode 和 newEndVNode 比较</span></span>
<span class="line"><span>08   } else if (oldEndVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>09     // 步骤四：oldEndVNode 和 newStartVNode 比较</span></span>
<span class="line"><span>10     // 仍然需要调用 patch 函数进行打补丁</span></span>
<span class="line"><span>11     patch(oldEndVNode, newStartVNode, container)</span></span>
<span class="line"><span>12     // 移动 DOM 操作</span></span>
<span class="line"><span>13     // oldEndVNode.el 移动到 oldStartVNode.el 前面</span></span>
<span class="line"><span>14     insert(oldEndVNode.el, container, oldStartVNode.el)</span></span>
<span class="line"><span>15</span></span>
<span class="line"><span>16     // 移动 DOM 完成后，更新索引值，指向下一个位置</span></span>
<span class="line"><span>17     oldEndVNode = oldChildren[--oldEndIdx]</span></span>
<span class="line"><span>18     newStartVNode = newChildren[++newStartIdx]</span></span>
<span class="line"><span>19   }</span></span>
<span class="line"><span>20 }</span></span></code></pre></div><p>由于在每一轮更新完成之后，紧接着都会更新四个索引中与当前更新轮次相关联的索引，所以整个 <code>while</code> 循环执行的条件是：头部索引值要小于等于尾部索引值。</p><p>在第一轮更新结束后循环条件仍然成立，因此需要进行下一轮的比较，如图 10-7 所示。</p><ul><li><p>第一步：比较旧的一组子节点中的头部节点 <code>p-1</code> 与新的一组子节点中的头部节点 <code>p-2</code>，看看它们是否相同。由于两者的 <code>key</code> 值不同，不可复用，所以什么都不做。</p><p>这里，我们使用了新的名词：<strong>头部节点</strong>。它指的是头部索引 <code>oldStartIdx</code> 和 <code>newStartIdx</code> 所指向的节点。</p></li><li><p>第二步：比较旧的一组子节点中的尾部节点 <code>p-3</code> 与新的一组子节点中的尾部节点 <code>p-3</code>，两者的 <code>key</code> 值相同，可以复用。另外，由于两者都处于尾部，因此不需要对真实 DOM 进行移动操作，只需要打补丁即可，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {</span></span>
<span class="line"><span>02   if (oldStartVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>03     // 步骤一：oldStartVNode 和 newStartVNode 比较</span></span>
<span class="line"><span>04   } else if (oldEndVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>05     // 步骤二：oldEndVNode 和 newEndVNode 比较</span></span>
<span class="line"><span>06     // 节点在新的顺序中仍然处于尾部，不需要移动，但仍需打补丁</span></span>
<span class="line"><span>07     patch(oldEndVNode, newEndVNode, container)</span></span>
<span class="line"><span>08     // 更新索引和头尾部节点变量</span></span>
<span class="line"><span>09     oldEndVNode = oldChildren[--oldEndIdx]</span></span>
<span class="line"><span>10     newEndVNode = newChildren[--newEndIdx]</span></span>
<span class="line"><span>11   } else if (oldStartVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>12     // 步骤三：oldStartVNode 和 newEndVNode 比较</span></span>
<span class="line"><span>13   } else if (oldEndVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>14     // 步骤四：oldEndVNode 和 newStartVNode 比较</span></span>
<span class="line"><span>15     patch(oldEndVNode, newStartVNode, container)</span></span>
<span class="line"><span>16     insert(oldEndVNode.el, container, oldStartVNode.el)</span></span>
<span class="line"><span>17     oldEndVNode = oldChildren[--oldEndIdx]</span></span>
<span class="line"><span>18     newStartVNode = newChildren[++newStartIdx]</span></span>
<span class="line"><span>19   }</span></span>
<span class="line"><span>20 }</span></span></code></pre></div></li></ul><p>在这一轮更新完成之后，新旧两组子节点与真实 DOM 节点的状态如图 10-8 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/071.jpg" alt="图 10-8"></p><p><strong>图 10-8　新旧两组子节点以及真实 DOM 节点的状态</strong></p><p>真实 DOM 的顺序相比上一轮没有变化，因为在这一轮的比较中没有对 DOM 节点进行移动，只是对 <code>p-3</code> 节点打补丁。接下来，我们再根据图 10-8 所示的状态执行下一轮的比较。</p><ul><li>第一步：比较旧的一组子节点中的头部节点 <code>p-1</code> 与新的一组子节点中的头部节点 <code>p-2</code>，看看它们是否相同。由于两者的 <code>key</code> 值不同，不可复用，因此什么都不做。</li><li>第二步：比较旧的一组子节点中的尾部节点 <code>p-2</code> 与新的一组子节点中的尾部节点 <code>p-1</code>，看看它们是否相同，由于两者的 <code>key</code> 值不同，不可复用，因此什么都不做。</li><li>第三步：比较旧的一组子节点中的头部节点 <code>p-1</code> 与新的一组子节点中的尾部节点 <code>p-1</code>。两者的 <code>key</code> 值相同，可以复用。</li></ul><p>在第三步的比较中，我们找到了相同的节点，这说明：<strong>节点</strong> <code>p-1</code> <strong>原本是头部节点，但在新的顺序中，它变成了尾部节点</strong>。因此，我们需要将节点 <code>p-1</code> 对应的真实 DOM 移动到旧的一组子节点的尾部节点 <code>p-2</code> 所对应的真实 DOM 后面，同时还需要更新相应的索引到下一个位置，如图 10-9 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/072.jpg" alt="图 10-9"></p><p><strong>图 10-9　新旧两组子节点以及真实 DOM 节点的状态</strong></p><p>这一步的代码实现如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {</span></span>
<span class="line"><span>02   if (oldStartVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>03   } else if (oldEndVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>04     patch(oldEndVNode, newEndVNode, container)</span></span>
<span class="line"><span>05     oldEndVNode = oldChildren[--oldEndIdx]</span></span>
<span class="line"><span>06     newEndVNode = newChildren[--newEndIdx]</span></span>
<span class="line"><span>07   } else if (oldStartVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>08     // 调用 patch 函数在 oldStartVNode 和 newEndVNode 之间打补丁</span></span>
<span class="line"><span>09     patch(oldStartVNode, newEndVNode, container)</span></span>
<span class="line"><span>10     // 将旧的一组子节点的头部节点对应的真实 DOM 节点 oldStartVNode.el 移动到</span></span>
<span class="line"><span>11     // 旧的一组子节点的尾部节点对应的真实 DOM 节点后面</span></span>
<span class="line"><span>12     insert(oldStartVNode.el, container, oldEndVNode.el.nextSibling)</span></span>
<span class="line"><span>13     // 更新相关索引到下一个位置</span></span>
<span class="line"><span>14     oldStartVNode = oldChildren[++oldStartIdx]</span></span>
<span class="line"><span>15     newEndVNode = newChildren[--newEndIdx]</span></span>
<span class="line"><span>16   } else if (oldEndVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>17     patch(oldEndVNode, newStartVNode, container)</span></span>
<span class="line"><span>18     insert(oldEndVNode.el, container, oldStartVNode.el)</span></span>
<span class="line"><span>19</span></span>
<span class="line"><span>20     oldEndVNode = oldChildren[--oldEndIdx]</span></span>
<span class="line"><span>21     newStartVNode = newChildren[++newStartIdx]</span></span>
<span class="line"><span>22   }</span></span>
<span class="line"><span>23 }</span></span></code></pre></div><p>如上面的代码所示，如果旧的一组子节点的头部节点与新的一组子节点的尾部节点匹配，则说明该旧节点所对应的真实 DOM 节点需要移动到尾部。因此，我们需要获取当前尾部节点的下一个兄弟节点作为锚点，即 <code>oldEndVNode.el.nextSibling</code>。最后，更新相关索引到下一个位置。</p><p>通过图 10-9 可知，此时，新旧两组子节点的头部索引和尾部索引发生重合，但仍然满足循环的条件，所以还会进行下一轮的更新。而在接下来的这一轮的更新中，更新步骤也发生了重合。</p><blockquote><p>第一步：比较旧的一组子节点中的头部节点 <code>p-2</code> 与新的一组子节点中的头部节点 <code>p-2</code>。发现两者 <code>key</code> 值相同，可以复用。但两者在新旧两组子节点中都是头部节点，因此不需要移动，只需要调用 <code>patch</code> 函数进行打补丁即可。</p></blockquote><p>代码实现如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {</span></span>
<span class="line"><span>02   if (oldStartVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>03     // 调用 patch 函数在 oldStartVNode 与 newStartVNode 之间打补丁</span></span>
<span class="line"><span>04     patch(oldStartVNode, newStartVNode, container)</span></span>
<span class="line"><span>05     // 更新相关索引，指向下一个位置</span></span>
<span class="line"><span>06     oldStartVNode = oldChildren[++oldStartIdx]</span></span>
<span class="line"><span>07     newStartVNode = newChildren[++newStartIdx]</span></span>
<span class="line"><span>08   } else if (oldEndVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>09     patch(oldEndVNode, newEndVNode, container)</span></span>
<span class="line"><span>10     oldEndVNode = oldChildren[--oldEndIdx]</span></span>
<span class="line"><span>11     newEndVNode = newChildren[--newEndIdx]</span></span>
<span class="line"><span>12   } else if (oldStartVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>13     patch(oldStartVNode, newEndVNode, container)</span></span>
<span class="line"><span>14     insert(oldStartVNode.el, container, oldEndVNode.el.nextSibling)</span></span>
<span class="line"><span>15</span></span>
<span class="line"><span>16     oldStartVNode = oldChildren[++oldStartIdx]</span></span>
<span class="line"><span>17     newEndVNode = newChildren[--newEndIdx]</span></span>
<span class="line"><span>18   } else if (oldEndVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>19     patch(oldEndVNode, newStartVNode, container)</span></span>
<span class="line"><span>20     insert(oldEndVNode.el, container, oldStartVNode.el)</span></span>
<span class="line"><span>21</span></span>
<span class="line"><span>22     oldEndVNode = oldChildren[--oldEndIdx]</span></span>
<span class="line"><span>23     newStartVNode = newChildren[++newStartIdx]</span></span>
<span class="line"><span>24   }</span></span>
<span class="line"><span>25 }</span></span></code></pre></div><p>在这一轮更新之后，新旧两组子节点与真实 DOM 节点的状态如图 10-10 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/073.jpg" alt="图 10-10 "></p><p><strong>图 10-10　新旧两组子节点以及真实 DOM 节点的状态</strong></p><p>此时，真实 DOM 节点的顺序与新的一组子节点的顺序相同了：<code>p-4</code>、<code>p-2</code>、<code>p-1</code>、<code>p-3</code>。另外，在这一轮更新完成之后，索引 <code>newStartIdx</code> 和索引 <code>oldStartIdx</code> 的值都小于 <code>newEndIdx</code> 和 <code>oldEndIdx</code>，所以循环终止，双端 Diff 算法执行完毕。</p><h3 id="_10-2-双端比较的优势" tabindex="-1">10.2　双端比较的优势 <a class="header-anchor" href="#_10-2-双端比较的优势" aria-label="Permalink to &quot;10.2　双端比较的优势&quot;">​</a></h3><p>理解了双端比较的原理之后，我们来看看与简单 Diff 算法相比，双端 Diff 算法具有怎样的优势。我们拿第 9 章的例子来看，如图 10-11 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/074.jpg" alt="图 10-11"></p><p><strong>图 10-11　新旧两组子节点</strong></p><p>图 10-11 给出了新旧两组子节点的节点顺序。当使用简单 Diff 算法对此例进行更新时，会发生两次 DOM 移动操作，如图 10-12 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/075.jpg" alt="图 10-12"></p><p><strong>图 10-12　两次 DOM 移动</strong></p><p>如果使用双端 Diff 算法对此例进行更新，会有怎样的表现呢？接下来，我们就以双端比较的思路来完成此例的更新，看一看双端 Diff 算法能否减少 DOM 移动操作次数。</p><p>图 10-13 给出了算法执行之前新旧两组子节点与真实 DOM 节点的状态。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/076.jpg" alt="图 10-13"></p><p><strong>图 10-13　新旧两组子节点与真实 DOM 节点的状态</strong></p><p>接下来，我们按照双端比较的步骤执行更新。</p><ul><li>第一步：比较旧的一组子节点中的头部节点 <code>p-1</code> 与新的一组子节点中的头部节点 <code>p-3</code>，两者 <code>key</code> 值不同，不可复用。</li><li>第二步：比较旧的一组子节点中的尾部节点 <code>p-3</code> 与新的一组子节点中的尾部节点 <code>p-2</code>，两者 <code>key</code> 值不同，不可复用。</li><li>第三步：比较旧的一组子节点中的头部节点 <code>p-1</code> 与新的一组子节点中的尾部节点 <code>p-2</code>，两者 <code>key</code> 值不同，不可复用。</li><li>第四步：比较旧的一组子节点中的尾部节点 <code>p-3</code> 与新的一组子节点中的头部节点 <code>p-3</code>，发现可以进行复用。</li></ul><p>可以看到，在第四步的比较中，我们找到了可复用的节点 <code>p-3</code>。该节点原本处于所有子节点的尾部，但在新的一组子节点中它处于头部。因此，只需要让节点 <code>p-3</code> 对应的真实 DOM 变成新的头部节点即可。在这一步移动操作之后，新旧两组子节点以及真实 DOM 节点的状态如图 10-14 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/077.jpg" alt="图 10-14"></p><p><strong>图 10-14　新旧两组子节点与真实 DOM 节点的状态</strong></p><p>观察图 10-14 能够发现，在这一轮比较过后，真实 DOM 节点的顺序已经与新的一组子节点的顺序一致了。换句话说，我们完成了更新，不过算法仍然会继续执行。开始下一轮的比较。</p><blockquote><p>第一步：比较旧的一组子节点中的头部节点 <code>p-1</code> 与新的一组子节点中的头部节点 <code>p-1</code>，两者的 <code>key</code> 值相同，可以复用。但由于两者都处于头部，因此不需要移动，只需要打补丁即可。</p></blockquote><p>在这一轮比较过后，新旧两组子节点与真实 DOM 节点的状态如图 10-15 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/078.jpg" alt="图 10-15"></p><p><strong>图 10-15　新旧两组子节点与真实 DOM 节点的状态</strong></p><p>此时，双端 Diff 算法仍然没有停止，开始新一轮的比较。</p><blockquote><p>第一步：比较旧的一组子节点中的头部节点 <code>p-2</code> 与新的一组子节点中的头部节点 <code>p-2</code>，两者的 <code>key</code> 值相同，可以复用。但由于两者都处于头部，因此不需要移动，只需要打补丁即可。</p></blockquote><p>在这一轮比较过后，新旧两组子节点与真实 DOM 节点的状态如图 10-16 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/079.jpg" alt="图 10-16"></p><p><strong>图 10-16　新旧两组子节点与真实 DOM 节点的状态</strong></p><p>到这一步后，索引 <code>newStartIdx</code> 和 <code>oldStartIdx</code> 的值比索引 <code>newEndIdx</code> 和 <code>oldEndIdx</code> 的值大，于是更新结束。可以看到，对于同样的例子，采用简单 Diff 算法需要两次 DOM 移动操作才能完成更新，而使用双端 Diff 算法只需要一次 DOM 移动操作即可完成更新。</p><h3 id="_10-3-非理想状况的处理方式" tabindex="-1">10.3　非理想状况的处理方式 <a class="header-anchor" href="#_10-3-非理想状况的处理方式" aria-label="Permalink to &quot;10.3　非理想状况的处理方式&quot;">​</a></h3><p>在上一节的讲解中，我们用了一个比较理想的例子。我们知道，双端 Diff 算法的每一轮比较的过程都分为四个步骤。在上一节的例子中，每一轮比较都会命中四个步骤中的一个，这是非常理想的情况。但实际上，并非所有情况都这么理想，如图 10-17 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/080.jpg" alt="图 10-17"></p><p><strong>图 10-17　第一轮比较都无法命中</strong></p><p>在这个例子中，新旧两组子节点的顺序如下。</p><ul><li>旧的一组子节点：<code>p-1</code>、<code>p-2</code>、<code>p-3</code>、<code>p-4</code>。</li><li>新的一组子节点：<code>p-2</code>、<code>p-4</code>、<code>p-1</code>、<code>p-3</code>。</li></ul><p>当我们尝试按照双端 Diff 算法的思路进行第一轮比较时，会发现无法命中四个步骤中的任何一步。</p><ul><li>第一步：比较旧的一组子节点中的头部节点 <code>p-1</code> 与新的一组子节点中的头部节点 <code>p-2</code>，不可复用。</li><li>第二步：比较旧的一组子节点中的尾部节点 <code>p-4</code> 与新的一组子节点中的尾部节点 <code>p-3</code>，不可复用。</li><li>第三步：比较旧的一组子节点中的头部节点 <code>p-1</code> 与新的一组子节点中的尾部节点 <code>p-3</code>，不可复用。</li><li>第四步：比较旧的一组子节点中的尾部节点 <code>p-4</code> 与新的一组子节点中的头部节点 <code>p-2</code>，不可复用。</li></ul><p>在四个步骤的比较过程中，都无法找到可复用的节点，应该怎么办呢？这时，我们只能通过增加额外的处理步骤来处理这种非理想情况。既然两个头部和两个尾部的四个节点中都没有可复用的节点，那么我们就尝试看看非头部、非尾部的节点能否复用。具体做法是，拿新的一组子节点中的头部节点去旧的一组子节点中寻找，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {</span></span>
<span class="line"><span>02   if (oldStartVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>03     // 省略部分代码</span></span>
<span class="line"><span>04   } else if (oldEndVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>05     // 省略部分代码</span></span>
<span class="line"><span>06   } else if (oldStartVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>07     // 省略部分代码</span></span>
<span class="line"><span>08   } else if (oldEndVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>09     // 省略部分代码</span></span>
<span class="line"><span>10   } else {</span></span>
<span class="line"><span>11     // 遍历旧的一组子节点，试图寻找与 newStartVNode 拥有相同 key 值的节点</span></span>
<span class="line"><span>12     // idxInOld 就是新的一组子节点的头部节点在旧的一组子节点中的索引</span></span>
<span class="line"><span>13     const idxInOld = oldChildren.findIndex(</span></span>
<span class="line"><span>14       node =&gt; node.key === newStartVNode.key</span></span>
<span class="line"><span>15     )</span></span>
<span class="line"><span>16   }</span></span>
<span class="line"><span>17 }</span></span></code></pre></div><p>在上面这段代码中，我们遍历旧的一组子节点，尝试在其中寻找与新的一组子节点的头部节点具有相同 <code>key</code> 值的节点，并将该节点在旧的一组子节点中的索引存储到变量 <code>idxInOld</code> 中。这么做的目的是什么呢？想要搞清楚这个问题，本质上需要我们先搞清楚：在旧的一组子节点中，找到与新的一组子节点的头部节点具有相同 <code>key</code> 值的节点意味着什么？如图 10-18 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/081.jpg" alt="图 10-18"></p><p><strong>图 10-18　在旧子节点中寻找可复用节点</strong></p><p>观察图 10-18，当我们拿新的一组子节点的头部节点 <code>p-2</code> 去旧的一组子节点中查找时，会在索引为 <code>1</code> 的位置找到可复用的节点。这意味着，节点 <code>p-2</code> 原本不是头部节点，但在更新之后，它应该变成头部节点。所以我们需要将节点 <code>p-2</code> 对应的真实 DOM 节点移动到当前旧的一组子节点的头部节点 <code>p-1</code> 所对应的真实 DOM 节点之前。具体实现如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {</span></span>
<span class="line"><span>02   if (oldStartVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>03     // 省略部分代码</span></span>
<span class="line"><span>04   } else if (oldEndVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>05     // 省略部分代码</span></span>
<span class="line"><span>06   } else if (oldStartVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>07     // 省略部分代码</span></span>
<span class="line"><span>08   } else if (oldEndVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>09     // 省略部分代码</span></span>
<span class="line"><span>10   } else {</span></span>
<span class="line"><span>11     // 遍历旧 children，试图寻找与 newStartVNode 拥有相同 key 值的元素</span></span>
<span class="line"><span>12     const idxInOld = oldChildren.findIndex(</span></span>
<span class="line"><span>13       node =&gt; node.key === newStartVNode.key</span></span>
<span class="line"><span>14     )</span></span>
<span class="line"><span>15     // idxInOld 大于 0，说明找到了可复用的节点，并且需要将其对应的真实 DOM 移动到头部</span></span>
<span class="line"><span>16     if (idxInOld &gt; 0) {</span></span>
<span class="line"><span>17       // idxInOld 位置对应的 vnode 就是需要移动的节点</span></span>
<span class="line"><span>18       const vnodeToMove = oldChildren[idxInOld]</span></span>
<span class="line"><span>19       // 不要忘记除移动操作外还应该打补丁</span></span>
<span class="line"><span>20       patch(vnodeToMove, newStartVNode, container)</span></span>
<span class="line"><span>21       // 将 vnodeToMove.el 移动到头部节点 oldStartVNode.el 之前，因此使用后者作为锚点</span></span>
<span class="line"><span>22       insert(vnodeToMove.el, container, oldStartVNode.el)</span></span>
<span class="line"><span>23       // 由于位置 idxInOld 处的节点所对应的真实 DOM 已经移动到了别处，因此将其设置为 undefined</span></span>
<span class="line"><span>24       oldChildren[idxInOld] = undefined</span></span>
<span class="line"><span>25       // 最后更新 newStartIdx 到下一个位置</span></span>
<span class="line"><span>26       newStartVNode = newChildren[++newStartIdx]</span></span>
<span class="line"><span>27     }</span></span>
<span class="line"><span>28   }</span></span>
<span class="line"><span>29 }</span></span></code></pre></div><p>在上面这段代码中，首先判断 <code>idxInOld</code> 是否大于 <code>0</code>。如果条件成立，则说明找到了可复用的节点，然后将该节点对应的真实 DOM 移动到头部。为此，我们先要获取需要移动的节点，这里的 <code>oldChildren[idxInOld]</code> 所指向的节点就是需要移动的节点。在移动节点之前，不要忘记调用 <code>patch</code> 函数进行打补丁。接着，调用 <code>insert</code> 函数，并以现在的头部节点对应的真实 DOM 节点 <code>oldStartVNode.el</code> 作为锚点参数来完成节点的移动操作。当节点移动完成后，还有两步工作需要做。</p><ul><li>由于处于 <code>idxInOld</code> 处的节点已经处理过了（对应的真实 DOM 移到了别处），因此我们应该将 <code>oldChildren[idxInOld]</code> 设置为 <code>undefined</code>。</li><li>新的一组子节点中的头部节点已经处理完毕，因此将 <code>newStartIdx</code> 前进到下一个位置。</li></ul><p>经过上述两个步骤的操作后，新旧两组子节点以及真实 DOM 节点的状态如图 10-19 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/082.jpg" alt="图 10-19 "></p><p><strong>图 10-19　新旧两组子节点以及真实 DOM 节点的状态</strong></p><p>此时，真实 DOM 的顺序为：<code>p-2</code>、<code>p-1</code>、<code>p-3</code>、<code>p-4</code>。接着，双端 Diff 算法会继续进行，如图 10-20 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/083.jpg" alt="图 10-20"></p><p><strong>图 10-20　新旧两组子节点以及真实 DOM 节点的状态</strong></p><ul><li>第一步：比较旧的一组子节点中的头部节点 <code>p-1</code> 与新的一组子节点中的头部节点 <code>p-4</code>，两者 <code>key</code> 值不同，不可复用。</li><li>第二步：比较旧的一组子节点中的尾部节点 <code>p-4</code> 与新的一组子节点中的尾部节点 <code>p-3</code>，两者 <code>key</code> 值不同，不可复用。</li><li>第三步：比较旧的一组子节点中的头部节点 <code>p-1</code> 与新的一组子节点中的尾部节点 <code>p-3</code>，两者 <code>key</code> 值不同，不可复用。</li><li>第四步：比较旧的一组子节点中的尾部节点 <code>p-4</code> 与新的一组子节点中的头部节点 <code>p-4</code>，两者的 <code>key</code> 值相同，可以复用。</li></ul><p>在这一轮比较的第四步中，我们找到了可复用的节点。因此，按照双端 Diff 算法的逻辑移动真实 DOM，即把节点 <code>p-4</code> 对应的真实 DOM 移动到旧的一组子节点中头部节点 <code>p-1</code> 所对应的真实 DOM 前面，如图 10-21 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/084.jpg" alt="图 10-21"></p><p><strong>图 10-21　移动节点 <code>p-4</code></strong></p><p>此时，真实 DOM 节点的顺序是：<code>p-2</code>、<code>p-4</code>、<code>p-1</code>、<code>p-3</code>。接着，开始下一轮的比较。</p><blockquote><p>第一步：比较旧的一组子节点中的头部节点 <code>p-1</code> 与新的一组子节点中的头部节点 <code>p-1</code>，两者的 <code>key</code> 值相同，可以复用。</p></blockquote><p>在这一轮比较中，第一步就找到了可复用的节点。由于两者都处于头部，所以不需要对真实 DOM 进行移动，只需要打补丁即可。在这一步操作过后，新旧两组子节点与真实 DOM 节点的状态如图 10-22 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/085.jpg" alt="图 10-22"></p><p><strong>图 10-22　新旧两组子节点与真实 DOM 节点的状态</strong></p><p>此时，真实 DOM 节点的顺序是：<code>p-2</code>、<code>p-4</code>、<code>p-1</code>、<code>p-3</code>。接着，进行下一轮的比较。需要注意的一点是，此时旧的一组子节点的头部节点是 <code>undefined</code>。这说明该节点已经被处理过了，因此不需要再处理它了，直接跳过即可。为此，我们需要补充这部分逻辑的代码，具体实现如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {</span></span>
<span class="line"><span>02   // 增加两个判断分支，如果头尾部节点为 undefined，则说明该节点已经被处理过了，直接跳到下一个位置</span></span>
<span class="line"><span>03   if (!oldStartVNode) {</span></span>
<span class="line"><span>04     oldStartVNode = oldChildren[++oldStartIdx]</span></span>
<span class="line"><span>05   } else if (!oldEndVNode) {</span></span>
<span class="line"><span>06     oldEndVNode = oldChildren[--oldEndIdx]</span></span>
<span class="line"><span>07   } else if (oldStartVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>08     // 省略部分代码</span></span>
<span class="line"><span>09   } else if (oldEndVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>10     // 省略部分代码</span></span>
<span class="line"><span>11   } else if (oldStartVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>12     // 省略部分代码</span></span>
<span class="line"><span>13   } else if (oldEndVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>14     // 省略部分代码</span></span>
<span class="line"><span>15   } else {</span></span>
<span class="line"><span>16     const idxInOld = oldChildren.findIndex(</span></span>
<span class="line"><span>17       node =&gt; node.key === newStartVNode.key</span></span>
<span class="line"><span>18     )</span></span>
<span class="line"><span>19     if (idxInOld &gt; 0) {</span></span>
<span class="line"><span>20       const vnodeToMove = oldChildren[idxInOld]</span></span>
<span class="line"><span>21       patch(vnodeToMove, newStartVNode, container)</span></span>
<span class="line"><span>22       insert(vnodeToMove.el, container, oldStartVNode.el)</span></span>
<span class="line"><span>23       oldChildren[idxInOld] = undefined</span></span>
<span class="line"><span>24       newStartVNode = newChildren[++newStartIdx]</span></span>
<span class="line"><span>25     }</span></span>
<span class="line"><span>26</span></span>
<span class="line"><span>27   }</span></span>
<span class="line"><span>28 }</span></span></code></pre></div><p>观察上面的代码，在循环开始时，我们优先判断头部节点和尾部节点是否存在。如果不存在，则说明它们已经被处理过了，直接跳到下一个位置即可。在这一轮比较过后，新旧两组子节点与真实 DOM 节点的状态如图 10-23 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/086.jpg" alt="图 10-23 "></p><p><strong>图 10-23　新旧两组子节点与真实 DOM 节点的状态</strong></p><p>现在，四个步骤又重合了，接着进行最后一轮的比较。</p><blockquote><p>第一步：比较旧的一组子节点中的头部节点 <code>p-3</code> 与新的一组子节点中的头部节点 <code>p-3</code>，两者的 <code>key</code> 值相同，可以复用。</p></blockquote><p>在第一步中找到了可复用的节点。由于两者都是头部节点，因此不需要进行 DOM 移动操作，直接打补丁即可。在这一轮比较过后，最终状态如图 10-24 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/087.jpg" alt="图 10-24"></p><p><strong>图 10-24　新旧两组子节点与真实 DOM 节点的状态</strong></p><p>这时，满足循环停止的条件，于是更新完成。最终，真实 DOM 节点的顺序与新的一组子节点的顺序一致，都是：<code>p-2</code>、<code>p-4</code>、<code>p-1</code>、<code>p-3</code>。</p><h3 id="_10-4-添加新元素" tabindex="-1">10.4　添加新元素 <a class="header-anchor" href="#_10-4-添加新元素" aria-label="Permalink to &quot;10.4　添加新元素&quot;">​</a></h3><p>在 10.3 节中，我们讲解了非理想情况的处理，即在一轮比较过程中，不会命中四个步骤中的任何一步。这时，我们会拿新的一组子节点中的头部节点去旧的一组子节点中寻找可复用的节点，然而并非总能找得到，如图 10-25 的例子所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/088.jpg" alt="图 10-25"></p><p><strong>图 10-25　新增节点的情况</strong></p><p>在这个例子中，新旧两组子节点的顺序如下。</p><ul><li>旧的一组子节点：<code>p-1</code>、<code>p-2</code>、<code>p-3</code>。</li><li>新的一组子节点：<code>p-4</code>、<code>p-1</code>、<code>p-3</code>、<code>p-2</code>。</li></ul><p>首先，我们尝试进行第一轮比较，发现在四个步骤的比较中都找不到可复用的节点。于是我们尝试拿新的一组子节点中的头部节点 <code>p-4</code> 去旧的一组子节点中寻找具有相同 <code>key</code> 值的节点，但在旧的一组子节点中根本就没有 <code>p-4</code> 节点，如图 10-26 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/089.jpg" alt="图 10-26"></p><p><strong>图 10-26　在旧的一组子节点中找不到可复用的节点</strong></p><p>这说明节点 <code>p-4</code> 是一个新增节点，我们应该将它挂载到正确的位置。那么应该挂载到哪里呢？很简单，因为节点 <code>p-4</code> 是新的一组子节点中的头部节点，所以只需要将它挂载到当前头部节点之前即可。“当前”头部节点指的是，旧的一组子节点中的头部节点所对应的真实 DOM 节点 <code>p-1</code>。下面是用来完成挂载操作的代码：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {</span></span>
<span class="line"><span>02   // 增加两个判断分支，如果头尾部节点为 undefined，则说明该节点已经被处理过了，直接跳到下一个位置</span></span>
<span class="line"><span>03   if (!oldStartVNode) {</span></span>
<span class="line"><span>04     oldStartVNode = oldChildren[++oldStartIdx]</span></span>
<span class="line"><span>05   } else if (!oldEndVNode) {</span></span>
<span class="line"><span>06     oldEndVNode = newChildren[--oldEndIdx]</span></span>
<span class="line"><span>07   } else if (oldStartVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>08     // 省略部分代码</span></span>
<span class="line"><span>09   } else if (oldEndVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>10     // 省略部分代码</span></span>
<span class="line"><span>11   } else if (oldStartVNode.key === newEndVNode.key) {</span></span>
<span class="line"><span>12     // 省略部分代码</span></span>
<span class="line"><span>13   } else if (oldEndVNode.key === newStartVNode.key) {</span></span>
<span class="line"><span>14     // 省略部分代码</span></span>
<span class="line"><span>15   } else {</span></span>
<span class="line"><span>16     const idxInOld = oldChildren.findIndex(</span></span>
<span class="line"><span>17       node =&gt; node.key === newStartVNode.key</span></span>
<span class="line"><span>18     )</span></span>
<span class="line"><span>19     if (idxInOld &gt; 0) {</span></span>
<span class="line"><span>20       const vnodeToMove = oldChildren[idxInOld]</span></span>
<span class="line"><span>21       patch(vnodeToMove, newStartVNode, container)</span></span>
<span class="line"><span>22       insert(vnodeToMove.el, container, oldStartVNode.el)</span></span>
<span class="line"><span>23       oldChildren[idxInOld] = undefined</span></span>
<span class="line"><span>24     } else {</span></span>
<span class="line"><span>25       // 将 newStartVNode 作为新节点挂载到头部，使用当前头部节点 oldStartVNode.el 作为锚点</span></span>
<span class="line"><span>26       patch(null, newStartVNode, container, oldStartVNode.el)</span></span>
<span class="line"><span>27     }</span></span>
<span class="line"><span>28     newStartVNode = newChildren[++newStartIdx]</span></span>
<span class="line"><span>29   }</span></span>
<span class="line"><span>30 }</span></span></code></pre></div><p>如上面的代码所示，当条件 <code>idxInOld &gt; 0</code> 不成立时，说明 <code>newStartVNode</code> 节点是全新的节点。又由于 <code>newStartVNode</code> 节点是头部节点，因此我们应该将其作为新的头部节点进行挂载。所以，在调用 <code>patch</code> 函数挂载节点时，我们使用 <code>oldStartVNode.el</code> 作为锚点。在这一步操作完成之后，新旧两组子节点以及真实 DOM 节点的状态如图 10-27 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/090.jpg" alt="图 10-27 "></p><p><strong>图 10-27　新旧两组子节点以及真实 DOM 节点的状态</strong></p><p>当新节点 <code>p-4</code> 挂载完成后，会进行后续的更新，直到全部更新完成为止。但这样就完美了吗？答案是否定的，我们再来看另外一个例子，如图 10-28 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/091.jpg" alt="图 10-28"></p><p><strong>图 10-28　新旧两组子节点以及真实 DOM 节点的状态</strong></p><p>这个例子与上一个的例子的不同之处在于，我们调整了新的一组子节点的顺序：<code>p-4</code>、<code>p-1</code>、<code>p-2</code>、<code>p-3</code>。下面我们按照双端 Diff 算法的思路来执行更新，看看会发生什么。</p><ul><li>第一步：比较旧的一组子节点中的头部节点 <code>p-1</code> 与新的一组子节点中的头部节点 <code>p-4</code>，两者的 <code>key</code> 值不同，不可以复用。</li><li>第二步：比较旧的一组子节点中的尾部节点 <code>p-3</code> 与新的一组子节点中的尾部节点 <code>p-3</code>，两者的 <code>key</code> 值相同，可以复用。</li></ul><p>在第二步中找到了可复用的节点，因此进行更新。更新后的新旧两组子节点以及真实 DOM 节点的状态如图 10-29 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/092.jpg" alt="图 10-29 "></p><p><strong>图 10-29　新旧两组子节点以及真实 DOM 节点的状态</strong></p><p>接着进行下一轮的比较。</p><ul><li>第一步：比较旧的一组子节点中的头部节点 <code>p-1</code> 与新的一组子节点中的头部节点 <code>p-4</code>，两者的 <code>key</code> 值不同，不可以复用。</li><li>第二步：比较旧的一组子节点中的尾部节点 <code>p-2</code> 与新的一组子节点中的尾部节点 <code>p-2</code>，两者的 <code>key</code> 值相同，可以复用。</li></ul><p>我们又在第二步找到了可复用的节点，于是再次进行更新。更新后的新旧两组子节点以及真实 DOM 节点的状态如图 10-30 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/093.jpg" alt="图 10-30"></p><p><strong>图 10-30　新旧两组子节点以及真实 DOM 节点的状态</strong></p><p>接着，进行下一轮的更新。</p><ul><li>第一步：比较旧的一组子节点中的头部节点 <code>p-1</code> 与新的一组子节点中的头部节点 <code>p-4</code>，两者的 <code>key</code> 值不同，不可以复用。</li><li>第二步：比较旧的一组子节点中的尾部节点 <code>p-1</code> 与新的一组子节点中的尾部节点 <code>p-1</code>，两者的 <code>key</code> 值相同，可以复用。</li></ul><p>还是在第二步找到了可复用的节点，再次进行更新。更新后的新旧两组子节点以及真实 DOM 节点的状态如图 10-31 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/094.jpg" alt="图 10-31"></p><p><strong>图 10-31　新旧两组子节点以及真实 DOM 节点的状态</strong></p><p>当这一轮更新完毕后，由于变量 <code>oldStartIdx</code> 的值大于 <code>oldEndIdx</code> 的值，满足更新停止的条件，因此更新停止。但通过观察可知，节点 <code>p-4</code> 在整个更新过程中被遗漏了，没有得到任何处理，这说明我们的算法是有缺陷的。为了弥补这个缺陷，我们需要添加额外的处理代码，如下所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {</span></span>
<span class="line"><span>02   // 省略部分代码</span></span>
<span class="line"><span>03 }</span></span>
<span class="line"><span>04</span></span>
<span class="line"><span>05 // 循环结束后检查索引值的情况，</span></span>
<span class="line"><span>06 if (oldEndIdx &lt; oldStartIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {</span></span>
<span class="line"><span>07   // 如果满足条件，则说明有新的节点遗留，需要挂载它们</span></span>
<span class="line"><span>08   for (let i = newStartIdx; i &lt;= newEndIdx; i++) {</span></span>
<span class="line"><span>09     const anchor = newChildren[newEndIdx + 1] ? newChildren[newEndIdx + 1].el : null;</span></span>
<span class="line"><span>10     patch(null, newChildren[i], container, anchor);</span></span>
<span class="line"><span>11   }</span></span>
<span class="line"><span>12 }</span></span></code></pre></div><p>我们在 <code>while</code> 循环结束后增加了一个 <code>if</code> 条件语句，检查四个索引值的情况。根据图 10-31 可知，如果条件 <code>oldEndIdx &lt; oldStartIdx &amp;&amp; newStartIdx &lt;= newEndIdx</code> 成立，说明新的一组子节点中有遗留的节点需要作为新节点挂载。哪些节点是新节点呢？索引值位于 <code>newStartIdx</code> 和 <code>newEndIdx</code> 这个区间内的节点都是新节点。于是我们开启一个 <code>for</code> 循环来遍历这个区间内的节点并逐一挂载。挂载时的锚点仍然使用当前的头部节点 <code>oldStartVNode.el</code>，这样就完成了对新增元素的处理。</p><h3 id="_10-5-移除不存在的元素" tabindex="-1">10.5　移除不存在的元素 <a class="header-anchor" href="#_10-5-移除不存在的元素" aria-label="Permalink to &quot;10.5　移除不存在的元素&quot;">​</a></h3><p>解决了新增节点的问题后，我们再来讨论关于移除元素的情况，如图 10-32 的例子所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/095.jpg" alt="图 10-32"></p><p><strong>图 10-32　移除节点的情况</strong></p><p>在这个例子中，新旧两组子节点的顺序如下。</p><ul><li>旧的一组子节点：<code>p-1</code>、<code>p-2</code>、<code>p-3</code>。</li><li>新的一组子节点：<code>p-1</code>、<code>p-3</code>。</li></ul><p>可以看到，在新的一组子节点中 <code>p-2</code> 节点已经不存在了。为了搞清楚应该如何处理节点被移除的情况，我们还是按照双端 Diff 算法的思路执行更新。</p><blockquote><p>第一步：比较旧的一组子节点中的头部节点 <code>p-1</code> 与新的一组子节点中的头部节点 <code>p-1</code>，两者的 <code>key</code> 值相同，可以复用。</p></blockquote><p>在第一步的比较中找到了可复用的节点，于是执行更新。在这一轮比较过后，新旧两组子节点以及真实 DOM 节点的状态如图 10-33 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/096.jpg" alt="图 10-33"></p><p><strong>图 10-33　新旧两组子节点以及真实 DOM 节点的状态</strong></p><p>接着，执行下一轮更新。</p><ul><li>第一步：比较旧的一组子节点中的头部节点 <code>p-2</code> 与新的一组子节点中的头部节点 <code>p-3</code>，两者的 <code>key</code> 值不同，不可以复用。</li><li>第二步：比较旧的一组子节点中的尾部节点 <code>p-3</code> 与新的一组子节点中的尾部节点 <code>p-3</code>，两者的 <code>key</code> 值相同，可以复用。</li></ul><p>在第二步中找到了可复用的节点，于是进行更新。更新后的新旧两组子节点以及真实 DOM 节点的状态如图 10-34 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/097.jpg" alt="图 10-34"></p><p><strong>图 10-34　新旧两组子节点以及真实 DOM 节点的状态</strong></p><p>此时变量 <code>newStartIdx</code> 的值大于变量 <code>newEndIdx</code> 的值，满足更新停止的条件，于是更新结束。但观察图 10-34 可知，旧的一组子节点中存在未被处理的节点，应该将其移除。因此，我们需要增加额外的代码来处理它，如下所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {</span></span>
<span class="line"><span>02   // 省略部分代码</span></span>
<span class="line"><span>03 }</span></span>
<span class="line"><span>04</span></span>
<span class="line"><span>05 if (oldEndIdx &lt; oldStartIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {</span></span>
<span class="line"><span>06   // 添加新节点</span></span>
<span class="line"><span>07   // 省略部分代码</span></span>
<span class="line"><span>08 } else if (newEndIdx &lt; newStartIdx &amp;&amp; oldStartIdx &lt;= oldEndIdx) {</span></span>
<span class="line"><span>09   // 移除操作</span></span>
<span class="line"><span>10   for (let i = oldStartIdx; i &lt;= oldEndIdx; i++) {</span></span>
<span class="line"><span>11     unmount(oldChildren[i])</span></span>
<span class="line"><span>12   }</span></span>
<span class="line"><span>13 }</span></span></code></pre></div><p>与处理新增节点类似，我们在 <code>while</code> 循环结束后又增加了一个 <code>else...if</code> 分支，用于卸载已经不存在的节点。由图 10-34 可知，索引值位于 <code>oldStartIdx</code> 和 <code>oldEndIdx</code> 这个区间内的节点都应该被卸载，于是我们开启一个 <code>for</code> 循环将它们逐一卸载。</p><h3 id="_10-6-总结" tabindex="-1">10.6　总结 <a class="header-anchor" href="#_10-6-总结" aria-label="Permalink to &quot;10.6　总结&quot;">​</a></h3><p>本章我们介绍了双端 Diff 算法的原理及其优势。顾名思义，双端 Diff 算法指的是，在新旧两组子节点的四个端点之间分别进行比较，并试图找到可复用的节点。相比简单 Diff 算法，双端 Diff 算法的优势在于，对于同样的更新场景，执行的 DOM 移动操作次数更少。</p><h2 id="第-11-章-快速-diff-算法" tabindex="-1">第 11 章　快速 Diff 算法 <a class="header-anchor" href="#第-11-章-快速-diff-算法" aria-label="Permalink to &quot;第 11 章　快速 Diff 算法&quot;">​</a></h2><h3 id="_11-1-相同的前置元素和后置元素" tabindex="-1">11.1　相同的前置元素和后置元素 <a class="header-anchor" href="#_11-1-相同的前置元素和后置元素" aria-label="Permalink to &quot;11.1　相同的前置元素和后置元素&quot;">​</a></h3><p>不同于简单 Diff 算法和双端 Diff 算法，快速 Diff 算法包含预处理步骤，这其实是借鉴了纯文本 Diff 算法的思路。在纯文本 Diff 算法中，存在对两段文本进行预处理的过程。例如，在对两段文本进行 Diff 之前，可以先对它们进行全等比较：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (text1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> text2) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span></span></code></pre></div><p>这也称为快捷路径。如果两段文本全等，那么就无须进入核心 Diff 算法的步骤了。除此之外，预处理过程还会处理两段文本相同的前缀和后缀。假设有如下两段文本：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 TEXT1: I use vue for app development</span></span>
<span class="line"><span>02 TEXT2: I use react for app development</span></span></code></pre></div><p>通过肉眼可以很容易发现，这两段文本的头部和尾部分别有一段相同的内容，如图 11-2 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/099.jpg" alt="图 11-2"></p><p><strong>图 11-2　文本预处理</strong></p><p>图 11-2 突出显示了 <code>TEXT1</code> 和 <code>TEXT2</code> 中相同的内容。对于内容相同的问题，是不需要进行核心 Diff 操作的。因此，对于 <code>TEXT1</code> 和 <code>TEXT2</code> 来说，真正需要进行 Diff 操作的部分是：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 TEXT1: vue</span></span>
<span class="line"><span>02 TEXT2: react</span></span></code></pre></div><p>这实际上是简化问题的一种方式。这么做的好处是，在特定情况下我们能够轻松地判断文本的插入和删除，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 TEXT1: I like you</span></span>
<span class="line"><span>02 TEXT2: I like you too</span></span></code></pre></div><p>经过预处理，去掉这两段文本中相同的前缀内容和后缀内容之后，它将变成：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 TEXT1:</span></span>
<span class="line"><span>02 TEXT2: too</span></span></code></pre></div><p>可以看到，经过预处理后，<code>TEXT1</code> 的内容为空。这说明 <code>TEXT2</code> 在 <code>TEXT1</code> 的基础上增加了字符串 <code>too</code>。相反，我们还可以将这两段文本的位置互换：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 TEXT1: I like you too</span></span>
<span class="line"><span>02 TEXT2: I like you</span></span></code></pre></div><p>这两段文本经过预处理后将变成：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 TEXT1: too</span></span>
<span class="line"><span>02 TEXT2:</span></span></code></pre></div><p>由此可知，<code>TEXT2</code> 是在 <code>TEXT1</code> 的基础上删除了字符串 <code>too</code>。</p><p>快速 Diff 算法借鉴了纯文本 Diff 算法中预处理的步骤。以图 11-3 给出的两组子节点为例。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/100.jpg" alt="图 11-3 "></p><p><strong>图 11-3　新旧两组子节点</strong></p><p>这两组子节点的顺序如下。</p><ul><li>旧的一组子节点：<code>p-1</code>、<code>p-2</code>、<code>p-3</code>。</li><li>新的一组子节点：<code>p-1</code>、<code>p-4</code>、<code>p-2</code>、<code>p-3</code>。</li></ul><p>通过观察可以发现，两组子节点具有相同的前置节点 <code>p-1</code>，以及相同的后置节点 <code>p-2</code> 和 <code>p-3</code>，如图 11-4 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/101.jpg" alt="图 11-4 "></p><p><strong>图 11-4　相同的前置节点和后置节点</strong></p><p>对于相同的前置节点和后置节点，由于它们在新旧两组子节点中的相对位置不变，所以我们无须移动它们，但仍然需要在它们之间打补丁。</p><p>对于前置节点，我们可以建立索引 <code>j</code>，其初始值为 <code>0</code>，用来指向两组子节点的开头，如图 11-5 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/102.jpg" alt="图 11-5"></p><p><strong>图 11-5　建立索引 j，指向两组子节点的开头</strong></p><p>然后开启一个 <code>while</code> 循环，让索引 <code>j</code> 递增，直到遇到不相同的节点为止，如下面 <code>patchKeyedChildren</code> 函数的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> patchKeyedChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n2.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n1.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 处理相同的前置节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 索引 j 指向新旧两组子节点的开头</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren[j]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[j]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // while 循环向后遍历，直到遇到拥有不同 key 值的节点为止</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (oldVNode.key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVNode.key) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 调用 patch 函数进行更新</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVNode, newVNode, container)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 更新索引 j，让其递增</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     oldVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren[j]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     newVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[j]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>在上面这段代码中，我们使用 <code>while</code> 循环查找所有相同的前置节点，并调用 <code>patch</code> 函数进行打补丁，直到遇到 <code>key</code> 值不同的节点为止。这样，我们就完成了对前置节点的更新。在这一步更新操作过后，新旧两组子节点的状态如图 11-6 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/103.jpg" alt="图 11-6 "></p><p><strong>图 11-6　处理完前置节点后的状态</strong></p><p>这里需要注意的是，当 <code>while</code> 循环终止时，索引 <code>j</code> 的值为 <code>1</code>。接下来，我们需要处理相同的后置节点。由于新旧两组子节点的数量可能不同，所以我们需要两个索引 <code>newEnd</code> 和 <code>oldEnd</code>，分别指向新旧两组子节点中的最后一个节点，如图 11-7 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/104.jpg" alt="图 11-7"></p><p><strong>图 11-7　建立索引，指向两组子节点的最后一个节点</strong></p><p>然后，再开启一个 <code>while</code> 循环，并从后向前遍历这两组子节点，直到遇到 <code>key</code> 值不同的节点为止，如下面的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> patchKeyedChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n2.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n1.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 更新相同的前置节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren[j]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[j]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (oldVNode.key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVNode.key) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVNode, newVNode, container)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     oldVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren[j]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     newVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[j]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 更新相同的后置节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 索引 oldEnd 指向旧的一组子节点的最后一个节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 索引 newEnd 指向新的一组子节点的最后一个节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   oldVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren[oldEnd]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   newVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[newEnd]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // while 循环从后向前遍历，直到遇到拥有不同 key 值的节点为止</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (oldVNode.key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVNode.key) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 调用 patch 函数进行更新</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVNode, newVNode, container)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 递减 oldEnd 和 nextEnd</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     oldEnd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     newEnd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     oldVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren[oldEnd]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     newVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[newEnd]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">33</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">34</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">35</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>与处理相同的前置节点一样，在 <code>while</code> 循环内，需要调用 <code>patch</code> 函数进行打补丁，然后递减两个索引 <code>oldEnd</code>、<code>newEnd</code> 的值。在这一步更新操作过后，新旧两组子节点的状态如图 11-8 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/105.jpg" alt="图 11-8"></p><p><strong>图 11-8　处理完后置节点后的状态</strong></p><p>由图 11-8 可知，当相同的前置节点和后置节点被处理完毕后，旧的一组子节点已经全部被处理了，而在新的一组子节点中，还遗留了一个未被处理的节点 <code>p-4</code>。其实不难发现，节点 <code>p-4</code> 是一个新增节点。那么，如何用程序得出“节点 <code>p-4</code> 是新增节点”这个结论呢？这需要我们观察三个索引 <code>j</code>、<code>newEnd</code> 和 <code>oldEnd</code> 之间的关系。</p><ul><li>条件一 <code>oldEnd &lt; j</code> 成立：说明在预处理过程中，所有旧子节点都处理完毕了。</li><li>条件二 <code>newEnd &gt;= j</code> 成立：说明在预处理过后，在新的一组子节点中，仍然有未被处理的节点，而这些遗留的节点将被视作<strong>新增节点</strong>。</li></ul><p>如果条件一和条件二同时成立，说明在新的一组子节点中，存在遗留节点，且这些节点都是新增节点。因此我们需要将它们挂载到正确的位置，如图 11-9 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/106.jpg" alt="图 11-9"></p><p><strong>图 11-9　新增节点的情况</strong></p><p>在新的一组子节点中，索引值处于 <code>j</code> 和 <code>newEnd</code> 之间的任何节点都需要作为新的子节点进行挂载。那么，应该怎样将这些节点挂载到正确位置呢？这就要求我们必须找到正确的锚点元素。观察图 11-9 中新的一组子节点可知，新增节点应该挂载到节点 <code>p-2</code> 所对应的真实 DOM 前面。所以，节点 <code>p-2</code> 对应的真实 DOM 节点就是挂载操作的锚点元素。有了这些信息，我们就可以给出具体的代码实现了，如下所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> patchKeyedChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n2.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n1.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 更新相同的前置节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 更新相同的后置节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 预处理完毕后，如果满足如下条件，则说明从 j --&gt; newEnd 之间的节点应作为新节点插入</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 锚点的索引</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> anchorIndex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 锚点元素</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> anchor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> anchorIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[anchorIndex].el </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 采用 while 循环，调用 patch 函数逐个挂载新增节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, newChildren[j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], container, anchor)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>在上面这段代码中，首先计算锚点的索引值（即 <code>anchorIndex</code>）为 <code>newEnd + 1</code>。如果小于新的一组子节点的数量，则说明锚点元素在新的一组子节点中，所以直接使用 <code>newChildren[anchorIndex].el</code> 作为锚点元素；否则说明索引 <code>newEnd</code> 对应的节点已经是尾部节点了，这时无须提供锚点元素。有了锚点元素之后，我们开启了一个 <code>while</code> 循环，用来遍历索引 <code>j</code> 和索引 <code>newEnd</code> 之间的节点，并调用 <code>patch</code> 函数挂载它们。</p><p>上面的案例展示了新增节点的情况，我们再来看看删除节点的情况，如图 11-10 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/107.jpg" alt="图 11-10"></p><p><strong>图 11-10　删除节点的情况</strong></p><p>在这个例子中，新旧两组子节点的顺序如下。</p><ul><li>旧的一组子节点：<code>p-1</code>、<code>p-2</code>、<code>p-3</code>。</li><li>新的一组子节点：<code>p-1</code>、<code>p-3</code>。</li></ul><p>我们同样使用索引 <code>j</code>、<code>oldEnd</code> 和 <code>newEnd</code> 进行标记，如图 11-11 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/108.jpg" alt="图 11-11 "></p><p><strong>图 11-11　在删除节点的情况下，各个索引的关系</strong></p><p>接着，对相同的前置节点进行预处理，处理后的状态如图 11-12 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/109.jpg" alt="图 11-12"></p><p><strong>图 11-12　处理完前置节点后，各个索引的关系</strong></p><p>然后，对相同的后置节点进行预处理，处理后的状态如图 11-13 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/110.jpg" alt="图 11-13 "></p><p><strong>图 11-13　处理完后置节点后，各个索引的关系</strong></p><p>由图 11-13 可知，当相同的前置节点和后置节点全部被处理完毕后，新的一组子节点已经全部被处理完毕了，而旧的一组子节点中遗留了一个节点 <code>p-2</code>。这说明，应该卸载节点 <code>p-2</code>。实际上，遗留的节点可能有多个，如图 11-14 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/111.jpg" alt="图 11-14 "></p><p><strong>图 11-14　遗留的节点可能有多个</strong></p><p>索引 <code>j</code> 和索引 <code>oldEnd</code> 之间的任何节点都应该被卸载，具体实现如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> patchKeyedChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n2.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n1.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 更新相同的前置节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 更新相同的后置节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // j -&gt; oldEnd 之间的节点应该被卸载</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       unmount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldChildren[j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>在上面这段代码中，我们新增了一个 <code>else...if</code> 分支。当满足条件 <code>j &gt; newEnd &amp;&amp; j &lt;= oldEnd</code> 时，则开启一个 <code>while</code> 循环，并调用 <code>unmount</code> 函数逐个卸载这些遗留节点。</p><h3 id="_11-2-判断是否需要进行-dom-移动操作" tabindex="-1">11.2　判断是否需要进行 DOM 移动操作 <a class="header-anchor" href="#_11-2-判断是否需要进行-dom-移动操作" aria-label="Permalink to &quot;11.2　判断是否需要进行 DOM 移动操作&quot;">​</a></h3><p>在上一节中，我们讲解了快速 Diff 算法的预处理过程，即处理相同的前置节点和后置节点。但是，上一节给出的例子比较理想化，当处理完相同的前置节点或后置节点后，新旧两组子节点中总会有一组子节点全部被处理完毕。在这种情况下，只需要简单地挂载、卸载节点即可。但有时情况会比较复杂，如图 11-15 中给出的例子。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/112.jpg" alt="图 11-15"></p><p><strong>图 11-15　复杂情况下的新旧两组子节点</strong></p><p>在这个例子中，新旧两组子节点的顺序如下。</p><ul><li>旧的一组子节点：<code>p-1</code>、<code>p-2</code>、<code>p-3</code>、<code>p-4</code>、<code>p-6</code>、<code>p-5</code>。</li><li>新的一组子节点：<code>p-1</code>、<code>p-3</code>、<code>p-4</code>、<code>p-2</code>、<code>p-7</code>、<code>p-5</code>。</li></ul><p>可以看到，与旧的一组子节点相比，新的一组子节点多出了一个新节点 <code>p-7</code>，少了一个节点 <code>p-6</code>。这个例子并不像上一节给出的例子那样理想化，我们无法简单地通过预处理过程完成更新。在这个例子中，相同的前置节点只有 <code>p-1</code>，而相同的后置节点只有 <code>p-5</code>，如图 11-16 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/113.jpg" alt="图 11-16"></p><p><strong>图 11-16　复杂情况下仅有少量相同的前置节点和后置节点</strong></p><p>图 11-17 给出了经过预处理后两组子节点的状态。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/114.jpg" alt="图 11-17 "></p><p><strong>图 11-17　处理完前置节点和后置节点后的状态</strong></p><p>可以看到，经过预处理后，无论是新的一组子节点，还是旧的一组子节点，都有部分节点未经处理。这时就需要我们进一步处理。怎么处理呢？其实无论是简单 Diff 算法，还是双端 Diff 算法，抑或本章介绍的快速 Diff 算法，它们都遵循同样的处理规则：</p><ul><li>判断是否有节点需要移动，以及应该如何移动；</li><li>找出那些需要被添加或移除的节点。</li></ul><p>所以接下来我们的任务就是，判断哪些节点需要移动，以及应该如何移动。观察图 11-17 可知，在这种非理想的情况下，当相同的前置节点和后置节点被处理完毕后，索引 <code>j</code>、<code>newEnd</code> 和 <code>oldEnd</code> 不满足下面两个条件中的任何一个：</p><ul><li><code>j &gt; oldEnd &amp;&amp; j &lt;= newEnd</code></li><li><code>j &gt; newEnd &amp;&amp; j &lt;= oldEnd</code></li></ul><p>因此，我们需要增加新的 <code>else</code> 分支来处理图 11-17 所示的情况，如下面的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> patchKeyedChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n2.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n1.children</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 更新相同的前置节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 更新相同的后置节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 增加 else 分支来处理非理想情况</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>后续的处理逻辑将会编写在这个 <code>else</code> 分支内。知道了在哪里编写处理代码，接下来我们讲解具体的处理思路。首先，我们需要构造一个数组 <code>source</code>，它的长度等于新的一组子节点在经过预处理之后剩余未处理节点的数量，并且 <code>source</code> 中每个元素的初始值都是 <code>-1</code>，如图 11-18 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/115.jpg" alt="图 11-18"></p><p><strong>图 11-18　构造 <code>source</code> 数组</strong></p><p>我们可以通过下面的代码完成 <code>source</code> 数组的构造：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 构造 source 数组</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 新的一组子节点中剩余未处理节点的数量</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> source</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>如上面的代码所示。首先，我们需要计算新的一组子节点中剩余未处理节点的数量，即 <code>newEnd - j + 1</code>，然后创建一个长度与之相同的数组 <code>source</code>，最后使用 <code>fill</code> 函数完成数组的填充。那么，数组 <code>source</code> 的作用是什么呢？观察图 11-18 可以发现，数组 <code>source</code> 中的每一个元素分别与新的一组子节点中剩余未处理节点对应。实际上，<code>source</code> 数组将用来存储<strong>新的一组子节点中的节点在旧的一组子节点中的位置索引，后面将会使用它计算出一个最长递增子序列，并用于辅助完成 DOM 移动的操作</strong>，如图 11-19 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/116.jpg" alt="图 11-19"></p><p><strong>图 11-19　填充 <code>source</code> 数组</strong></p><p>图 11-19 展示了填充 <code>source</code> 数组的过程。由于 <code>source</code> 数组存储的是新子节点在旧的一组子节点中的位置索引，所以有：</p><ul><li>新的一组子节点中的节点 <code>p-3</code> 在旧的一组子节点中的索引为 <code>2</code>，因此 <code>source</code> 数组的第一个元素值为 <code>2</code>；</li><li>新的一组子节点中的节点 <code>p-4</code> 在旧的一组子节点中的索引为 <code>3</code>，因此 <code>source</code> 数组的第二个元素值为 <code>3</code>；</li><li>新的一组子节点中的节点 <code>p-2</code> 在旧的一组子节点中的索引为 <code>1</code>，因此 <code>source</code> 数组的第三个元素值为 <code>1</code>；</li><li>新的一组子节点中的节点 <code>p-7</code> 比较特殊，因为在旧的一组子节点中没有与其 <code>key</code> 值相等的节点，所以 <code>source</code> 数组的第四个元素值保留原来的 <code>-1</code>。</li></ul><p>我们可以通过两层 <code>for</code> 循环来完成 <code>source</code> 数组的填充工作，外层循环用于遍历旧的一组子节点，内层循环用于遍历新的一组子节点：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> source</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // oldStart 和 newStart 分别为起始索引，即 j</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldStart</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newStart</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 遍历旧的一组子节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldStart; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldVNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren[i]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 遍历新的一组子节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newStart; k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd; k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newVNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[k]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 找到拥有相同 key 值的可复用节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (oldVNode.key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVNode.key) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 调用 patch 进行更新</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVNode, newVNode, container)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 最后填充 source 数组</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         source[k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newStart] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>这里需要注意的是，由于数组 <code>source</code> 的索引是从 <code>0</code> 开始的，而未处理节点的索引未必从 <code>0</code> 开始，所以在填充数组时需要使用表达式 <code>k - newStart</code> 的值作为数组的索引值。外层循环的变量 <code>i</code> 就是当前节点在旧的一组子节点中的位置索引，因此直接将变量 <code>i</code> 的值赋给 <code>source[k - newStart]</code> 即可。</p><p>现在，<code>source</code> 数组已经填充完毕，我们后面会用到它。不过在进一步讲解之前，我们需要回头思考一下上面那段用于填充 <code>source</code> 数组的代码存在怎样的问题。这段代码中我们采用了两层嵌套的循环，其时间复杂度为 <code>O(n1 * n2)</code>，其中 <code>n1</code> 和 <code>n2</code> 为新旧两组子节点的数量，我们也可以使用 <code>O(n^2)</code> 来表示。当新旧两组子节点的数量较多时，两层嵌套的循环会带来性能问题。出于优化的目的，我们可以为新的一组子节点构建一张<strong>索引表</strong>，用来存储节点的 <code>key</code> 和节点位置索引之间的映射，如图 11-20 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/117.jpg" alt="图 11-20"></p><p><strong>图 11-20　使用索引表填充 <code>source</code> 数组</strong></p><p>有了索引表，我们就可以利用它快速地填充 <code>source</code> 数组，如下面的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> source</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // oldStart 和 newStart 分别为起始索引，即 j</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldStart</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newStart</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 构建索引表</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> keyIndex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newStart; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     keyIndex[newChildren[i].key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 遍历旧的一组子节点中剩余未处理的节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldStart; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     oldVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren[i]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 通过索引表快速找到新的一组子节点中具有相同 key 值的节点位置</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> keyIndex[oldVNode.key]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;undefined&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       newVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[k]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 调用 patch 函数完成更新</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVNode, newVNode, container)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 填充 source 数组</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       source[k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newStart] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">31</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 没找到</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       unmount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVNode)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">33</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">34</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">35</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>在上面这段代码中，同样使用了两个 <code>for</code> 循环，不过它们不再是嵌套的关系，所以能够将代码的时间复杂度降至 <code>O(n)</code>。其中，第一个 <code>for</code> 循环用来构建索引表，索引表存储的是节点的 <code>key</code> 值与节点在新的一组子节点中位置索引之间的映射，第二个 <code>for</code> 循环用来遍历旧的一组子节点。可以看到，我们拿旧子节点的 <code>key</code> 值去索引表 <code>keyIndex</code> 中查找该节点在新的一组子节点中的位置，并将查找结果存储到变量 <code>k</code> 中。如果 <code>k</code> 存在，说明该节点是可复用的，所以我们调用 <code>patch</code> 函数进行打补丁，并填充 <code>source</code> 数组；否则说明该节点已经不存在于新的一组子节点中了，这时我们需要调用 <code>unmount</code> 函数卸载它。</p><p>上述流程执行完毕后，<code>source</code> 数组已经填充完毕了。接下来我们应该思考的是，如何判断节点是否需要移动。实际上，快速 Diff 算法判断节点是否需要移动的方法与简单 Diff 算法类似，如下面的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 构造 source 数组</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 新的一组子节点中剩余未处理节点的数量</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> source</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldStart</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newStart</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 新增两个变量，moved 和 pos</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> moved </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> keyIndex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newStart; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     keyIndex[newChildren[i].key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldStart; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     oldVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren[i]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> keyIndex[oldVNode.key]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;undefined&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       newVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[k]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVNode, newVNode, container)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       source[k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newStart] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 判断节点是否需要移动</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pos) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         moved </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">33</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">34</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">35</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">36</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       unmount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVNode)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">37</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">38</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">39</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>在上面这段代码中，我们新增了两个变量 <code>moved</code> 和 <code>pos</code>。前者的初始值为 <code>false</code>，代表是否需要移动节点，后者的初始值为 <code>0</code>，代表遍历旧的一组子节点的过程中遇到的最大索引值 <code>k</code>。我们在讲解简单 Diff 算法时曾提到，如果在遍历过程中遇到的索引值呈现递增趋势，则说明不需要移动节点，反之则需要。所以在第二个 <code>for</code> 循环内，我们通过比较变量 <code>k</code> 与变量 <code>pos</code> 的值来判断是否需要移动节点。</p><p>除此之外，我们还需要一个数量标识，代表<strong>已经更新过的节点数量</strong>。我们知道，<strong>已经更新过的节点数量</strong>应该小于新的一组子节点中需要更新的节点数量。一旦前者超过后者，则说明有多余的节点，我们应该将它们卸载，如下面的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 构造 source 数组</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> source</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldStart</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newStart</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> moved </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> keyIndex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newStart; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     keyIndex[newChildren[i].key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 新增 patched 变量，代表更新过的节点数量</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> patched </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldStart; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     oldVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren[i]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 如果更新过的节点数量小于等于需要更新的节点数量，则执行更新</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (patched </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> keyIndex[oldVNode.key]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;undefined&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         newVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[k]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVNode, newVNode, container)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 每更新一个节点，都将 patched 变量 +1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         patched</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         source[k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newStart] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pos) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">33</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           moved </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">34</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">35</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">36</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">37</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">38</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 没找到</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">39</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         unmount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVNode)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">40</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">41</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 如果更新过的节点数量大于需要更新的节点数量，则卸载多余的节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">43</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       unmount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVNode)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">44</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">45</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">46</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>在上面这段代码中，我们增加了 <code>patched</code> 变量，其初始值为 <code>0</code>，代表更新过的节点数量。接着，在第二个 <code>for</code> 循环中增加了判断 <code>patched &lt;= count</code>，如果此条件成立，则正常执行更新，并且每次更新后都让变量 <code>patched</code> 自增；否则说明剩余的节点都是多余的，于是调用 <code>unmount</code> 函数将它们卸载。</p><p>现在，我们通过判断变量 <code>moved</code> 的值，已经能够知道是否需要移动节点，同时也处理了很多边界条件。接下来我们讨论如何移动节点。</p><h3 id="_11-3-如何移动元素" tabindex="-1">11.3　如何移动元素 <a class="header-anchor" href="#_11-3-如何移动元素" aria-label="Permalink to &quot;11.3　如何移动元素&quot;">​</a></h3><p>在上一节中，我们实现了两个目标。</p><ul><li>判断是否需要进行 DOM 移动操作。我们创建了变量 <code>moved</code> 作为标识，当它的值为 <code>true</code> 时，说明需要进行 DOM 移动操作。</li><li>构建 <code>source</code> 数组。该数组的长度等于新的一组子节点<strong>去掉</strong>相同的前置/后置节点后，剩余未处理节点的数量。<code>source</code> 数组中存储着新的一组子节点中的节点在旧的一组子节点中的位置，后面我们会根据 <code>source</code> 数组计算出一个<strong>最长递增子序列</strong>，用于 DOM 移动操作。</li></ul><p>接下来，我们讨论如何进行 DOM 移动操作，如下面的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldStart; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEnd; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (moved) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 如果 moved 为真，则需要进行 DOM 移动操作</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>在上面这段代码中，我们在 <code>for</code> 循环后增加了一个 <code>if</code> 判断分支。如果变量 <code>moved</code> 的值为 <code>true</code>，则说明需要进行 DOM 移动操作，所以用于 DOM 移动操作的逻辑将编写在该 <code>if</code> 语句块内。</p><p>为了进行 DOM 移动操作，我们首先要根据 <code>source</code> 数组计算出它的最长递增子序列。<code>source</code> 数组仍然取用在 11.2 节中给出的例子，如图 11-21 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/118.jpg" alt="图 11-21"></p><p><strong>图 11-21　用于计算 <code>source</code> 数组的递增子序列的例子</strong></p><p>在这个例子中，我们计算出 <code>source</code> 数组为 <code>[2, 3, 1, -1]</code>。那么，该数组的最长递增子序列是什么呢？这就需要我们了解最长递增子序列的概念。为此，我们先要搞清楚什么是一个序列的递增子序列。简单来说，给定一个数值序列，找到它的一个子序列，并且该子序列中的值是递增的，子序列中的元素在原序列中不一定连续。一个序列可能有很多个递增子序列，其中最长的那一个就称为最长递增子序列。举个例子，假设给定数值序列 <code>[ 0, 8, 4, 12 ]</code>，那么它的最长递增子序列就是 <code>[0, 8, 12]</code>。当然，对于同一个数值序列来说，它的最长递增子序列可能有多个，例如 <code>[0, 4, 12]</code> 也是本例的答案之一。</p><p>理解了什么是最长递增子序列，接下来我们就可以求解 <code>source</code> 数组的最长递增子序列了，如下面的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (moved) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 计算最长递增子序列</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> seq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sources) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [ 0, 1 ]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>在上面这段代码中，我们使用 <code>lis</code> 函数计算一个数组的最长递增子序列。<code>lis</code> 函数接收 <code>source</code> 数组作为参数，并返回 <code>source</code> 数组的最长递增子序列之一。在上例中，你可能疑惑为什么通过 <code>lis</code> 函数计算得到的是 <code>[0, 1]</code>？实际上，<code>source</code> 数组 <code>[2, 3, 1, -1]</code> 的最长递增子序列应该是 <code>[2, 3]</code>，但我们得到的结果是 <code>[0, 1]</code>，这是为什么呢？这是因为 <code>lis</code> 函数的返回结果是最长递增子序列中的元素在 <code>source</code> 数组中的位置索引，如图 11-22 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/119.jpg" alt="图 11-22 "></p><p><strong>图 11-22　递增子序列中存储的是 <code>source</code> 数组内元素的位置索引</strong></p><p>因为 <code>source</code> 数组的最长递增子序列为 <code>[2, 3]</code>，其中元素 <code>2</code> 在该数组中的索引为 <code>0</code>，而数组 <code>3</code> 在该数组中的索引为 <code>1</code>，所以最终结果为 <code>[0, 1]</code>。</p><p>有了最长递增子序列的索引信息后，下一步要重新对节点进行编号，如图 11-23 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/120.jpg" alt="图 11-23"></p><p><strong>图 11-23　重新对节点进行编号后的状态</strong></p><p>观察图 11-23，在编号时，我们忽略了经过预处理的节点 <code>p-1</code> 和 <code>p-5</code>。所以，索引为 <code>0</code> 的节点是 <code>p-2</code>，而索引为 <code>1</code> 节点是 <code>p-3</code>，以此类推。重新编号是为了让子序列 <code>seq</code> 与新的索引值产生对应关系。其实，最长递增子序列 <code>seq</code> 拥有一个非常重要的意义。以上例来说，子序列 <code>seq</code> 的值为 <code>[0, 1]</code>，它的含义是：<strong>在新的一组子节点中，重新编号后索引值为 <code>0</code> 和 <code>1</code> 的这两个节点在更新前后顺序没有发生变化</strong>。换句话说，重新编号后，索引值为 <code>0</code> 和 <code>1</code> 的节点不需要移动。在新的一组子节点中，节点 <code>p-3</code> 的索引为 <code>0</code>，节点 <code>p-4</code> 的索引为 <code>1</code>，所以节点 <code>p-3</code> 和 <code>p-4</code> 所对应的真实 DOM 不需要移动。换句话说，只有节点 <code>p-2</code> 和 <code>p-7</code> 可能需要移动。</p><p>为了完成节点的移动，我们还需要创建两个索引值 <code>i</code> 和 <code>s</code>：</p><ul><li>用索引 <code>i</code> 指向新的一组子节点中的最后一个节点；</li><li>用索引 <code>s</code> 指向最长递增子序列中的最后一个元素。</li></ul><p>如图 11-24 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/121.jpg" alt="图 11-24"></p><p><strong>图 11-24　建立索引 <code>s</code> 和 <code>i</code>，分别指向子序列和索引的最后一个位置</strong></p><p>观察图 11-24，为了简化图示，我们在去掉了旧的一组子节点以及无关的线条和变量。接下来，我们将开启一个 <code>for</code> 循环，让变量 <code>i</code> 和 <code>s</code> 按照图 11-24 中箭头的方向移动，如下面的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (moved) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> seq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sources)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // s 指向最长递增子序列的最后一个元素</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> seq.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // i 指向新的一组子节点的最后一个元素</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // for 循环使得 i 递减，即按照图 11-24 中箭头的方向移动</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> seq[s]) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 如果节点的索引 i 不等于 seq[s] 的值，说明该节点需要移动</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 当 i === seq[s] 时，说明该位置的节点不需要移动</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 只需要让 s 指向下一个位置</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>其中，<code>for</code> 循环的目的是让变量 <code>i</code> 按照图 11-24 中箭头的方向移动，以便能够逐个访问新的一组子节点中的节点，这里的变量 <code>i</code> 就是节点的索引。在 <code>for</code> 循环内，判断条件 <code>i !== seq[s]</code>，如果节点的索引 <code>i</code> 不等于 <code>seq[s]</code> 的值，则说明该节点对应的真实 DOM 需要移动，否则说明当前访问的节点不需要移动，但这时变量 <code>s</code> 需要按照图 11-24 中箭头的方向移动，即让变量 <code>s</code> 递减。</p><p>接下来我们就按照上述思路执行更新。初始时索引 <code>i</code> 指向节点 <code>p-7</code>。由于节点 <code>p-7</code> 对应的 <code>source</code> 数组中相同位置的元素值为 <code>-1</code>，所以我们应该将节点 <code>p-7</code> 作为全新的节点进行挂载，如下面的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (moved) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> seq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sources)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // s 指向最长递增子序列的最后一个元素</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> seq.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // i 指向新的一组子节点的最后一个元素</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // for 循环使得 i 递减，即按照图 11-24 中箭头的方向移动</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (source[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 说明索引为 i 的节点是全新的节点，应该将其挂载</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 该节点在新 children 中的真实位置索引</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pos</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newStart</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newVNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[pos]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 该节点的下一个节点的位置索引</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nextPos</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 锚点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> anchor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nextPos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[nextPos].el</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         :</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 挂载</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, newVNode, container, anchor)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> seq[s]) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 如果节点的索引 i 不等于 seq[s] 的值，说明该节点需要移动</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 当 i === seq[s] 时，说明该位置的节点不需要移动</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 只需要让 s 指向下一个位置</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>如果 <code>source[i]</code> 的值为 <code>-1</code>，则说明索引为 <code>i</code> 的节点是全新的节点，于是我们调用 <code>patch</code> 函数将其挂载到容器中。这里需要注意的是，由于索引 <code>i</code> 是重新编号后的，因此为了得到真实索引值，我们需要计算表达式 <code>i + newStart</code> 的值。</p><p>新节点创建完毕后，<code>for</code> 循环已经执行了一次，此时索引 <code>i</code> 向上移动一步，指向了节点 <code>p-2</code>，如图 11-25 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/122.jpg" alt="图 11-25 "></p><p><strong>图 11-25　节点以及索引的当前状态</strong></p><p>接着，进行下一轮 <code>for</code> 循环，步骤如下。</p><ul><li>第一步：<code>source[i]</code> 是否等于 <code>-1</code>？很明显，此时索引 <code>i</code> 的值为 <code>2</code>，<code>source[2]</code> 的值等于 <code>1</code>，因此节点 <code>p-2</code> 不是全新的节点，不需要挂载它，进行下一步的判断。</li><li>第二步：<code>i !== seq[s]</code> 是否成立？此时索引 <code>i</code> 的值为 <code>2</code>，索引 <code>s</code> 的值为 <code>1</code>。因此 <code>2 !== seq[1]</code> 成立，节点 <code>p-2</code> 所对应的真实 DOM 需要移动。</li></ul><p>在第二步中，我们知道了节点 <code>p-2</code> 所对应的真实 DOM 应该移动。实现代码如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (moved) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> seq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sources)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // s 指向最长递增子序列的最后一个元素</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> seq.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (source[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> seq[s]) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 说明该节点需要移动</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 该节点在新的一组子节点中的真实位置索引</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pos</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newStart</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newVNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[pos]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 该节点的下一个节点的位置索引</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nextPos</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 锚点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> anchor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nextPos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren[nextPos].el</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         :</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 移动</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newVNode.el, container, anchor)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 当 i === seq[s] 时，说明该位置的节点不需要移动</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 并让 s 指向下一个位置</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>可以看到，移动节点的实现思路类似于挂载全新的节点。不同点在于，移动节点是通过 <code>insert</code> 函数来完成的。</p><p>接着，进行下一轮的循环。此时索引 <code>i</code> 指向节点 <code>p-4</code>，如图 11-26 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/123.jpg" alt=" 11-26"></p><p><strong>图 11-26　节点以及索引的当前状态</strong></p><p>更新过程仍然分为三个步骤。</p><ul><li>第一步：判断表达式 <code>source[i]</code> 的值是否等于 <code>-1</code>？很明显，此时索引 <code>i</code> 的值为 <code>1</code>，表达式 <code>source[1]</code> 的值等于 <code>3</code>，条件不成立。所以节点 <code>p-4</code> 不是全新的节点，不需要挂载它。接着进行下一步判断。</li><li>第二步：判断表达式 <code>i !== seq[s]</code> 是否成立？此时索引 <code>i</code> 的值为 <code>1</code>，索引 <code>s</code> 的值为 <code>1</code>。这时表达式 <code>1 === seq[1]</code> 为真，所以条件 <code>i !== seq[s]</code> 也不成立。</li><li>第三步：由于第一步和第二步中的条件都不成立，所以代码会执行最终的 <code>else</code> 分支。这意味着，节点 <code>p-4</code> 所对应的真实 DOM 不需要移动，但我们仍然需要让索引 <code>s</code> 的值递减，即 <code>s--</code>。</li></ul><p>经过三步判断之后，我们得出结论：节点 <code>p-4</code> 不需要移动。于是进行下一轮循环，此时的状态如图 11-27 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/124.jpg" alt="图 11-27"></p><p><strong>图 11-27　节点以及索引的当前状态</strong></p><p>由图 11-27 可知，此时索引 <code>i</code> 指向节点 <code>p-3</code>。我们继续进行三个步骤的判断。</p><ul><li>第一步：判断表达式 <code>source[i]</code> 的值是否等于 <code>-1</code>？很明显，此时索引 <code>i</code> 的值为 <code>0</code>，表达式 <code>source[0]</code> 的值等于 <code>2</code>，所以节点 <code>p-3</code> 不是全新的节点，不需要挂载它，接着进行下一步判断。</li><li>第二步：判断表达式 <code>i !== seq[s]</code> 是否成立？此时索引 <code>i</code> 的值为 <code>0</code>，索引 <code>s</code> 的值也为 <code>0</code>。这时表达式 <code>0 === seq[0]</code> 为真，因此条件也不成立，最终将执行 <code>else</code> 分支的代码，也就是第三步。</li><li>第三步：到了这里，意味着节点 <code>p-3</code> 所对应的真实 DOM 也不需要移动。</li></ul><p>在这一轮更新完成之后，循环将会停止，更新完成。</p><p>需要强调的是，关于给定序列的递增子序列的求法不在本书的讲解范围内，网络上有大量文章讲解了这方面的内容，读者可以自行查阅。如下是用于求解给定序列的最长递增子序列的代码，取自 Vue.js 3：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getSequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i, j, u, v, c</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> len</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arrI</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr[i]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (arrI </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result[result.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (arr[j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arrI) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         p[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         result.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         continue</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (arr[result[c]] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arrI) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (arrI </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr[result[u]]) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           p[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result[u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         result[u] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">33</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">34</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result[u </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">35</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">36</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     result[u] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">37</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p[v]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">38</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">39</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">40</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><h3 id="_11-4-总结" tabindex="-1">11.4　总结 <a class="header-anchor" href="#_11-4-总结" aria-label="Permalink to &quot;11.4　总结&quot;">​</a></h3><p>快速 Diff 算法在实测中性能最优。它借鉴了文本 Diff 中的预处理思路，先处理新旧两组子节点中相同的前置节点和相同的后置节点。当前置节点和后置节点全部处理完毕后，如果无法简单地通过挂载新节点或者卸载已经不存在的节点来完成更新，则需要根据节点的索引关系，构造出一个最长递增子序列。最长递增子序列所指向的节点即为不需要移动的节点。</p><h2 id="第-12-章-组件的实现原理" tabindex="-1">第 12 章　组件的实现原理 <a class="header-anchor" href="#第-12-章-组件的实现原理" aria-label="Permalink to &quot;第 12 章　组件的实现原理&quot;">​</a></h2><h2 id="第-14-章-内建组件和模块" tabindex="-1">第 14 章　内建组件和模块 <a class="header-anchor" href="#第-14-章-内建组件和模块" aria-label="Permalink to &quot;第 14 章　内建组件和模块&quot;">​</a></h2><h3 id="_14-1-keepalive-组件的实现原理" tabindex="-1">14.1　KeepAlive 组件的实现原理 <a class="header-anchor" href="#_14-1-keepalive-组件的实现原理" aria-label="Permalink to &quot;14.1　KeepAlive 组件的实现原理&quot;">​</a></h3><h4 id="_14-1-1-组件的激活与失活" tabindex="-1">14.1.1　组件的激活与失活 <a class="header-anchor" href="#_14-1-1-组件的激活与失活" aria-label="Permalink to &quot;14.1.1　组件的激活与失活&quot;">​</a></h4><p>KeepAlive 一词借鉴于 HTTP 协议。在 HTTP 协议中，KeepAlive 又称 <strong>HTTP 持久连接</strong>（HTTP persistent connection），其作用是允许多个请求或响应共用一个 TCP 连接。在没有 KeepAlive 的情况下，一个 HTTP 连接会在每次请求/响应结束后关闭，当下一次请求发生时，会建立一个新的 HTTP 连接。频繁地销毁、创建 HTTP 连接会带来额外的性能开销，KeepAlive 就是为了解决这个问题而生的。</p><p>HTTP 中的 KeepAlive 可以避免连接频繁地销毁/创建，与 HTTP 中的 KeepAlive 类似，Vue.js 内建的 KeepAlive 组件可以避免一个组件被频繁地销毁/重建。假设我们的页面中有一组 <code>&lt;Tab&gt;</code> 组件，如下面的代码所示：</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">01 &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">02   &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Tab</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> v-if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">currentTab </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;...&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Tab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">03   &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Tab</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> v-if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">currentTab </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;...&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Tab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">04   &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Tab</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> v-if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">currentTab </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;...&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Tab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">05 &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>可以看到，根据变量 <code>currentTab</code> 值的不同，会渲染不同的 <code>&lt;Tab&gt;</code> 组件。当用户频繁地切换 Tab 时，会导致不停地卸载并重建对应的 <code>&lt;Tab&gt;</code> 组件。为了避免因此产生的性能开销，可以使用 KeepAlive 组件来解决这个问题，如下面的代码所示：</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">01 &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">02   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 使用 KeepAlive 组件包裹 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">03   &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">KeepAlive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">04     &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Tab</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> v-if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">currentTab </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;...&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Tab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">05     &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Tab</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> v-if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">currentTab </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;...&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Tab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">06     &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Tab</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> v-if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">currentTab </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;...&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Tab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">07   &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">KeepAlive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">08 &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>这样，无论用户怎样切换 <code>&lt;Tab&gt;</code> 组件，都不会发生频繁的创建和销毁，因而会极大地优化对用户操作的响应，尤其是在大组件场景下，优势会更加明显。那么，KeepAlive 组件的实现原理是怎样的呢？其实 KeepAlive 的本质是缓存管理，再加上特殊的挂载/卸载逻辑。</p><p>首先，KeepAlive 组件的实现需要渲染器层面的支持。这是因为被 KeepAlive 的组件在卸载时，我们不能真的将其卸载，否则就无法维持组件的当前状态了。正确的做法是，将被 KeepAlive 的组件从原容器搬运到另外一个隐藏的容器中，实现“假卸载”。当被搬运到隐藏容器中的组件需要再次被“挂载”时，我们也不能执行真正的挂载逻辑，而应该把该组件从隐藏容器中再搬运到原容器。这个过程对应到组件的生命周期，其实就是 <code>activated</code> 和 <code>deactivated</code>。</p><p>图 14-1 描述了“卸载”和“挂载”一个被 KeepAlive 的组件的过程。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/125.jpg" alt="图 14-1"></p><p><strong>图 14-1　“卸载”和“挂载”一个被 KeepAlive 的组件的过程</strong></p><p>如图 14-1 所示，“卸载”一个被 KeepAlive 的组件时，它并不会真的被卸载，而会被移动到一个隐藏容器中。当重新“挂载”该组件时，它也不会被真的挂载，而会被从隐藏容器中取出，再“放回”原来的容器中，即页面中。</p><p>一个最基本的 KeepAlive 组件实现起来并不复杂，如下面的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> KeepAlive</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // KeepAlive 组件独有的属性，用作标识</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   __isKeepAlive: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   setup(props, { slots }) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 创建一个缓存对象</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // key: vnode.type</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // value: vnode</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 当前 KeepAlive 组件的实例</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> instance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentInstance</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 对于 KeepAlive 组件来说，它的实例上存在特殊的 keepAliveCtx 对象，该对象由渲染器注入</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 该对象会暴露渲染器的一些内部方法，其中 move 函数用来将一段 DOM 移动到另一个容器中</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> instance.keepAliveCtx</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 创建隐藏容器</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> storageContainer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // KeepAlive 组件的实例上会被添加两个内部函数，分别是 _deActivate 和 _activate</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 这两个函数会在渲染器中被调用</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     instance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_deActivate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vnode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vnode, storageContainer)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     instance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_activate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vnode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">anchor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vnode, container, anchor)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // KeepAlive 的默认插槽就是要被 KeepAlive 的组件</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rawVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slots.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 如果不是组件，直接渲染即可，因为非组件的虚拟节点无法被 KeepAlive</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">31</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rawVNode.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;object&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rawVNode</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">33</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">34</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">35</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 在挂载时先获取缓存的组件 vnode</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">36</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cachedVNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rawVNode.type)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">37</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (cachedVNode) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">38</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 如果有缓存的内容，则说明不应该执行挂载，而应该执行激活</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">39</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 继承组件实例</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">40</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         rawVNode.component </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cachedVNode.component</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">41</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 在 vnode 上添加 keptAlive 属性，标记为 true，避免渲染器重新挂载它</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         rawVNode.keptAlive </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">43</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">44</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 如果没有缓存，则将其添加到缓存中，这样下次激活组件时就不会执行新的挂载动作了</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">45</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rawVNode.type, rawVNode)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">46</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">47</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">48</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 在组件 vnode 上添加 shouldKeepAlive 属性，并标记为 true，避免渲染器真的将组件卸载</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">49</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       rawVNode.shouldKeepAlive </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 将 KeepAlive 组件的实例也添加到 vnode 上，以便在渲染器中访问</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">51</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       rawVNode.keepAliveInstance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> instance</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">52</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">53</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 渲染组件 vnode</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">54</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rawVNode</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">55</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">56</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">57</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>从上面的实现中可以看到，与普通组件的一个较大的区别在于，KeepAlive 组件与渲染器的结合非常深。首先，KeepAlive 组件本身并不会渲染额外的内容，它的渲染函数最终只返回需要被 KeepAlive 的组件，我们把这个需要被 KeepAlive 的组件称为“内部组件”。KeepAlive 组件会对“内部组件”进行操作，主要是在“内部组件”的 <code>vnode</code> 对象上添加一些标记属性，以便渲染器能够据此执行特定的逻辑。这些标记属性包括如下几个。</p><ul><li><p><code>shouldKeepAlive</code>：该属性会被添加到“内部组件”的 <code>vnode</code> 对象上，这样当渲染器卸载“内部组件”时，可以通过检查该属性得知“内部组件”需要被 KeepAlive。于是，渲染器就不会真的卸载“内部组件”，而是会调用 <code>_deActivate</code> 函数完成搬运工作，如下面的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 卸载操作</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> unmount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vnode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (vnode.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Fragment) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     vnode.children.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> unmount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     return</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vnode.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;object&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // vnode.shouldKeepAlive 是一个布尔值，用来标识该组件是否应该被 KeepAlive</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (vnode.shouldKeepAlive) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 对于需要被 KeepAlive 的组件，我们不应该真的卸载它，而应调用该组件的父组件，</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 即 KeepAlive 组件的 _deActivate 函数使其失活</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       vnode.keepAliveInstance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_deActivate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vnode)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       unmount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vnode.component.subTree)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     return</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> parent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vnode.el.parentNode</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (parent) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     parent.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vnode.el)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>可以看到，<code>unmount</code> 函数在卸载组件时，会检测组件是否应该被 KeepAlive，从而执行不同的操作。</p></li><li><p><code>keepAliveInstance</code>：“内部组件”的 <code>vnode</code> 对象会持有 KeepAlive 组件实例，在 <code>unmount</code> 函数中会通过 <code>keepAliveInstance</code> 来访问 <code>_deActivate</code> 函数。</p></li><li><p><code>keptAlive</code>：“内部组件”如果已经被缓存，则还会为其添加一个 <code>keptAlive</code> 标记。这样当“内部组件”需要重新渲染时，渲染器并不会重新挂载它，而会将其激活，如下面 <code>patch</code> 函数的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">anchor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n1.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n2.type) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     unmount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n1)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     n1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n2</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;string&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Text) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Fragment) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;object&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;function&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // component</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n1) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 如果该组件已经被 KeepAlive，则不会重新挂载它，而是会调用 _activate 来激活它</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n2.keptAlive) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         n2.keepAliveInstance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_activate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n2, container, anchor)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         mountComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n2, container, anchor)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       patchComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n1, n2, anchor)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>可以看到，如果组件的 <code>vnode</code> 对象中存在 <code>keptAlive</code> 标识，则渲染器不会重新挂载它，而是会通过 <code>keepAliveInstance._activate</code> 函数来激活它。</p><p>我们再来看一下用于激活组件和失活组件的两个函数：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> instance.keepAliveCtx</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> instance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_deActivate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vnode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vnode, storageContainer)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> instance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_activate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vnode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">anchor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vnode, container, anchor)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>可以看到，失活的本质就是将组件所渲染的内容移动到隐藏容器中，而激活的本质是将组件所渲染的内容从隐藏容器中搬运回原来的容器。另外，上面这段代码中涉及的 <code>move</code> 函数是由渲染器注入的，如下面 <code>mountComponent</code> 函数的代码所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mountComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vnode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">anchor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> instance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     state,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     props: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shallowReactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(props),</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     isMounted: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     subTree: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     slots,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     mounted: [],</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 只有 KeepAlive 组件的实例下会有 keepAliveCtx 属性</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     keepAliveCtx: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 检查当前要挂载的组件是否是 KeepAlive 组件</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> isKeepAlive</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vnode.type.__isKeepAlive</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (isKeepAlive) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 在 KeepAlive 组件实例上添加 keepAliveCtx 对象</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     instance.keepAliveCtx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // move 函数用来移动一段 vnode</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       move(vnode, container, anchor) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 本质上是将组件渲染的内容移动到指定容器中，即隐藏容器中</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vnode.component.subTree.el, container, anchor)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       createElement</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 省略部分代码</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>至此，一个最基本的 KeepAlive 组件就完成了。</p></li></ul><h3 id="_14-4-总结" tabindex="-1">14.4　总结 <a class="header-anchor" href="#_14-4-总结" aria-label="Permalink to &quot;14.4　总结&quot;">​</a></h3><p>在本章中，我们介绍了 Vue.js 内建的三个组件，即 KeepAlive 组件、Teleport 组件和 Transition 组件。它们的共同特点是，与渲染器的结合非常紧密，因此需要框架提供底层的实现与支持。</p><p>KeepAlive 组件的作用类似于 HTTP 中的持久链接。它可以避免组件实例不断地被销毁和重建。KeepAlive 的基本实现并不复杂。当被 KeepAlive 的组件“卸载”时，渲染器并不会真的将其卸载掉，而是会将该组件搬运到一个隐藏容器中，从而使得组件可以维持当前状态。当被 KeepAlive 的组件“挂载”时，渲染器也不会真的挂载它，而是将它从隐藏容器搬运到原容器。</p><p>我们还讨论了 KeepAlive 的其他能力，如匹配策略和缓存策略。<code>include</code> 和 <code>exclude</code> 这两个选项用来指定哪些组件需要被 KeepAlive，哪些组件不需要被 KeepAlive。默认情况下，<code>include</code> 和 <code>exclude</code> 会匹配组件的 <code>name</code> 选项。但是在具体实现中，我们可以扩展匹配能力。对于缓存策略，Vue.js 默认采用“最新一次访问”。为了让用户能自行实现缓存策略，我们还介绍了正在讨论中的提案。</p><p>接着，我们讨论了 Teleport 组件所要解决的问题和它的实现原理。Teleport 组件可以跨越 DOM 层级完成渲染，这在很多场景下非常有用。在实现 Teleport 时，我们将 Teleport 组件的渲染逻辑从渲染器中分离出来，这么做有两点好处：</p><ul><li>可以避免渲染器逻辑代码“膨胀”；</li><li>可以利用 Tree-Shaking 机制在最终的 bundle 中删除 Teleport 相关的代码，使得最终构建包的体积变小。</li></ul><p>Teleport 组件是一个特殊的组件。与普通组件相比，它的组件选项非常特殊，例如 <code>__isTeleport</code> 选型和 <code>process</code> 选项等。这是因为 Teleport 本质上是渲染器逻辑的合理抽象，它完全可以作为渲染器的一部分而存在。</p><p>最后，我们讨论了 Transition 组件的原理与实现。我们从原生 DOM 过渡开始，讲解了如何使用 JavaScript 为 DOM 元素添加进场动效和离场动效。在此过程中，我们将实现动效的过程分为多个阶段，即 <code>beforeEnter</code>、<code>enter</code>、<code>leave</code> 等。Transition 组件的实现原理与为原生 DOM 添加过渡效果的原理类似，我们将过渡相关的钩子函数定义到虚拟节点的 <code>vnode.transition</code> 对象中。渲染器在执行挂载和卸载操作时，会优先检查该虚拟节点是否需要进行过渡，如果需要，则会在合适的时机执行 <code>vnode.transition</code> 对象中定义的过渡相关钩子函数。</p><h2 id="第-15-章-编译器核心技术概览" tabindex="-1">第 15 章　编译器核心技术概览 <a class="header-anchor" href="#第-15-章-编译器核心技术概览" aria-label="Permalink to &quot;第 15 章　编译器核心技术概览&quot;">​</a></h2><h3 id="_15-1-模板-dsl-的编译器" tabindex="-1">15.1　模板 DSL 的编译器 <a class="header-anchor" href="#_15-1-模板-dsl-的编译器" aria-label="Permalink to &quot;15.1　模板 DSL 的编译器&quot;">​</a></h3><p>编译器其实只是一段程序，它用来将“一种语言 A”翻译成“另外一种语言 B”。其中，语言 A 通常叫作<strong>源代码</strong>（source code），语言 B 通常叫作<strong>目标代码</strong>（object code 或 target code）。编译器将源代码翻译为目标代码的过程叫作<strong>编译</strong>（compile）。</p><p>​ 对于 Vue.js 模板编译器来说，源代码就是组件的模板，而目标代码是能够在浏览器平台上运行的 JavaScript 代码，或其他拥有 JavaScript 运行时的平台代码，如图 15-2 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/128.jpg" alt="图 15-2"></p><p><strong>图 15-2　Vue.js 模板编译器的目标代码是 JavaScript 代码</strong></p><p>可以看到，Vue.js 模板编译器的目标代码其实就是渲染函数。详细而言，Vue.js 模板编译器会首先对模板进行词法分析和语法分析，得到模板 AST。接着，将模板 AST <strong>转换</strong>（transform）成 JavaScript AST。最后，根据 JavaScript AST 生成 JavaScript 代码，即渲染函数代码。图 15-3 给出了 Vue.js 模板编译器的工作流程。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/129.jpg" alt="图 15-3"></p><p><strong>图 15-3　Vue.js 模板编译器的工作流程</strong></p><p>AST 是 abstract syntax tree 的首字母缩写，即抽象语法树。所谓模板 AST，其实就是用来描述模板的抽象语法树。举个例子，假设我们有如下模板：</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">01 &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">02   &lt;h1 v-if=&quot;ok&quot;&gt;Vue Template&lt;/h1&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">03 &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>这段模板会被编译为如下所示的 AST：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ast</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 逻辑根节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Root&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   children: [</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // div 标签节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">07</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Element&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">08</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">09</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       children: [</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // h1 标签节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Element&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;h1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           props: [</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             // v-if 指令节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">               type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Directive&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 类型为 Directive 代表指令</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">               name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;if&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 指令名称为 if，不带有前缀 v-</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">               exp: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                 // 表达式节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                 type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Expression&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                 content: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ok&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">               }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           ]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">26</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       ]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">28</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   ]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>可以看到，AST 其实就是一个具有层级结构的对象。模板 AST 具有与模板同构的嵌套结构。每一棵 AST 都有一个逻辑上的根节点，其类型为 <code>Root</code>。模板中真正的根节点则作为 <code>Root</code> 节点的 <code>children</code> 存在。观察上面的 <code>AST</code>，我们可以得出如下结论。</p><ul><li>不同类型的节点是通过节点的 <code>type</code> 属性进行区分的。例如标签节点的 <code>type</code> 值为 <code>&#39;Element&#39;</code>。</li><li>标签节点的子节点存储在其 <code>children</code> 数组中。</li><li>标签节点的属性节点和指令节点会存储在 <code>props</code> 数组中。</li><li>不同类型的节点会使用不同的对象属性进行描述。例如指令节点拥有 <code>name</code> 属性，用来表达指令的名称，而表达式节点拥有 <code>content</code> 属性，用来描述表达式的内容。</li></ul><p>我们可以通过封装 <code>parse</code> 函数来完成对模板的词法分析和语法分析，得到模板 AST，如图 15-4 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/130.jpg" alt="图 15-4"></p><p><strong>图 15-4　<code>parse</code> 函数的作用</strong></p><p>我们也可以用下面的代码来表达模板解析的过程：</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">01 const template = `</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">02   &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">03     &lt;h1 v-if=&quot;ok&quot;&gt;Vue Template&lt;/h1&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">04   &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">05 `</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">06</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">07 const templateAST = parse(template)</span></span></code></pre></div><p>可以看到，<code>parse</code> 函数接收字符串模板作为参数，并将解析后得到的 AST 作为返回值返回。</p><p>有了模板 AST 后，我们就可以对其进行语义分析，并对模板 AST 进行转换了。什么是语义分析呢？举几个例子。</p><ul><li>检查 <code>v-else</code> 指令是否存在相符的 <code>v-if</code> 指令。</li><li>分析属性值是否是静态的，是否是常量等。</li><li>插槽是否会引用上层作用域的变量。</li><li>……</li></ul><p>在语义分析的基础上，我们即可得到模板 AST。接着，我们还需要将模板 AST 转换为 JavaScript AST。因为 Vue.js 模板编译器的最终目标是生成渲染函数，而渲染函数本质上是 JavaScript 代码，所以我们需要将模板 AST 转换成用于描述渲染函数的 JavaScript AST。</p><p>我们可以封装 <code>transform</code> 函数来完成模板 AST 到 JavaScript AST 的转换工作，如图 15-5 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/131.jpg" alt="图 15-5"></p><p><strong>图 15-5　<code>transform</code> 函数的作用</strong></p><p>同样，我们也可以用下面的代码来表达：</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">01 const templateAST = parse(template)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">02 const jsAST = transform(templateAST)</span></span></code></pre></div><p>有了 JavaScript AST 后，我们就可以根据它生成渲染函数了，这一步可以通过封装 <code>generate</code> 函数来完成，如图 15-6 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/132.jpg" alt="图 15-6 "></p><p><strong>图 15-6　<code>generate</code> 函数的作用</strong></p><p>我们也可以用下面的代码来表达代码生成的过程：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const templateAST = parse(template)</span></span>
<span class="line"><span>02 const jsAST = transform(templateAST)</span></span>
<span class="line"><span>03 const code = generate(jsAST)</span></span></code></pre></div><p>在上面这段代码中，<code>generate</code> 函数会将渲染函数的代码以字符串的形式返回，并存储在 <code>code</code> 常量中。图 15-7 给出了完整的流程。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/133.jpg" alt="图 15-7"></p><p><strong>图 15-7　将 Vue.js 模板编译为渲染函数的完整流程</strong></p><h3 id="_15-2-parser-的实现原理与状态机" tabindex="-1">15.2　<code>parser</code> 的实现原理与状态机 <a class="header-anchor" href="#_15-2-parser-的实现原理与状态机" aria-label="Permalink to &quot;15.2　`parser` 的实现原理与状态机&quot;">​</a></h3><p>在上一节中，我们讲解了 Vue.js 模板编译器的基本结构和工作流程，它主要由三个部分组成：</p><ul><li>用来将模板字符串解析为模板 AST 的解析器（<code>parser</code>）；</li><li>用来将模板 AST 转换为 JavaScript AST 的转换器（<code>transformer</code>）；</li><li>用来根据 JavaScript AST 生成渲染函数代码的生成器（<code>generator</code>）。</li></ul><p>本节，我们将详细讨论解析器 <code>parser</code> 的实现原理。</p><p>解析器的入参是字符串模板，解析器会逐个读取字符串模板中的字符，并根据一定的规则将整个字符串切割为一个个 Token。这里的 Token 可以视作词法记号，后续我们将使用 Token 一词来代表词法记号进行讲解。举例来说，假设有这样一段模板：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;p&gt;Vue&lt;/p&gt;</span></span></code></pre></div><p>解析器会把这段字符串模板切割为三个 Token。</p><ul><li>开始标签：<code>&lt;p&gt;</code>。</li><li>文本节点：<code>Vue</code>。</li><li>结束标签：<code>&lt;/p&gt;</code>。</li></ul><p>那么，解析器是如何对模板进行切割的呢？依据什么规则？这就不得不提到有限状态自动机。千万不要被这个名词吓到，它理解起来并不难。所谓“有限状态”，就是指有限个状态，而“自动机”意味着随着字符的输入，解析器会自动地在不同状态间迁移。拿上面的模板来说，当我们分析这段模板字符串时，<code>parse</code> 函数会逐个读取字符，状态机会有一个初始状态，我们记为“初始状态 1”。图 15-8 给出了状态迁移的过程。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/134.jpg" alt="图 15-8 "></p><p><strong>图 15-8　解析器的状态机图</strong></p><p>我们用自然语言来描述图 15-8 给出的状态迁移过程。</p><ul><li>状态机始于“初始状态 1”。</li><li>在“初始状态 1”下，读取模板的第一个字符 <code>&lt;</code>，状态机会进入下一个状态，即“标签开始状态 2”。</li><li>在“标签开始状态 2”下，读取下一个字符 <code>p</code>。由于字符 <code>p</code> 是字母，所以状态机会进入“标签名称状态 3”。</li><li>在“标签名称状态 3”下，读取下一个字符 <code>&gt;</code>，此时状态机会从“标签名称状态 3”迁移回“初始状态 1”，并记录在“标签名称状态”下产生的标签名称 <code>p</code>。</li><li>在“初始状态 1”下，读取下一个字符 <code>V</code>，此时状态机会进入“文本状态 4”。</li><li>在“文本状态 4”下，继续读取后续字符，直到遇到字符 <code>&lt;</code> 时，状态机会再次进入“标签开始状态 2”，并记录在“文本状态 4”下产生的文本内容，即字符串“<code>Vue</code>”。</li><li>在“标签开始状态 2”下，读取下一个字符 <code>/</code>，状态机会进入“结束标签状态 5”。</li><li>在“结束标签状态 5”下，读取下一个字符 <code>p</code>，状态机会进入“结束标签名称状态 6”。</li><li>在“结束标签名称状态 6”下，读取最后一个字符 <code>&gt;</code>，它是结束标签的闭合字符，于是状态机迁移回“初始状态 1”，并记录在“结束标签名称状态 6”下生成的结束标签名称。</li></ul><p>经过这样一系列的状态迁移过程之后，我们最终就能够得到相应的 Token 了。观察图 15-8 可以发现，有的圆圈是单线的，而有的圆圈是双线的。双线代表此时状态机是一个合法的 Token。</p><p>可以看到，在“初始状态”（Data State）下，当遇到字符 <code>&lt;</code> 时，状态机会迁移到 <code>tag open state</code>，即“标签开始状态”。如果遇到字符 <code>&lt;</code> 以外的字符，规范中也都有对应的说明，应该让状态机迁移到怎样的状态。不过 Vue.js 的模板作为一个 DSL，并非必须遵守该规范。但 Vue.js 的模板毕竟是类 HTML 的实现，因此，尽可能按照规范来做，不会有什么坏处。更重要的一点是，规范中已经定义了非常详细的状态迁移过程，这对于我们编写解析器非常有帮助。</p><p>按照有限状态自动机的状态迁移过程，我们可以很容易地编写对应的代码实现。因此，有限状态自动机可以帮助我们完成对模板的<strong>标记化</strong>（tokenized），最终我们将得到一系列 Token。图 15-8 中描述的状态机的实现如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 // 定义状态机的状态</span></span>
<span class="line"><span>02 const State = {</span></span>
<span class="line"><span>03   initial: 1,    // 初始状态</span></span>
<span class="line"><span>04   tagOpen: 2,    // 标签开始状态</span></span>
<span class="line"><span>05   tagName: 3,    // 标签名称状态</span></span>
<span class="line"><span>06   text: 4,       // 文本状态</span></span>
<span class="line"><span>07   tagEnd: 5,     // 结束标签状态</span></span>
<span class="line"><span>08   tagEndName: 6  // 结束标签名称状态</span></span>
<span class="line"><span>09 }</span></span>
<span class="line"><span>10 // 一个辅助函数，用于判断是否是字母</span></span>
<span class="line"><span>11 function isAlpha(char) {</span></span>
<span class="line"><span>12   return char &gt;= &#39;a&#39; &amp;&amp; char &lt;= &#39;z&#39; || char &gt;= &#39;A&#39; &amp;&amp; char &lt;= &#39;Z&#39;</span></span>
<span class="line"><span>13 }</span></span>
<span class="line"><span>14</span></span>
<span class="line"><span>15 // 接收模板字符串作为参数，并将模板切割为 Token 返回</span></span>
<span class="line"><span>16 function tokenize(str) {</span></span>
<span class="line"><span>17   // 状态机的当前状态：初始状态</span></span>
<span class="line"><span>18   let currentState = State.initial</span></span>
<span class="line"><span>19   // 用于缓存字符</span></span>
<span class="line"><span>20   const chars = []</span></span>
<span class="line"><span>21   // 生成的 Token 会存储到 tokens 数组中，并作为函数的返回值返回</span></span>
<span class="line"><span>22   const tokens = []</span></span>
<span class="line"><span>23   // 使用 while 循环开启自动机，只要模板字符串没有被消费尽，自动机就会一直运行</span></span>
<span class="line"><span>24   while(str) {</span></span>
<span class="line"><span>25     // 查看第一个字符，注意，这里只是查看，没有消费该字符</span></span>
<span class="line"><span>26     const char = str[0]</span></span>
<span class="line"><span>27     // switch 语句匹配当前状态</span></span>
<span class="line"><span>28     switch (currentState) {</span></span>
<span class="line"><span>29       // 状态机当前处于初始状态</span></span>
<span class="line"><span>30       case State.initial:</span></span>
<span class="line"><span>31         // 遇到字符 &lt;</span></span>
<span class="line"><span>32         if (char === &#39;&lt;&#39;) {</span></span>
<span class="line"><span>33           // 1. 状态机切换到标签开始状态</span></span>
<span class="line"><span>34           currentState = State.tagOpen</span></span>
<span class="line"><span>35           // 2. 消费字符 &lt;</span></span>
<span class="line"><span>36           str = str.slice(1)</span></span>
<span class="line"><span>37         } else if (isAlpha(char)) {</span></span>
<span class="line"><span>38           // 1. 遇到字母，切换到文本状态</span></span>
<span class="line"><span>39           currentState = State.text</span></span>
<span class="line"><span>40           // 2. 将当前字母缓存到 chars 数组</span></span>
<span class="line"><span>41           chars.push(char)</span></span>
<span class="line"><span>42           // 3. 消费当前字符</span></span>
<span class="line"><span>43           str = str.slice(1)</span></span>
<span class="line"><span>44         }</span></span>
<span class="line"><span>45         break</span></span>
<span class="line"><span>46       // 状态机当前处于标签开始状态</span></span>
<span class="line"><span>47       case State.tagOpen:</span></span>
<span class="line"><span>48         if (isAlpha(char)) {</span></span>
<span class="line"><span>49           // 1. 遇到字母，切换到标签名称状态</span></span>
<span class="line"><span>50           currentState = State.tagName</span></span>
<span class="line"><span>51           // 2. 将当前字符缓存到 chars 数组</span></span>
<span class="line"><span>52           chars.push(char)</span></span>
<span class="line"><span>53           // 3. 消费当前字符</span></span>
<span class="line"><span>54           str = str.slice(1)</span></span>
<span class="line"><span>55         } else if (char === &#39;/&#39;) {</span></span>
<span class="line"><span>56           // 1. 遇到字符 /，切换到结束标签状态</span></span>
<span class="line"><span>57           currentState = State.tagEnd</span></span>
<span class="line"><span>58           // 2. 消费字符 /</span></span>
<span class="line"><span>59           str = str.slice(1)</span></span>
<span class="line"><span>60         }</span></span>
<span class="line"><span>61         break</span></span>
<span class="line"><span>62       // 状态机当前处于标签名称状态</span></span>
<span class="line"><span>63       case State.tagName:</span></span>
<span class="line"><span>64         if (isAlpha(char)) {</span></span>
<span class="line"><span>65           // 1. 遇到字母，由于当前处于标签名称状态，所以不需要切换状态，</span></span>
<span class="line"><span>66           // 但需要将当前字符缓存到 chars 数组</span></span>
<span class="line"><span>67           chars.push(char)</span></span>
<span class="line"><span>68           // 2. 消费当前字符</span></span>
<span class="line"><span>69           str = str.slice(1)</span></span>
<span class="line"><span>70         } else if (char === &#39;&gt;&#39;) {</span></span>
<span class="line"><span>71           // 1.遇到字符 &gt;，切换到初始状态</span></span>
<span class="line"><span>72           currentState = State.initial</span></span>
<span class="line"><span>73           // 2. 同时创建一个标签 Token，并添加到 tokens 数组中</span></span>
<span class="line"><span>74           // 注意，此时 chars 数组中缓存的字符就是标签名称</span></span>
<span class="line"><span>75           tokens.push({</span></span>
<span class="line"><span>76             type: &#39;tag&#39;,</span></span>
<span class="line"><span>77             name: chars.join(&#39;&#39;)</span></span>
<span class="line"><span>78           })</span></span>
<span class="line"><span>79           // 3. chars 数组的内容已经被消费，清空它</span></span>
<span class="line"><span>80           chars.length = 0</span></span>
<span class="line"><span>81           // 4. 同时消费当前字符 &gt;</span></span>
<span class="line"><span>82           str = str.slice(1)</span></span>
<span class="line"><span>83         }</span></span>
<span class="line"><span>84         break</span></span>
<span class="line"><span>85       // 状态机当前处于文本状态</span></span>
<span class="line"><span>86       case State.text:</span></span>
<span class="line"><span>87         if (isAlpha(char)) {</span></span>
<span class="line"><span>88           // 1. 遇到字母，保持状态不变，但应该将当前字符缓存到 chars 数组</span></span>
<span class="line"><span>89           chars.push(char)</span></span>
<span class="line"><span>90           // 2. 消费当前字符</span></span>
<span class="line"><span>91           str = str.slice(1)</span></span>
<span class="line"><span>92         } else if (char === &#39;&lt;&#39;) {</span></span>
<span class="line"><span>93           // 1. 遇到字符 &lt;，切换到标签开始状态</span></span>
<span class="line"><span>94           currentState = State.tagOpen</span></span>
<span class="line"><span>95           // 2. 从 文本状态 --&gt; 标签开始状态，此时应该创建文本 Token，并添加到 tokens 数组</span></span>
<span class="line"><span>96           // 注意，此时 chars 数组中的字符就是文本内容</span></span>
<span class="line"><span>97           tokens.push({</span></span>
<span class="line"><span>98             type: &#39;text&#39;,</span></span>
<span class="line"><span>99             content: chars.join(&#39;&#39;)</span></span>
<span class="line"><span>100           })</span></span>
<span class="line"><span>101           // 3. chars 数组的内容已经被消费，清空它</span></span>
<span class="line"><span>102           chars.length = 0</span></span>
<span class="line"><span>103           // 4. 消费当前字符</span></span>
<span class="line"><span>104           str = str.slice(1)</span></span>
<span class="line"><span>105         }</span></span>
<span class="line"><span>106         break</span></span>
<span class="line"><span>107       // 状态机当前处于标签结束状态</span></span>
<span class="line"><span>108       case State.tagEnd:</span></span>
<span class="line"><span>109         if (isAlpha(char)) {</span></span>
<span class="line"><span>110           // 1. 遇到字母，切换到结束标签名称状态</span></span>
<span class="line"><span>111           currentState = State.tagEndName</span></span>
<span class="line"><span>112           // 2. 将当前字符缓存到 chars 数组</span></span>
<span class="line"><span>113           chars.push(char)</span></span>
<span class="line"><span>114           // 3. 消费当前字符</span></span>
<span class="line"><span>115           str = str.slice(1)</span></span>
<span class="line"><span>116         }</span></span>
<span class="line"><span>117         break</span></span>
<span class="line"><span>118       // 状态机当前处于结束标签名称状态</span></span>
<span class="line"><span>119       case State.tagEndName:</span></span>
<span class="line"><span>120         if (isAlpha(char)) {</span></span>
<span class="line"><span>121           // 1. 遇到字母，不需要切换状态，但需要将当前字符缓存到 chars 数组</span></span>
<span class="line"><span>122           chars.push(char)</span></span>
<span class="line"><span>123           // 2. 消费当前字符</span></span>
<span class="line"><span>124           str = str.slice(1)</span></span>
<span class="line"><span>125         } else if (char === &#39;&gt;&#39;) {</span></span>
<span class="line"><span>126           // 1. 遇到字符 &gt;，切换到初始状态</span></span>
<span class="line"><span>127           currentState = State.initial</span></span>
<span class="line"><span>128           // 2. 从 结束标签名称状态 --&gt; 初始状态，应该保存结束标签名称 Token</span></span>
<span class="line"><span>129           // 注意，此时 chars 数组中缓存的内容就是标签名称</span></span>
<span class="line"><span>130           tokens.push({</span></span>
<span class="line"><span>131             type: &#39;tagEnd&#39;,</span></span>
<span class="line"><span>132             name: chars.join(&#39;&#39;)</span></span>
<span class="line"><span>133           })</span></span>
<span class="line"><span>134           // 3. chars 数组的内容已经被消费，清空它</span></span>
<span class="line"><span>135           chars.length = 0</span></span>
<span class="line"><span>136           // 4. 消费当前字符</span></span>
<span class="line"><span>137           str = str.slice(1)</span></span>
<span class="line"><span>138         }</span></span>
<span class="line"><span>139         break</span></span>
<span class="line"><span>140     }</span></span>
<span class="line"><span>141   }</span></span>
<span class="line"><span>142</span></span>
<span class="line"><span>143   // 最后，返回 tokens</span></span>
<span class="line"><span>144   return tokens</span></span>
<span class="line"><span>145 }</span></span></code></pre></div><p>上面这段代码看上去比较冗长，可优化的点非常多。这段代码高度还原了图 15-8 中展示的状态机，配合代码中的注释会更容易理解。</p><p>使用上面给出的 <code>tokenize</code> 函数来解析模板 <code>&lt;p&gt;Vue&lt;/p&gt;</code>，我们将得到三个 Token：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tokens</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> tokenize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`&lt;p&gt;Vue&lt;/p&gt;`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">02</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // [</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">03</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //   { type: &#39;tag&#39;, name: &#39;p&#39; },        // 开始标签</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">04</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //   { type: &#39;text&#39;, content: &#39;Vue&#39; },  // 文本节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">05</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //   { type: &#39;tagEnd&#39;, name: &#39;p&#39; }      // 结束标签</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">06</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // ]</span></span></code></pre></div><p>现在，你已经明白了状态机的工作原理，以及模板编译器将模板字符串切割为一个个 Token 的过程。但拿上述例子来说，我们并非总是需要所有 Token。例如，在解析模板的过程中，结束标签 Token 可以省略。这时，我们就可以调整 <code>tokenize</code> 函数的代码，并选择性地忽略结束标签 Token。当然，有时我们也可能需要更多的 Token，这都取决于具体的需求，然后据此灵活地调整代码实现。</p><p>总而言之，通过有限自动机，我们能够将模板解析为一个个 Token，进而可以用它们构建一棵 AST 了。但在具体构建 AST 之前，我们需要思考能否简化 <code>tokenize</code> 函数的代码。实际上，我们可以通过正则表达式来精简 <code>tokenize</code> 函数的代码。上文之所以没有从最开始就采用正则表达式来实现，是因为<strong>正则表达式的本质就是有限自动机</strong>。当你编写正则表达式的时候，其实就是在编写有限自动机。</p><h3 id="_15-3-构造-ast" tabindex="-1">15.3　构造 AST <a class="header-anchor" href="#_15-3-构造-ast" aria-label="Permalink to &quot;15.3　构造 AST&quot;">​</a></h3><p>实际上，不同用途的编译器之间可能会存在非常大的差异。它们唯一的共同点是，都会将源代码转换成目标代码。但如果深入细节即可发现，不同编译器之间的实现思路甚至可能完全不同，其中就包括 AST 的构造方式。对于通用用途语言（GPL）来说，例如 JavaScript 这样的脚本语言，想要为其构造 AST，较常用的一种算法叫作递归下降算法，这里面需要解决 GPL 层面才会遇到的很多问题，例如最基本的运算符优先级问题。然而，对于像 Vue.js 模板这样的 DSL 来说，首先可以确定的一点是，它不具有运算符，所以也就没有所谓的运算符优先级问题。DSL 与 GPL 的区别在于，GPL 是图灵完备的，我们可以使用 GPL 来实现 DSL。而 DSL 不要求图灵完备，它只需要满足特定场景下的特定用途即可。</p><p>为 Vue.js 的模板构造 AST 是一件很简单的事。HTML 是一种标记语言，它的格式非常固定，标签元素之间天然嵌套，形成父子关系。因此，一棵用于描述 HTML 的 AST 将拥有与 HTML 标签非常相似的树型结构。举例来说，假设有如下模板：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;</span></span></code></pre></div><p>在上面这段模板中，最外层的根节点是 <code>div</code> 标签，它有两个 <code>p</code> 标签作为子节点。同时，这两个 <code>p</code> 标签都具有一个文本节点作为子节点。我们可以将这段模板对应的 AST 设计为：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const ast = {</span></span>
<span class="line"><span>02   // AST 的逻辑根节点</span></span>
<span class="line"><span>03   type: &#39;Root&#39;,</span></span>
<span class="line"><span>04   children: [</span></span>
<span class="line"><span>05     // 模板的 div 根节点</span></span>
<span class="line"><span>06     {</span></span>
<span class="line"><span>07       type: &#39;Element&#39;,</span></span>
<span class="line"><span>08       tag: &#39;div&#39;,</span></span>
<span class="line"><span>09       children: [</span></span>
<span class="line"><span>10         // div 节点的第一个子节点 p</span></span>
<span class="line"><span>11         {</span></span>
<span class="line"><span>12           type: &#39;Element&#39;,</span></span>
<span class="line"><span>13           tag: &#39;p&#39;,</span></span>
<span class="line"><span>14           // p 节点的文本节点</span></span>
<span class="line"><span>15           children: [</span></span>
<span class="line"><span>16             {</span></span>
<span class="line"><span>17               type: &#39;Text&#39;,</span></span>
<span class="line"><span>18               content: &#39;Vue&#39;</span></span>
<span class="line"><span>19             }</span></span>
<span class="line"><span>20           ]</span></span>
<span class="line"><span>21         },</span></span>
<span class="line"><span>22         // div 节点的第二个子节点 p</span></span>
<span class="line"><span>23         {</span></span>
<span class="line"><span>24           type: &#39;Element&#39;,</span></span>
<span class="line"><span>25           tag: &#39;p&#39;,</span></span>
<span class="line"><span>26           // p 节点的文本节点</span></span>
<span class="line"><span>27           children: [</span></span>
<span class="line"><span>28             {</span></span>
<span class="line"><span>29               type: &#39;Text&#39;,</span></span>
<span class="line"><span>30               content: &#39;Template&#39;</span></span>
<span class="line"><span>31             }</span></span>
<span class="line"><span>32           ]</span></span>
<span class="line"><span>33         }</span></span>
<span class="line"><span>34       ]</span></span>
<span class="line"><span>35     }</span></span>
<span class="line"><span>36   ]</span></span>
<span class="line"><span>37 }</span></span></code></pre></div><p>可以看到，AST 在结构上与模板是“同构”的，它们都具有树型结构，如图 15-10 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/136.jpg" alt="图 15-10"></p><p><strong>图 15-10　AST 的结构</strong></p><p>了解了 AST 的结构，接下来我们的任务是，使用程序根据模板解析后生成的 Token 构造出这样一棵 AST。首先，我们使用上一节讲解的 <code>tokenize</code> 函数将本节开头给出的模板进行标记化。解析这段模板得到的 <code>tokens</code> 如下所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const tokens = tokenize(`&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;`)</span></span></code></pre></div><p>执行上面这段代码，我们将得到如下 <code>tokens</code>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const tokens = [</span></span>
<span class="line"><span>02   {type: &quot;tag&quot;, name: &quot;div&quot;},          // div 开始标签节点</span></span>
<span class="line"><span>03   {type: &quot;tag&quot;, name: &quot;p&quot;},            // p 开始标签节点</span></span>
<span class="line"><span>04   {type: &quot;text&quot;, content: &quot;Vue&quot;},      // 文本节点</span></span>
<span class="line"><span>05   {type: &quot;tagEnd&quot;, name: &quot;p&quot;},         // p 结束标签节点</span></span>
<span class="line"><span>06   {type: &quot;tag&quot;, name: &quot;p&quot;},            // p 开始标签节点</span></span>
<span class="line"><span>07   {type: &quot;text&quot;, content: &quot;Template&quot;}, // 文本节点</span></span>
<span class="line"><span>08   {type: &quot;tagEnd&quot;, name: &quot;p&quot;},         // p 结束标签节点</span></span>
<span class="line"><span>09   {type: &quot;tagEnd&quot;, name: &quot;div&quot;}        // div 结束标签节点</span></span>
<span class="line"><span>10 ]</span></span></code></pre></div><p>根据 Token 列表构建 AST 的过程，其实就是对 Token 列表进行扫描的过程。从第一个 Token 开始，顺序地扫描整个 Token 列表，直到列表中的所有 Token 处理完毕。在这个过程中，我们需要维护一个栈 <code>elementStack</code>，这个栈将用于维护元素间的父子关系。每遇到一个开始标签节点，我们就构造一个 <code>Element</code> 类型的 AST 节点，并将其压入栈中。类似地，每当遇到一个结束标签节点，我们就将当前栈顶的节点弹出。这样，栈顶的节点将始终充当父节点的角色。扫描过程中遇到的所有节点，都会作为当前栈顶节点的子节点，并添加到栈顶节点的 <code>children</code> 属性下。</p><p>还是拿上例来说，图 15-11 给出了在扫描 Token 列表之前，Token 列表、父级元素栈和 AST 三者的状态。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/137.jpg" alt="图 15-11 "></p><p><strong>图 15-11　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p><p>在图 15-11 中，左侧的是 Token 列表，我们将会按照从上到下的顺序扫描 Token 列表，中间和右侧分别展示了栈 <code>elementStack</code> 的状态和 AST 的状态。可以看到，它们最初都只有 <code>Root</code> 根节点。</p><p>接着，我们对 Token 列表进行扫描。首先，扫描到第一个 Token，即“开始标签（<code>div</code>）”，如图 15-12 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/138.jpg" alt="图 15-12"></p><p><strong>图 15-12　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p><p>由于当前扫描到的 Token 是一个开始标签节点，因此我们创建一个类型为 <code>Element</code> 的 AST 节点 <code>Element(div)</code>，然后将该节点作为当前栈顶节点的子节点。由于当前栈顶节点是 <code>Root</code> 根节点，所以我们将新建的 <code>Element(div)</code> 节点作为 <code>Root</code> 根节点的子节点添加到 AST 中，最后将新建的 <code>Element(div)</code> 节点压入 <code>elementStack</code> 栈。</p><p>接着，我们扫描下一个 Token，如图 15-13 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/139.jpg" alt="图 15-13"></p><p><strong>图 15-13　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p><p>扫描到的第二个 Token 也是一个开始标签节点，于是我们再创建一个类型为 <code>Element</code> 的 AST 节点 <code>Element(p)</code>，然后将该节点作为当前栈顶节点的子节点。由于当前栈顶节点为 <code>Element(div)</code> 节点，所以我们将新建的 <code>Element(p)</code> 节点作为 <code>Element(div)</code> 节点的子节点添加到 AST 中，最后将新建的 <code>Element(p)</code> 节点压入 <code>elementStack</code> 栈。</p><p>接着，我们扫描下一个 Token，如图 15-14 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/140.jpg" alt="图 15-14"></p><p><strong>图 15-14　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p><p>扫描到的第三个 Token 是一个文本节点，于是我们创建一个类型为 <code>Text</code> 的 AST 节点 <code>Text(Vue)</code>，然后将该节点作为当前栈顶节点的子节点。由于当前栈顶节点为 <code>Element(p)</code> 节点，所以我们将新建的 <code>Text(p)</code> 节点作为 <code>Element(p)</code> 节点的子节点添加到 AST 中。</p><p>接着，扫描下一个 Token，如图 15-15 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/141.jpg" alt="图 15-15"></p><p><strong>图 15-15　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p><p>此时扫描到的 Token 是一个结束标签，所以我们需要将栈顶的 <code>Element(p)</code> 节点从 <code>elementStack</code> 栈中弹出。接着，扫描下一个 Token，如图 15-16 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/142.jpg" alt="图 15-16 "></p><p><strong>图 15-16　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p><p>此时扫描到的 Token 是一个开始标签。我们为它新建一个 AST 节点 <code>Element(p)</code>，并将其作为当前栈顶节点 <code>Element(div)</code> 的子节点。最后，将 <code>Element(p)</code> 压入 <code>elementStack</code> 栈中，使其成为新的栈顶节点。</p><p>接着，扫描下一个 Token，如图 15-17 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/143.jpg" alt="图 15-17 "></p><p><strong>图 15-17　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p><p>此时扫描到的 Token 是一个文本节点，所以只需要为其创建一个相应的 AST 节点 <code>Text(Template)</code> 即可，然后将其作为当前栈顶节点 <code>Element(p)</code> 的子节点添加到 AST 中。</p><p>接着，扫描下一个 Token，如图 15-18 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/144.jpg" alt="图 15-18"></p><p><strong>图 15-18　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p><p>此时扫描到的 Token 是一个结束标签，于是我们将当前的栈顶节点 <code>Element(p)</code> 从 <code>elementStack</code> 栈中弹出。</p><p>接着，扫描下一个 Token，如图 15-19 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/145.jpg" alt="图 15-19 "></p><p><strong>图 15-19　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p><p>此时，扫描到了最后一个 Token，它是一个 <code>div</code> 结束标签，所以我们需要再次将当前栈顶节点 <code>Element(div)</code> 从 <code>elementStack</code> 栈中弹出。至此，所有 Token 都被扫描完毕，AST 构建完成。图 15-20 给出了最终状态。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/146.jpg" alt="图 15-20 "></p><p><strong>图 15-20　Token 列表、父级元素栈和 AST 三者的当前状态</strong></p><p>如图 15-20 所示，在所有 Token 扫描完毕后，一棵 AST 就构建完成了。</p><p>扫描 Token 列表并构建 AST 的具体实现如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 // parse 函数接收模板作为参数</span></span>
<span class="line"><span>02 function parse(str) {</span></span>
<span class="line"><span>03   // 首先对模板进行标记化，得到 tokens</span></span>
<span class="line"><span>04   const tokens = tokenize(str)</span></span>
<span class="line"><span>05   // 创建 Root 根节点</span></span>
<span class="line"><span>06   const root = {</span></span>
<span class="line"><span>07     type: &#39;Root&#39;,</span></span>
<span class="line"><span>08     children: []</span></span>
<span class="line"><span>09   }</span></span>
<span class="line"><span>10   // 创建 elementStack 栈，起初只有 Root 根节点</span></span>
<span class="line"><span>11   const elementStack = [root]</span></span>
<span class="line"><span>12</span></span>
<span class="line"><span>13   // 开启一个 while 循环扫描 tokens，直到所有 Token 都被扫描完毕为止</span></span>
<span class="line"><span>14   while (tokens.length) {</span></span>
<span class="line"><span>15     // 获取当前栈顶节点作为父节点 parent</span></span>
<span class="line"><span>16     const parent = elementStack[elementStack.length - 1]</span></span>
<span class="line"><span>17     // 当前扫描的 Token</span></span>
<span class="line"><span>18     const t = tokens[0]</span></span>
<span class="line"><span>19     switch (t.type) {</span></span>
<span class="line"><span>20       case &#39;tag&#39;:</span></span>
<span class="line"><span>21         // 如果当前 Token 是开始标签，则创建 Element 类型的 AST 节点</span></span>
<span class="line"><span>22         const elementNode = {</span></span>
<span class="line"><span>23           type: &#39;Element&#39;,</span></span>
<span class="line"><span>24           tag: t.name,</span></span>
<span class="line"><span>25           children: []</span></span>
<span class="line"><span>26         }</span></span>
<span class="line"><span>27         // 将其添加到父级节点的 children 中</span></span>
<span class="line"><span>28         parent.children.push(elementNode)</span></span>
<span class="line"><span>29         // 将当前节点压入栈</span></span>
<span class="line"><span>30         elementStack.push(elementNode)</span></span>
<span class="line"><span>31         break</span></span>
<span class="line"><span>32       case &#39;text&#39;:</span></span>
<span class="line"><span>33         // 如果当前 Token 是文本，则创建 Text 类型的 AST 节点</span></span>
<span class="line"><span>34         const textNode = {</span></span>
<span class="line"><span>35           type: &#39;Text&#39;,</span></span>
<span class="line"><span>36           content: t.content</span></span>
<span class="line"><span>37         }</span></span>
<span class="line"><span>38         // 将其添加到父节点的 children 中</span></span>
<span class="line"><span>39         parent.children.push(textNode)</span></span>
<span class="line"><span>40         break</span></span>
<span class="line"><span>41       case &#39;tagEnd&#39;:</span></span>
<span class="line"><span>42         // 遇到结束标签，将栈顶节点弹出</span></span>
<span class="line"><span>43         elementStack.pop()</span></span>
<span class="line"><span>44         break</span></span>
<span class="line"><span>45     }</span></span>
<span class="line"><span>46     // 消费已经扫描过的 token</span></span>
<span class="line"><span>47     tokens.shift()</span></span>
<span class="line"><span>48   }</span></span>
<span class="line"><span>49</span></span>
<span class="line"><span>50   // 最后返回 AST</span></span>
<span class="line"><span>51   return root</span></span>
<span class="line"><span>52 }</span></span></code></pre></div><p>上面这段代码很好地还原了上文中介绍的构建 AST 的思路，我们可以使用如下代码对其进行测试：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const ast = parse(`&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;`)</span></span></code></pre></div><p>运行这句代码，我们将得到与本节开头给出的 AST 一致的结果。这里有必要说明一点，当前的实现仍然存在诸多问题，例如无法处理自闭合标签等。</p><h3 id="_15-4-ast-的转换与插件化架构" tabindex="-1">15.4　AST 的转换与插件化架构 <a class="header-anchor" href="#_15-4-ast-的转换与插件化架构" aria-label="Permalink to &quot;15.4　AST 的转换与插件化架构&quot;">​</a></h3><p>在上一节中，我们完成了模板 AST 的构造。本节，我们将讨论关于 AST 的转换。所谓 AST 的转换，指的是对 AST 进行一系列操作，将其转换为新的 AST 的过程。新的 AST 可以是原语言或原 DSL 的描述，也可以是其他语言或其他 DSL 的描述。例如，我们可以对模板 AST 进行操作，将其转换为 JavaScript AST。转换后的 AST 可以用于代码生成。这其实就是 Vue.js 的模板编译器将模板编译为渲染函数的过程，如图 15-21 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/147.jpg" alt="图 15-21 "></p><p><strong>图 15-21　模板编译器将模板编译为渲染函数的过程</strong></p><p>其中 <code>transform</code> 函数就是用来完成 AST 转换工作的。</p><h4 id="_15-4-1-节点的访问" tabindex="-1">15.4.1　节点的访问 <a class="header-anchor" href="#_15-4-1-节点的访问" aria-label="Permalink to &quot;15.4.1　节点的访问&quot;">​</a></h4><p>为了对 AST 进行转换，我们需要能访问 AST 的每一个节点，这样才有机会对特定节点进行修改、替换、删除等操作。由于 AST 是树型数据结构，所以我们需要编写一个深度优先的遍历算法，从而实现对 AST 中节点的访问。不过，在开始编写转换代码之前，我们有必要编写一个 <code>dump</code> 工具函数，用来打印当前 AST 中节点的信息，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function dump(node, indent = 0) {</span></span>
<span class="line"><span>02   // 节点的类型</span></span>
<span class="line"><span>03   const type = node.type</span></span>
<span class="line"><span>04   // 节点的描述，如果是根节点，则没有描述</span></span>
<span class="line"><span>05   // 如果是 Element 类型的节点，则使用 node.tag 作为节点的描述</span></span>
<span class="line"><span>06   // 如果是 Text 类型的节点，则使用 node.content 作为节点的描述</span></span>
<span class="line"><span>07   const desc = node.type === &#39;Root&#39;</span></span>
<span class="line"><span>08     ? &#39;&#39;</span></span>
<span class="line"><span>09     : node.type === &#39;Element&#39;</span></span>
<span class="line"><span>10       ? node.tag</span></span>
<span class="line"><span>11       : node.content</span></span>
<span class="line"><span>12</span></span>
<span class="line"><span>13   // 打印节点的类型和描述信息</span></span>
<span class="line"><span>14   console.log(`${&#39;-&#39;.repeat(indent)}${type}: ${desc}`)</span></span>
<span class="line"><span>15</span></span>
<span class="line"><span>16   // 递归地打印子节点</span></span>
<span class="line"><span>17   if (node.children) {</span></span>
<span class="line"><span>18     node.children.forEach(n =&gt; dump(n, indent + 2))</span></span>
<span class="line"><span>19   }</span></span>
<span class="line"><span>20 }</span></span></code></pre></div><p>我们沿用上一节中给出的例子，看看使用 <code>dump</code> 函数会输出怎样的结果：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const ast = parse(`&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;`)</span></span>
<span class="line"><span>02 console.log(dump(ast))</span></span></code></pre></div><p>运行上面这段代码，将得到如下输出：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 Root:</span></span>
<span class="line"><span>02 --Element: div</span></span>
<span class="line"><span>03 ----Element: p</span></span>
<span class="line"><span>04 ------Text: Vue</span></span>
<span class="line"><span>05 ----Element: p</span></span>
<span class="line"><span>06 ------Text: Template</span></span></code></pre></div><p>可以看到，<code>dump</code> 函数以清晰的格式来展示 AST 中的节点。在后续编写 AST 的转换代码时，我们将使用 <code>dump</code> 函数来展示转换后的结果。</p><p>接下来，我们将着手实现对 AST 中节点的访问。访问节点的方式是，从 AST 根节点开始，进行深度优先遍历，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function traverseNode(ast) {</span></span>
<span class="line"><span>02   // 当前节点，ast 本身就是 Root 节点</span></span>
<span class="line"><span>03   const currentNode = ast</span></span>
<span class="line"><span>04   // 如果有子节点，则递归地调用 traverseNode 函数进行遍历</span></span>
<span class="line"><span>05   const children = currentNode.children</span></span>
<span class="line"><span>06   if (children) {</span></span>
<span class="line"><span>07     for (let i = 0; i &lt; children.length; i++) {</span></span>
<span class="line"><span>08       traverseNode(children[i])</span></span>
<span class="line"><span>09     }</span></span>
<span class="line"><span>10   }</span></span>
<span class="line"><span>11 }</span></span></code></pre></div><p><code>traverseNode</code> 函数用来以深度优先的方式遍历 AST，它的实现与 <code>dump</code> 函数几乎相同。有了 <code>traverseNdoe</code> 函数之后，我们即可实现对 AST 中节点的访问。例如，我们可以实现一个转换功能，将 AST 中所有 <code>p</code> 标签转换为 <code>h1</code> 标签，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function traverseNode(ast) {</span></span>
<span class="line"><span>02   // 当前节点，ast 本身就是 Root 节点</span></span>
<span class="line"><span>03   const currentNode = ast</span></span>
<span class="line"><span>04</span></span>
<span class="line"><span>05   // 对当前节点进行操作</span></span>
<span class="line"><span>06   if (currentNode.type === &#39;Element&#39; &amp;&amp; currentNode.tag === &#39;p&#39;) {</span></span>
<span class="line"><span>07     // 将所有 p 标签转换为 h1 标签</span></span>
<span class="line"><span>08     currentNode.tag = &#39;h1&#39;</span></span>
<span class="line"><span>09   }</span></span>
<span class="line"><span>10</span></span>
<span class="line"><span>11   // 如果有子节点，则递归地调用 traverseNode 函数进行遍历</span></span>
<span class="line"><span>12   const children = currentNode.children</span></span>
<span class="line"><span>13   if (children) {</span></span>
<span class="line"><span>14     for (let i = 0; i &lt; children.length; i++) {</span></span>
<span class="line"><span>15       traverseNode(children[i])</span></span>
<span class="line"><span>16     }</span></span>
<span class="line"><span>17   }</span></span>
<span class="line"><span>18 }</span></span></code></pre></div><p>在上面这段代码中，我们通过检查当前节点的 <code>type</code> 属性和 <code>tag</code> 属性，来确保被操作的节点是 <code>p</code> 标签。接着，我们将符合条件的节点的 <code>tag</code> 属性值修改为 <code>&#39;h1&#39;</code>，从而实现 <code>p</code> 标签到 <code>h1</code> 标签的转换。我们可以使用 <code>dump</code> 函数打印转换后的 AST 的信息，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 // 封装 transform 函数，用来对 AST 进行转换</span></span>
<span class="line"><span>02 function transform(ast) {</span></span>
<span class="line"><span>03   // 调用 traverseNode 完成转换</span></span>
<span class="line"><span>04   traverseNode(ast)</span></span>
<span class="line"><span>05   // 打印 AST 信息</span></span>
<span class="line"><span>06   console.log(dump(ast))</span></span>
<span class="line"><span>07 }</span></span>
<span class="line"><span>08</span></span>
<span class="line"><span>09 const ast = parse(`&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;`)</span></span>
<span class="line"><span>10 transform(ast)</span></span></code></pre></div><p>运行上面这段代码，我们将得到如下输出：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 Root:</span></span>
<span class="line"><span>02 --Element: div</span></span>
<span class="line"><span>03 ----Element: h1</span></span>
<span class="line"><span>04 ------Text: Vue</span></span>
<span class="line"><span>05 ----Element: h1</span></span>
<span class="line"><span>06 ------Text: Template</span></span></code></pre></div><p>可以看到，所有 <code>p</code> 标签都已经变成了 <code>h1</code> 标签。</p><p>我们还可以对 AST 进行其他转换。例如，实现一个转换，将文本节点的内容重复两次：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function traverseNode(ast) {</span></span>
<span class="line"><span>02   // 当前节点，ast 本身就是 Root 节点</span></span>
<span class="line"><span>03   const currentNode = ast</span></span>
<span class="line"><span>04</span></span>
<span class="line"><span>05   // 对当前节点进行操作</span></span>
<span class="line"><span>06   if (currentNode.type === &#39;Element&#39; &amp;&amp; currentNode.tag === &#39;p&#39;) {</span></span>
<span class="line"><span>07     // 将所有 p 标签转换为 h1 标签</span></span>
<span class="line"><span>08     currentNode.tag = &#39;h1&#39;</span></span>
<span class="line"><span>09   }</span></span>
<span class="line"><span>10</span></span>
<span class="line"><span>11   // 如果节点的类型为 Text</span></span>
<span class="line"><span>12   if (currentNode.type === &#39;Text&#39;) {</span></span>
<span class="line"><span>13     // 重复其内容两次，这里我们使用了字符串的 repeat() 方法</span></span>
<span class="line"><span>14     currentNode.content = currentNode.content.repeat(2)</span></span>
<span class="line"><span>15   }</span></span>
<span class="line"><span>16</span></span>
<span class="line"><span>17   // 如果有子节点，则递归地调用 traverseNode 函数进行遍历</span></span>
<span class="line"><span>18   const children = currentNode.children</span></span>
<span class="line"><span>19   if (children) {</span></span>
<span class="line"><span>20     for (let i = 0; i &lt; children.length; i++) {</span></span>
<span class="line"><span>21       traverseNode(children[i])</span></span>
<span class="line"><span>22     }</span></span>
<span class="line"><span>23   }</span></span>
<span class="line"><span>24 }</span></span></code></pre></div><p>如上面的代码所示，我们增加了对文本类型节点的处理代码。一旦检查到当前节点的类型为 <code>Text</code>，则调用 <code>repeat(2)</code> 方法将文本节点的内容重复两次。最终，我们将得到如下输出：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 Root:</span></span>
<span class="line"><span>02 --Element: div</span></span>
<span class="line"><span>03 ----Element: h1</span></span>
<span class="line"><span>04 ------Text: VueVue</span></span>
<span class="line"><span>05 ----Element: h1</span></span>
<span class="line"><span>06 ------Text: TemplateTemplate</span></span></code></pre></div><p>可以看到，文本节点的内容全部重复了两次。</p><p>不过，随着功能的不断增加，<code>traverseNode</code> 函数将会变得越来越“臃肿”。这时，我们很自然地想到，能否对节点的操作和访问进行解耦呢？答案是“当然可以”，我们可以使用回调函数的机制来实现解耦，如下面 <code>traverseNode</code> 函数的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 // 接收第二个参数 context</span></span>
<span class="line"><span>02 function traverseNode(ast, context) {</span></span>
<span class="line"><span>03   const currentNode = ast</span></span>
<span class="line"><span>04</span></span>
<span class="line"><span>05   // context.nodeTransforms 是一个数组，其中每一个元素都是一个函数</span></span>
<span class="line"><span>06   const transforms = context.nodeTransforms</span></span>
<span class="line"><span>07   for (let i = 0; i &lt; transforms.length; i++) {</span></span>
<span class="line"><span>08     // 将当前节点 currentNode 和 context 都传递给 nodeTransforms 中注册的回调函数</span></span>
<span class="line"><span>09     transforms[i](currentNode, context)</span></span>
<span class="line"><span>10   }</span></span>
<span class="line"><span>11</span></span>
<span class="line"><span>12   const children = currentNode.children</span></span>
<span class="line"><span>13   if (children) {</span></span>
<span class="line"><span>14     for (let i = 0; i &lt; children.length; i++) {</span></span>
<span class="line"><span>15       traverseNode(children[i], context)</span></span>
<span class="line"><span>16     }</span></span>
<span class="line"><span>17   }</span></span>
<span class="line"><span>18 }</span></span></code></pre></div><p>在上面这段代码中，我们首先为 <code>traverseNode</code> 函数增加了第二个参数 <code>context</code>。关于 <code>context</code> 的内容，下文会详细介绍。接着，我们把回调函数存储到 <code>transforms</code> 数组中，然后遍历该数组，并逐个调用注册在其中的回调函数。最后，我们将当前节点 <code>currentNode</code> 和 <code>context</code> 对象分别作为参数传递给回调函数。</p><p>有了修改后的 <code>traverseNode</code> 函数，我们就可以如下所示使用它了：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function transform(ast) {</span></span>
<span class="line"><span>02   // 在 transform 函数内创建 context 对象</span></span>
<span class="line"><span>03   const context = {</span></span>
<span class="line"><span>04     // 注册 nodeTransforms 数组</span></span>
<span class="line"><span>05     nodeTransforms: [</span></span>
<span class="line"><span>06       transformElement, // transformElement 函数用来转换标签节点</span></span>
<span class="line"><span>07       transformText     // transformText 函数用来转换文本节点</span></span>
<span class="line"><span>08     ]</span></span>
<span class="line"><span>09   }</span></span>
<span class="line"><span>10   // 调用 traverseNode 完成转换</span></span>
<span class="line"><span>11   traverseNode(ast, context)</span></span>
<span class="line"><span>12   // 打印 AST 信息</span></span>
<span class="line"><span>13   console.log(dump(ast))</span></span>
<span class="line"><span>14 }</span></span></code></pre></div><p>其中，<code>transformElement</code> 函数和 <code>transformText</code> 函数的实现如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function transformElement(node) {</span></span>
<span class="line"><span>02   if (node.type === &#39;Element&#39; &amp;&amp; node.tag === &#39;p&#39;) {</span></span>
<span class="line"><span>03     node.tag = &#39;h1&#39;</span></span>
<span class="line"><span>04   }</span></span>
<span class="line"><span>05 }</span></span>
<span class="line"><span>06</span></span>
<span class="line"><span>07 function transformText(node) {</span></span>
<span class="line"><span>08   if (node.type === &#39;Text&#39;) {</span></span>
<span class="line"><span>09     node.content = node.content.repeat(2)</span></span>
<span class="line"><span>10   }</span></span>
<span class="line"><span>11 }</span></span></code></pre></div><p>可以看到，解耦之后，节点操作封装到了 <code>transformElement</code> 和 <code>transformText</code> 这样的独立函数中。我们甚至可以编写任意多个类似的转换函数，只需要将它们注册到 <code>context.nodeTransforms</code> 中即可。这样就解决了功能增加所导致的 <code>traverseNode</code> 函数“臃肿”的问题。</p><h4 id="_15-4-2-转换上下文与节点操作" tabindex="-1">15.4.2　转换上下文与节点操作 <a class="header-anchor" href="#_15-4-2-转换上下文与节点操作" aria-label="Permalink to &quot;15.4.2　转换上下文与节点操作&quot;">​</a></h4><p>在上文中，我们将转换函数注册到 <code>context.nodeTransforms</code> 数组中。那么，为什么要使用 <code>context</code> 对象呢？直接定义一个数组不可以吗？为了搞清楚这个问题，就不得不提到关于上下文的知识。你可能或多或少听说过关于 Context（上下文）的内容，我们可以把 Context 看作程序在某个范围内的“全局变量”。实际上，上下文并不是一个具象的东西，它依赖于具体的使用场景。我们举几个例子来直观地感受一下。</p><ul><li>在编写 React 应用时，我们可以使用 <code>React.createContext</code> 函数创建一个上下文对象，该上下文对象允许我们将数据通过组件树一层层地传递下去。无论组件树的层级有多深，只要组件在这棵组件树的层级内，那么它就能够访问上下文对象中的数据。</li><li>在编写 Vue.js 应用时，我们也可以通过 <code>provide</code>/<code>inject</code> 等能力，向一整棵组件树提供数据。这些数据可以称为上下文。</li><li>在编写 Koa 应用时，中间件函数接收的 <code>context</code> 参数也是一种上下文对象，所有中间件都可以通过 <code>context</code> 来访问相同的数据。</li></ul><p>通过上述三个例子我们能够认识到，上下文对象其实就是程序在某个范围内的“全局变量”。换句话说，我们也可以把全局变量看作全局上下文。</p><p>回到我们本节讲解的 <code>context.nodeTransforms</code> 数组，这里的 <code>context</code> 可以看作 AST 转换函数过程中的上下文数据。所有 AST 转换函数都可以通过 <code>context</code> 来共享数据。上下文对象中通常会维护程序的当前状态，例如当前转换的节点是哪一个？当前转换的节点的父节点是谁？甚至当前节点是父节点的第几个子节点？等等。这些信息对于编写复杂的转换函数非常有用。所以，接下来我们要做的就是构造转换上下文信息，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function transform(ast) {</span></span>
<span class="line"><span>02   const context = {</span></span>
<span class="line"><span>03     // 增加 currentNode，用来存储当前正在转换的节点</span></span>
<span class="line"><span>04     currentNode: null,</span></span>
<span class="line"><span>05     // 增加 childIndex，用来存储当前节点在父节点的 children 中的位置索引</span></span>
<span class="line"><span>06     childIndex: 0,</span></span>
<span class="line"><span>07     // 增加 parent，用来存储当前转换节点的父节点</span></span>
<span class="line"><span>08     parent: null,</span></span>
<span class="line"><span>09     nodeTransforms: [</span></span>
<span class="line"><span>10       transformElement,</span></span>
<span class="line"><span>11       transformText</span></span>
<span class="line"><span>12     ]</span></span>
<span class="line"><span>13   }</span></span>
<span class="line"><span>14</span></span>
<span class="line"><span>15   traverseNode(ast, context)</span></span>
<span class="line"><span>16   console.log(dump(ast))</span></span>
<span class="line"><span>17 }</span></span></code></pre></div><p>在上面这段代码中，我们为转换上下文对象扩展了一些重要信息。</p><ul><li><code>currentNode</code>：用来存储当前正在转换的节点。</li><li><code>childIndex</code>：用来存储当前节点在父节点的 <code>children</code> 中的位置索引。</li><li><code>parent</code>：用来存储当前转换节点的父节点。</li></ul><p>紧接着，我们需要在合适的地方设置转换上下文对象中的数据，如下面 <code>traverseNode</code> 函数的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function traverseNode(ast, context) {</span></span>
<span class="line"><span>02   // 设置当前转换的节点信息 context.currentNode</span></span>
<span class="line"><span>03   context.currentNode = ast</span></span>
<span class="line"><span>04</span></span>
<span class="line"><span>05   const transforms = context.nodeTransforms</span></span>
<span class="line"><span>06   for (let i = 0; i &lt; transforms.length; i++) {</span></span>
<span class="line"><span>07     transforms[i](context.currentNode, context)</span></span>
<span class="line"><span>08   }</span></span>
<span class="line"><span>09</span></span>
<span class="line"><span>10   const children = context.currentNode.children</span></span>
<span class="line"><span>11   if (children) {</span></span>
<span class="line"><span>12     for (let i = 0; i &lt; children.length; i++) {</span></span>
<span class="line"><span>13       // 递归地调用 traverseNode 转换子节点之前，将当前节点设置为父节点</span></span>
<span class="line"><span>14       context.parent = context.currentNode</span></span>
<span class="line"><span>15       // 设置位置索引</span></span>
<span class="line"><span>16       context.childIndex = i</span></span>
<span class="line"><span>17       // 递归地调用时，将 context 透传</span></span>
<span class="line"><span>18       traverseNode(children[i], context)</span></span>
<span class="line"><span>19     }</span></span>
<span class="line"><span>20   }</span></span>
<span class="line"><span>21 }</span></span></code></pre></div><p>观察上面这段代码，其关键点在于，在递归地调用 <code>traverseNode</code> 函数进行子节点的转换之前，我们必须设置 <code>context.parent</code> 和 <code>context.childIndex</code> 的值，这样才能保证在接下来的递归转换中，<code>context</code> 对象所存储的信息是正确的。</p><p>有了上下文数据后，我们就可以实现节点替换功能了。什么是节点替换呢？在对 AST 进行转换的时候，我们可能希望把某些节点替换为其他类型的节点。例如，将所有文本节点替换成一个元素节点。为了完成节点替换，我们需要在上下文对象中添加 <code>context.replaceNode</code> 函数。该函数接收新的 AST 节点作为参数，并使用新节点替换当前正在转换的节点，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function transform(ast) {</span></span>
<span class="line"><span>02   const context = {</span></span>
<span class="line"><span>03     currentNode: null,</span></span>
<span class="line"><span>04     parent: null,</span></span>
<span class="line"><span>05     // 用于替换节点的函数，接收新节点作为参数</span></span>
<span class="line"><span>06     replaceNode(node) {</span></span>
<span class="line"><span>07       // 为了替换节点，我们需要修改 AST</span></span>
<span class="line"><span>08       // 找到当前节点在父节点的 children 中的位置：context.childIndex</span></span>
<span class="line"><span>09       // 然后使用新节点替换即可</span></span>
<span class="line"><span>10       context.parent.children[context.childIndex] = node</span></span>
<span class="line"><span>11       // 由于当前节点已经被新节点替换掉了，因此我们需要将 currentNode 更新为新节点</span></span>
<span class="line"><span>12       context.currentNode = node</span></span>
<span class="line"><span>13     },</span></span>
<span class="line"><span>14     nodeTransforms: [</span></span>
<span class="line"><span>15       transformElement,</span></span>
<span class="line"><span>16       transformText</span></span>
<span class="line"><span>17     ]</span></span>
<span class="line"><span>18   }</span></span>
<span class="line"><span>19</span></span>
<span class="line"><span>20   traverseNode(ast, context)</span></span>
<span class="line"><span>21   console.log(dump(ast))</span></span>
<span class="line"><span>22 }</span></span></code></pre></div><p>观察上面代码中的 <code>replaceNode</code> 函数。在该函数内，我们首先通过 <code>context.childIndex</code> 属性取得当前节点的位置索引，然后通过 <code>context.parent.children</code> 取得当前节点所在集合，最后配合使用 <code>context.childIndex</code> 与 <code>context.parent.children</code> 即可完成节点替换。另外，由于当前节点已经替换为新节点了，所以我们应该使用新节点更新 <code>context.currentNode</code> 属性的值。</p><p>接下来，我们就可以在转换函数中使用 <code>replaceNode</code> 函数对 AST 中的节点进行替换了。如下面 <code>transformText</code> 函数的代码所示，它能够将文本节点转换为元素节点：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 // 转换函数的第二个参数就是 context 对象</span></span>
<span class="line"><span>02 function transformText(node, context) {</span></span>
<span class="line"><span>03   if (node.type === &#39;Text&#39;) {</span></span>
<span class="line"><span>04     // 如果当前转换的节点是文本节点，则调用 context.replaceNode 函数将其替换为元素节点</span></span>
<span class="line"><span>05     context.replaceNode({</span></span>
<span class="line"><span>06       type: &#39;Element&#39;,</span></span>
<span class="line"><span>07       tag: &#39;span&#39;</span></span>
<span class="line"><span>08     })</span></span>
<span class="line"><span>09   }</span></span>
<span class="line"><span>10 }</span></span></code></pre></div><p>如上面的代码所示，转换函数的第二个参数就是 <code>context</code> 对象，所以我们可以在转换函数内部使用该对象上的任意属性或函数。在 <code>transformText</code> 函数内部，首先检查当前转换的节点是否是文本节点，如果是，则调用 <code>context.replaceNode</code> 函数将其替换为新的 <code>span</code> 标签节点。</p><p>下面的例子用来验证节点替换功能：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const ast = parse(`&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;`)</span></span>
<span class="line"><span>02 transform(ast)</span></span></code></pre></div><p>运行上面这段代码，其转换前后的结果分别是：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 // 转换前</span></span>
<span class="line"><span>02 Root:</span></span>
<span class="line"><span>03 --Element: div</span></span>
<span class="line"><span>04 ----Element: p</span></span>
<span class="line"><span>05 ------Text: VueVue</span></span>
<span class="line"><span>06 ----Element: p</span></span>
<span class="line"><span>07 ------Text: TemplateTemplate</span></span>
<span class="line"><span>08</span></span>
<span class="line"><span>09 // 转换后</span></span>
<span class="line"><span>10 Root:</span></span>
<span class="line"><span>11 --Element: div</span></span>
<span class="line"><span>12 ----Element: h1</span></span>
<span class="line"><span>13 ------Element: span</span></span>
<span class="line"><span>14 ----Element: h1</span></span>
<span class="line"><span>15 ------Element: span</span></span></code></pre></div><p>可以看到，转换后的 AST 中的文本节点全部变为 <code>span</code> 标签节点了。</p><p>除了替换节点，有时我们还希望移除当前访问的节点。我们可以通过实现 <code>context.removeNode</code> 函数来达到目的，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function transform(ast) {</span></span>
<span class="line"><span>02   const context = {</span></span>
<span class="line"><span>03     currentNode: null,</span></span>
<span class="line"><span>04     parent: null,</span></span>
<span class="line"><span>05     replaceNode(node) {</span></span>
<span class="line"><span>06       context.currentNode = node</span></span>
<span class="line"><span>07       context.parent.children[context.childIndex] = node</span></span>
<span class="line"><span>08     },</span></span>
<span class="line"><span>09     // 用于删除当前节点。</span></span>
<span class="line"><span>10     removeNode() {</span></span>
<span class="line"><span>11       if (context.parent) {</span></span>
<span class="line"><span>12         // 调用数组的 splice 方法，根据当前节点的索引删除当前节点</span></span>
<span class="line"><span>13         context.parent.children.splice(context.childIndex, 1)</span></span>
<span class="line"><span>14         // 将 context.currentNode 置空</span></span>
<span class="line"><span>15         context.currentNode = null</span></span>
<span class="line"><span>16       }</span></span>
<span class="line"><span>17     },</span></span>
<span class="line"><span>18     nodeTransforms: [</span></span>
<span class="line"><span>19       transformElement,</span></span>
<span class="line"><span>20       transformText</span></span>
<span class="line"><span>21     ]</span></span>
<span class="line"><span>22   }</span></span>
<span class="line"><span>23</span></span>
<span class="line"><span>24   traverseNode(ast, context)</span></span>
<span class="line"><span>25   console.log(dump(ast))</span></span>
<span class="line"><span>26 }</span></span></code></pre></div><p>移除当前访问的节点也非常简单，只需要取得其位置索引 <code>context.childIndex</code>，再调用数组的 <code>splice</code> 方法将其从所属的 <code>children</code> 列表中移除即可。另外，当节点被移除之后，不要忘记将 <code>context.currentNode</code> 的值置空。这里有一点需要注意，由于当前节点被移除了，所以后续的转换函数将不再需要处理该节点。因此，我们需要对 <code>traverseNode</code> 函数做一些调整，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function traverseNode(ast, context) {</span></span>
<span class="line"><span>02   context.currentNode = ast</span></span>
<span class="line"><span>03</span></span>
<span class="line"><span>04   const transforms = context.nodeTransforms</span></span>
<span class="line"><span>05   for (let i = 0; i &lt; transforms.length; i++) {</span></span>
<span class="line"><span>06     transforms[i](context.currentNode, context)</span></span>
<span class="line"><span>07     // 由于任何转换函数都可能移除当前节点，因此每个转换函数执行完毕后，</span></span>
<span class="line"><span>08     // 都应该检查当前节点是否已经被移除，如果被移除了，直接返回即可</span></span>
<span class="line"><span>09     if (!context.currentNode) return</span></span>
<span class="line"><span>10   }</span></span>
<span class="line"><span>11</span></span>
<span class="line"><span>12   const children = context.currentNode.children</span></span>
<span class="line"><span>13   if (children) {</span></span>
<span class="line"><span>14     for (let i = 0; i &lt; children.length; i++) {</span></span>
<span class="line"><span>15       context.parent = context.currentNode</span></span>
<span class="line"><span>16       context.childIndex = i</span></span>
<span class="line"><span>17       traverseNode(children[i], context)</span></span>
<span class="line"><span>18     }</span></span>
<span class="line"><span>19   }</span></span>
<span class="line"><span>20 }</span></span></code></pre></div><p>在修改后的 <code>traverseNode</code> 函数中，我们增加了一行代码，用于检查 <code>context.currentNode</code> 是否存在。由于任何转换函数都可能移除当前访问的节点，所以每个转换函数执行完毕后，都应该检查当前访问的节点是否已经被移除，如果被某个转换函数移除了，则 <code>traverseNode</code> 直接返回即可，无须做后续的处理。</p><p>有了 <code>context.removeNode</code> 函数之后，我们即可实现用于移除文本节点的转换函数，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function transformText(node, context) {</span></span>
<span class="line"><span>02   if (node.type === &#39;Text&#39;) {</span></span>
<span class="line"><span>03     // 如果是文本节点，直接调用 context.removeNode 函数将其移除即可</span></span>
<span class="line"><span>04     context.removeNode()</span></span>
<span class="line"><span>05   }</span></span>
<span class="line"><span>06 }</span></span></code></pre></div><p>配合上面的 <code>transformText</code> 转换函数，运行下面的用例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const ast = parse(`&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;`)</span></span>
<span class="line"><span>02 transform(ast)</span></span></code></pre></div><p>转换前后输出结果是：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 // 转换前</span></span>
<span class="line"><span>02 Root:</span></span>
<span class="line"><span>03 --Element: div</span></span>
<span class="line"><span>04 ----Element: p</span></span>
<span class="line"><span>05 ------Text: VueVue</span></span>
<span class="line"><span>06 ----Element: p</span></span>
<span class="line"><span>07 ------Text: TemplateTemplate</span></span>
<span class="line"><span>08</span></span>
<span class="line"><span>09 // 转换后</span></span>
<span class="line"><span>10 Root:</span></span>
<span class="line"><span>11 --Element: div</span></span>
<span class="line"><span>12 ----Element: h1</span></span>
<span class="line"><span>13 ----Element: h1</span></span></code></pre></div><p>可以看到，在转换后的 AST 中，将不再有任何文本节点。</p><h4 id="_15-4-3-进入与退出" tabindex="-1">15.4.3　进入与退出 <a class="header-anchor" href="#_15-4-3-进入与退出" aria-label="Permalink to &quot;15.4.3　进入与退出&quot;">​</a></h4><p>在转换 AST 节点的过程中，往往需要根据其子节点的情况来决定如何对当前节点进行转换。这就要求父节点的转换操作必须等待其所有子节点全部转换完毕后再执行。然而，我们目前设计的转换工作流并不支持这一能力。上文中介绍的转换工作流，是一种从根节点开始、顺序执行的工作流，如图 15-22 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/148.jpg" alt="图 15-22"></p><p><strong>图 15-22　顺序执行工作流</strong></p><p>从图 15-22 中可以看到，<code>Root</code> 根节点第一个被处理，节点层次越深，对它的处理将越靠后。这种顺序处理的工作流存在的问题是，当一个节点被处理时，意味着它的父节点已经被处理完毕了，并且我们无法再回过头重新处理父节点。</p><p>更加理想的转换工作流应该如图 15-23 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/149.jpg" alt="图 15-23"></p><p><strong>图 15-23　更加理想的转换工作流</strong></p><p>由图 15-23 可知，对节点的访问分为两个阶段，即进入阶段和退出阶段。当转换函数处于进入阶段时，它会先进入父节点，再进入子节点。而当转换函数处于退出阶段时，则会先退出子节点，再退出父节点。这样，只要我们在退出节点阶段对当前访问的节点进行处理，就一定能够保证其子节点全部处理完毕。</p><p>为了实现如图 15-23 所示的转换工作流，我们需要重新设计转换函数的能力，如下面 <code>traverseNode</code> 函数的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function traverseNode(ast, context) {</span></span>
<span class="line"><span>02   context.currentNode = ast</span></span>
<span class="line"><span>03   // 1. 增加退出阶段的回调函数数组</span></span>
<span class="line"><span>04   const exitFns = []</span></span>
<span class="line"><span>05   const transforms = context.nodeTransforms</span></span>
<span class="line"><span>06   for (let i = 0; i &lt; transforms.length; i++) {</span></span>
<span class="line"><span>07     // 2. 转换函数可以返回另外一个函数，该函数即作为退出阶段的回调函数</span></span>
<span class="line"><span>08     const onExit = transforms[i](context.currentNode, context)</span></span>
<span class="line"><span>09     if (onExit) {</span></span>
<span class="line"><span>10       // 将退出阶段的回调函数添加到 exitFns 数组中</span></span>
<span class="line"><span>11       exitFns.push(onExit)</span></span>
<span class="line"><span>12     }</span></span>
<span class="line"><span>13     if (!context.currentNode) return</span></span>
<span class="line"><span>14   }</span></span>
<span class="line"><span>15</span></span>
<span class="line"><span>16   const children = context.currentNode.children</span></span>
<span class="line"><span>17   if (children) {</span></span>
<span class="line"><span>18     for (let i = 0; i &lt; children.length; i++) {</span></span>
<span class="line"><span>19       context.parent = context.currentNode</span></span>
<span class="line"><span>20       context.childIndex = i</span></span>
<span class="line"><span>21       traverseNode(children[i], context)</span></span>
<span class="line"><span>22     }</span></span>
<span class="line"><span>23   }</span></span>
<span class="line"><span>24</span></span>
<span class="line"><span>25   // 在节点处理的最后阶段执行缓存到 exitFns 中的回调函数</span></span>
<span class="line"><span>26   // 注意，这里我们要反序执行</span></span>
<span class="line"><span>27   let i = exitFns.length</span></span>
<span class="line"><span>28   while (i--) {</span></span>
<span class="line"><span>29     exitFns[i]()</span></span>
<span class="line"><span>30   }</span></span>
<span class="line"><span>31 }</span></span></code></pre></div><p>在上面这段代码中，我们增加了一个数组 <code>exitFns</code>，用来存储由转换函数返回的回调函数。接着，在 <code>traverseNode</code> 函数的最后，执行这些缓存在 <code>exitFns</code> 数组中的回调函数。这样就保证了，<strong>当退出阶段的回调函数执行时，当前访问的节点的子节点已经全部处理过了</strong>。有了这些能力之后，我们在编写转换函数时，可以将转换逻辑编写在退出阶段的回调函数中，从而保证在对当前访问的节点进行转换之前，其子节点一定全部处理完毕了，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function transformElement(node, context) {</span></span>
<span class="line"><span>02   // 进入节点</span></span>
<span class="line"><span>03</span></span>
<span class="line"><span>04   // 返回一个会在退出节点时执行的回调函数</span></span>
<span class="line"><span>05   return () =&gt; {</span></span>
<span class="line"><span>06     // 在这里编写退出节点的逻辑，当这里的代码运行时，当前转换节点的子节点一定处理完毕了</span></span>
<span class="line"><span>07   }</span></span>
<span class="line"><span>08 }</span></span></code></pre></div><p>另外还有一点需要注意，退出阶段的回调函数是反序执行的。这意味着，如果注册了多个转换函数，则它们的注册顺序将决定代码的执行结果。假设我们注册的两个转换函数分别是 <code>transformA</code> 和 <code>transformB</code>，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function transform(ast) {</span></span>
<span class="line"><span>02   const context = {</span></span>
<span class="line"><span>03     // 省略部分代码</span></span>
<span class="line"><span>04</span></span>
<span class="line"><span>05     // 注册两个转换函数，transformA 先于 transformB</span></span>
<span class="line"><span>06     nodeTransforms: [</span></span>
<span class="line"><span>07       transformA,</span></span>
<span class="line"><span>08       transformB</span></span>
<span class="line"><span>09     ]</span></span>
<span class="line"><span>10   }</span></span>
<span class="line"><span>11</span></span>
<span class="line"><span>12   traverseNode(ast, context)</span></span>
<span class="line"><span>13   console.log(dump(ast))</span></span>
<span class="line"><span>14 }</span></span></code></pre></div><p>在上面这段代码中，转换函数 <code>transformA</code> 先于 <code>transformB</code> 被注册。这意味着，在执行转换时，<code>transformA</code> 的“进入阶段”会先于 <code>transformB</code> 的“进入阶段”执行，而 <code>transformA</code> 的“退出阶段”将晚于 <code>transformB</code> 的“退出阶段”执行：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 -- transformA 进入阶段执行</span></span>
<span class="line"><span>02 ---- transformB 进入阶段执行</span></span>
<span class="line"><span>03 ---- transformB 退出阶段执行</span></span>
<span class="line"><span>04 -- transformA 退出阶段执行</span></span></code></pre></div><p>这么设计的好处是，转换函数 <code>transformA</code> 将有机会等待 <code>transformB</code> 执行完毕后，再根据具体情况决定应该如何工作。</p><p>如果将 <code>transformA</code> 与 <code>transformB</code> 的顺序调换，那么转换函数的执行顺序也将改变：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 -- transformB 进入阶段执行</span></span>
<span class="line"><span>02 ---- transformA 进入阶段执行</span></span>
<span class="line"><span>03 ---- transformA 退出阶段执行</span></span>
<span class="line"><span>04 -- transformB 退出阶段执行</span></span></code></pre></div><p>由此可见，当把转换逻辑编写在转换函数的退出阶段时，不仅能够保证所有子节点全部处理完毕，还能够保证所有后续注册的转换函数执行完毕。</p><h3 id="_15-5-将模板-ast-转为-javascript-ast15-5" tabindex="-1">15.5　将模板 AST 转为 JavaScript AST15.5 <a class="header-anchor" href="#_15-5-将模板-ast-转为-javascript-ast15-5" aria-label="Permalink to &quot;15.5　将模板 AST 转为 JavaScript AST15.5&quot;">​</a></h3><p>在上一节中，我们讨论了如何对 AST 进行转换，并实现了一个基本的插件架构，即通过注册自定义的转换函数实现对 AST 的操作。本节，我们将讨论如何将模板 AST 转换为 JavaScript AST，为后续讲解代码生成做铺垫。</p><p>为什么要将模板 AST 转换为 JavaScript AST 呢？原因我们已经多次提到：我们需要将模板编译为渲染函数。而渲染函数是由 JavaScript 代码来描述的，因此，我们需要将模板 AST 转换为用于描述渲染函数的 JavaScript AST。</p><p>以上一节给出的模板为例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;</span></span></code></pre></div><p>与这段模板等价的渲染函数是：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function render() {</span></span>
<span class="line"><span>02   return h(&#39;div&#39;, [</span></span>
<span class="line"><span>03     h(&#39;p&#39;, &#39;Vue&#39;),</span></span>
<span class="line"><span>04     h(&#39;p&#39;, &#39;Template&#39;)</span></span>
<span class="line"><span>05   ])</span></span>
<span class="line"><span>06 }</span></span></code></pre></div><p>上面这段渲染函数的 JavaScript 代码所对应的 JavaScript AST 就是我们的转换目标。那么，它对应的 JavaScript AST 是什么样子的呢？与模板 AST 是模板的描述一样，JavaScript AST 是 JavaScript 代码的描述。所以，本质上我们需要设计一些数据结构来描述渲染函数的代码。</p><p>首先，我们观察上面这段渲染函数的代码。它是一个函数声明，所以我们首先要描述 JavaScript 中的函数声明语句。一个函数声明语句由以下几部分组成。</p><ul><li><code>id</code>：函数名称，它是一个标识符 <code>Identifier</code>。</li><li><code>params</code>：函数的参数，它是一个数组。</li><li><code>body</code>：函数体，由于函数体可以包含多个语句，因此它也是一个数组。</li></ul><p>为了简化问题，这里我们不考虑箭头函数、生成器函数、async 函数等情况。那么，根据以上这些信息，我们就可以设计一个基本的数据结构来描述函数声明语句：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const FunctionDeclNode = {</span></span>
<span class="line"><span>02   type: &#39;FunctionDecl&#39; // 代表该节点是函数声明</span></span>
<span class="line"><span>03   // 函数的名称是一个标识符，标识符本身也是一个节点</span></span>
<span class="line"><span>04   id: {</span></span>
<span class="line"><span>05     type: &#39;Identifier&#39;,</span></span>
<span class="line"><span>06     name: &#39;render&#39; // name 用来存储标识符的名称，在这里它就是渲染函数的名称 render</span></span>
<span class="line"><span>07   },</span></span>
<span class="line"><span>08   params: [], // 参数，目前渲染函数还不需要参数，所以这里是一个空数组</span></span>
<span class="line"><span>09   // 渲染函数的函数体只有一个语句，即 return 语句</span></span>
<span class="line"><span>10   body: [</span></span>
<span class="line"><span>11     {</span></span>
<span class="line"><span>12       type: &#39;ReturnStatement&#39;,</span></span>
<span class="line"><span>13       return: null // 暂时留空，在后续讲解中补全</span></span>
<span class="line"><span>14     }</span></span>
<span class="line"><span>15   ]</span></span>
<span class="line"><span>16 }</span></span></code></pre></div><p>如上面的代码所示，我们使用一个对象来描述一个 JavaScript AST 节点。每个节点都具有 <code>type</code> 字段，该字段用来代表节点的类型。对于函数声明语句来说，它的类型是 <code>FunctionDecl</code>。接着，我们使用 <code>id</code> 字段来存储函数的名称。函数的名称应该是一个合法的标识符，因此 <code>id</code> 字段本身也是一个类型为 <code>Identifier</code> 的节点。当然，我们在设计 JavaScript AST 的时候，可以根据实际需要进行调整。例如，我们完全可以将 <code>id</code> 字段设计为一个字符串类型的值。这样做虽然不完全符合 JavaScript 的语义，但是能够满足我们的需求。对于函数的参数，我们使用 <code>params</code> 数组来存储。目前，我们设计的渲染函数还不需要参数，因此暂时设为空数组。最后，我们使用 <code>body</code> 字段来描述函数的函数体。一个函数的函数体内可以存在多个语句，所以我们使用一个数组来描述它。该数组内的每个元素都对应一条语句，对于渲染函数来说，目前它只有一个返回语句，所以我们使用一个类型为 <code>ReturnStatement</code> 的节点来描述该返回语句。</p><p>介绍完函数声明语句的节点结构后，我们再来看一下渲染函数的返回值。渲染函数返回的是虚拟 DOM 节点，具体体现在 <code>h</code> 函数的调用。我们可以使用 <code>CallExpression</code> 类型的节点来描述函数调用语句，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const CallExp = {</span></span>
<span class="line"><span>02   type: &#39;CallExpression&#39;,</span></span>
<span class="line"><span>03   // 被调用函数的名称，它是一个标识符</span></span>
<span class="line"><span>04   callee: {</span></span>
<span class="line"><span>05     type: &#39;Identifier&#39;,</span></span>
<span class="line"><span>06     name: &#39;h&#39;</span></span>
<span class="line"><span>07   },</span></span>
<span class="line"><span>08   // 参数</span></span>
<span class="line"><span>09   arguments: []</span></span>
<span class="line"><span>10 }</span></span></code></pre></div><p>类型为 <code>CallExpression</code> 的节点拥有两个属性。</p><ul><li><code>callee</code>：用来描述被调用函数的名称，它本身是一个标识符节点。</li><li><code>arguments</code>：被调用函数的形式参数，多个参数的话用数组来描述。</li></ul><p>我们再次观察渲染函数的返回值：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function render() {</span></span>
<span class="line"><span>02   // h 函数的第一个参数是一个字符串字面量</span></span>
<span class="line"><span>03   // h 函数的第二个参数是一个数组</span></span>
<span class="line"><span>04   return h(&#39;div&#39;, [/*...*/])</span></span>
<span class="line"><span>05 }</span></span></code></pre></div><p>可以看到，最外层的 <code>h</code> 函数的第一个参数是一个字符串字面量，我们可以使用类型为 <code>StringLiteral</code> 的节点来描述它：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const Str = {</span></span>
<span class="line"><span>02   type: &#39;StringLiteral&#39;,</span></span>
<span class="line"><span>03   value: &#39;div&#39;</span></span>
<span class="line"><span>04 }</span></span></code></pre></div><p>最外层的 <code>h</code> 函数的第二个参数是一个数组，我们可以使用类型为 <code>ArrayExpression</code> 的节点来描述它：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const Arr = {</span></span>
<span class="line"><span>02   type: &#39;ArrayExpression&#39;,</span></span>
<span class="line"><span>03   // 数组中的元素</span></span>
<span class="line"><span>04   elements: []</span></span>
<span class="line"><span>05 }</span></span></code></pre></div><p>使用上述 <code>CallExpression</code>、<code>StringLiteral</code>、<code>ArrayExpression</code> 等节点来填充渲染函数的返回值，其最终结果如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const FunctionDeclNode = {</span></span>
<span class="line"><span>02   type: &#39;FunctionDecl&#39; // 代表该节点是函数声明</span></span>
<span class="line"><span>03   // 函数的名称是一个标识符，标识符本身也是一个节点</span></span>
<span class="line"><span>04   id: {</span></span>
<span class="line"><span>05     type: &#39;Identifier&#39;,</span></span>
<span class="line"><span>06     name: &#39;render&#39; // name 用来存储标识符的名称，在这里它就是渲染函数的名称 render</span></span>
<span class="line"><span>07   },</span></span>
<span class="line"><span>08   params: [], // 参数，目前渲染函数还不需要参数，所以这里是一个空数组</span></span>
<span class="line"><span>09   // 渲染函数的函数体只有一个语句，即 return 语句</span></span>
<span class="line"><span>10   body: [</span></span>
<span class="line"><span>11     {</span></span>
<span class="line"><span>12       type: &#39;ReturnStatement&#39;,</span></span>
<span class="line"><span>13       // 最外层的 h 函数调用</span></span>
<span class="line"><span>14       return: {</span></span>
<span class="line"><span>15         type: &#39;CallExpression&#39;,</span></span>
<span class="line"><span>16         callee: { type: &#39;Identifier&#39;, name: &#39;h&#39; },</span></span>
<span class="line"><span>17         arguments: [</span></span>
<span class="line"><span>18           // 第一个参数是字符串字面量 &#39;div&#39;</span></span>
<span class="line"><span>19           {</span></span>
<span class="line"><span>20             type: &#39;StringLiteral&#39;,</span></span>
<span class="line"><span>21             value: &#39;div&#39;</span></span>
<span class="line"><span>22           },</span></span>
<span class="line"><span>23           // 第二个参数是一个数组</span></span>
<span class="line"><span>24           {</span></span>
<span class="line"><span>25             type: &#39;ArrayExpression&#39;,</span></span>
<span class="line"><span>26             elements: [</span></span>
<span class="line"><span>27               // 数组的第一个元素是 h 函数的调用</span></span>
<span class="line"><span>28               {</span></span>
<span class="line"><span>29                 type: &#39;CallExpression&#39;,</span></span>
<span class="line"><span>30                 callee: { type: &#39;Identifier&#39;, name: &#39;h&#39; },</span></span>
<span class="line"><span>31                 arguments: [</span></span>
<span class="line"><span>32                   // 该 h 函数调用的第一个参数是字符串字面量</span></span>
<span class="line"><span>33                   { type: &#39;StringLiteral&#39;, value: &#39;p&#39; },</span></span>
<span class="line"><span>34                   // 第二个参数也是一个字符串字面量</span></span>
<span class="line"><span>35                   { type: &#39;StringLiteral&#39;, value: &#39;Vue&#39; },</span></span>
<span class="line"><span>36                 ]</span></span>
<span class="line"><span>37               },</span></span>
<span class="line"><span>38               // 数组的第二个元素也是 h 函数的调用</span></span>
<span class="line"><span>39               {</span></span>
<span class="line"><span>40                 type: &#39;CallExpression&#39;,</span></span>
<span class="line"><span>41                 callee: { type: &#39;Identifier&#39;, name: &#39;h&#39; },</span></span>
<span class="line"><span>42                 arguments: [</span></span>
<span class="line"><span>43                   // 该 h 函数调用的第一个参数是字符串字面量</span></span>
<span class="line"><span>44                   { type: &#39;StringLiteral&#39;, value: &#39;p&#39; },</span></span>
<span class="line"><span>45                   // 第二个参数也是一个字符串字面量</span></span>
<span class="line"><span>46                   { type: &#39;StringLiteral&#39;, value: &#39;Template&#39; },</span></span>
<span class="line"><span>47                 ]</span></span>
<span class="line"><span>48               }</span></span>
<span class="line"><span>49             ]</span></span>
<span class="line"><span>50           }</span></span>
<span class="line"><span>51         ]</span></span>
<span class="line"><span>52       }</span></span>
<span class="line"><span>53     }</span></span>
<span class="line"><span>54   ]</span></span>
<span class="line"><span>55 }</span></span></code></pre></div><p>如上面这段 JavaScript AST 的代码所示，它是对渲染函数代码的完整描述。接下来我们的任务是，编写转换函数，将模板 AST 转换为上述 JavaScript AST。不过在开始之前，我们需要编写一些用来创建 JavaScript AST 节点的辅助函数，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 // 用来创建 StringLiteral 节点</span></span>
<span class="line"><span>02 function createStringLiteral(value) {</span></span>
<span class="line"><span>03   return {</span></span>
<span class="line"><span>04     type: &#39;StringLiteral&#39;,</span></span>
<span class="line"><span>05     value</span></span>
<span class="line"><span>06   }</span></span>
<span class="line"><span>07 }</span></span>
<span class="line"><span>08 // 用来创建 Identifier 节点</span></span>
<span class="line"><span>09 function createIdentifier(name) {</span></span>
<span class="line"><span>10   return {</span></span>
<span class="line"><span>11     type: &#39;Identifier&#39;,</span></span>
<span class="line"><span>12     name</span></span>
<span class="line"><span>13   }</span></span>
<span class="line"><span>14 }</span></span>
<span class="line"><span>15 // 用来创建 ArrayExpression 节点</span></span>
<span class="line"><span>16 function createArrayExpression(elements) {</span></span>
<span class="line"><span>17   return {</span></span>
<span class="line"><span>18     type: &#39;ArrayExpression&#39;,</span></span>
<span class="line"><span>19     elements</span></span>
<span class="line"><span>20   }</span></span>
<span class="line"><span>21 }</span></span>
<span class="line"><span>22 // 用来创建 CallExpression 节点</span></span>
<span class="line"><span>23 function createCallExpression(callee, arguments) {</span></span>
<span class="line"><span>24   return {</span></span>
<span class="line"><span>25     type: &#39;CallExpression&#39;,</span></span>
<span class="line"><span>26     callee: createIdentifier(callee),</span></span>
<span class="line"><span>27     arguments</span></span>
<span class="line"><span>28   }</span></span>
<span class="line"><span>29 }</span></span></code></pre></div><p>有了这些辅助函数，我们可以更容易地编写转换代码。</p><p>为了把模板 AST 转换为 JavaScript AST，我们同样需要两个转换函数：<code>transformElement</code> 和 <code>transformText</code>，它们分别用来处理标签节点和文本节点。具体实现如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 // 转换文本节点</span></span>
<span class="line"><span>02 function transformText(node) {</span></span>
<span class="line"><span>03   // 如果不是文本节点，则什么都不做</span></span>
<span class="line"><span>04   if (node.type !== &#39;Text&#39;) {</span></span>
<span class="line"><span>05     return</span></span>
<span class="line"><span>06   }</span></span>
<span class="line"><span>07   // 文本节点对应的 JavaScript AST 节点其实就是一个字符串字面量，</span></span>
<span class="line"><span>08   // 因此只需要使用 node.content 创建一个 StringLiteral 类型的节点即可</span></span>
<span class="line"><span>09   // 最后将文本节点对应的 JavaScript AST 节点添加到 node.jsNode 属性下</span></span>
<span class="line"><span>10   node.jsNode = createStringLiteral(node.content)</span></span>
<span class="line"><span>11 }</span></span>
<span class="line"><span>12</span></span>
<span class="line"><span>13 // 转换标签节点</span></span>
<span class="line"><span>14 function transformElement(node) {</span></span>
<span class="line"><span>15   // 将转换代码编写在退出阶段的回调函数中，</span></span>
<span class="line"><span>16   // 这样可以保证该标签节点的子节点全部被处理完毕</span></span>
<span class="line"><span>17   return () =&gt; {</span></span>
<span class="line"><span>18     // 如果被转换的节点不是元素节点，则什么都不做</span></span>
<span class="line"><span>19     if (node.type !== &#39;Element&#39;) {</span></span>
<span class="line"><span>20       return</span></span>
<span class="line"><span>21     }</span></span>
<span class="line"><span>22</span></span>
<span class="line"><span>23     // 1. 创建 h 函数调用语句,</span></span>
<span class="line"><span>24     // h 函数调用的第一个参数是标签名称，因此我们以 node.tag 来创建一个字符串字面量节点</span></span>
<span class="line"><span>25     // 作为第一个参数</span></span>
<span class="line"><span>26     const callExp = createCallExpression(&#39;h&#39;, [</span></span>
<span class="line"><span>27       createStringLiteral(node.tag)</span></span>
<span class="line"><span>28     ])</span></span>
<span class="line"><span>29     // 2. 处理 h 函数调用的参数</span></span>
<span class="line"><span>30     node.children.length === 1</span></span>
<span class="line"><span>31       // 如果当前标签节点只有一个子节点，则直接使用子节点的 jsNode 作为参数</span></span>
<span class="line"><span>32       ? callExp.arguments.push(node.children[0].jsNode)</span></span>
<span class="line"><span>33       // 如果当前标签节点有多个子节点，则创建一个 ArrayExpression 节点作为参数</span></span>
<span class="line"><span>34       : callExp.arguments.push(</span></span>
<span class="line"><span>35         // 数组的每个元素都是子节点的 jsNode</span></span>
<span class="line"><span>36         createArrayExpression(node.children.map(c =&gt; c.jsNode))</span></span>
<span class="line"><span>37       )</span></span>
<span class="line"><span>38     // 3. 将当前标签节点对应的 JavaScript AST 添加到 jsNode 属性下</span></span>
<span class="line"><span>39     node.jsNode = callExp</span></span>
<span class="line"><span>40   }</span></span>
<span class="line"><span>41 }</span></span></code></pre></div><p>如上面的代码及注释所示，总体实现并不复杂。有两点需要注意：</p><ul><li>在转换标签节点时，我们需要将转换逻辑编写在退出阶段的回调函数内，这样才能保证其子节点全部被处理完毕；</li><li>无论是文本节点还是标签节点，它们转换后的 JavaScript AST 节点都存储在节点的 <code>node.jsNode</code> 属性下。</li></ul><p>使用上面两个转换函数即可完成标签节点和文本节点的转换，即把模板转换成 <code>h</code> 函数的调用。但是，转换后得到的 AST 只是用来描述渲染函数 <code>render</code> 的返回值的，所以我们最后一步要做的就是，补全 JavaScript AST，即把用来描述 <code>render</code> 函数本身的函数声明语句节点附加到 JavaScript AST 中。这需要我们编写 <code>transformRoot</code> 函数来实现对 <code>Root</code> 根节点的转换：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 // 转换 Root 根节点</span></span>
<span class="line"><span>02 function transformRoot(node) {</span></span>
<span class="line"><span>03   // 将逻辑编写在退出阶段的回调函数中，保证子节点全部被处理完毕</span></span>
<span class="line"><span>04   return () =&gt; {</span></span>
<span class="line"><span>05     // 如果不是根节点，则什么都不做</span></span>
<span class="line"><span>06     if (node.type !== &#39;Root&#39;) {</span></span>
<span class="line"><span>07       return</span></span>
<span class="line"><span>08     }</span></span>
<span class="line"><span>09     // node 是根节点，根节点的第一个子节点就是模板的根节点，</span></span>
<span class="line"><span>10     // 当然，这里我们暂时不考虑模板存在多个根节点的情况</span></span>
<span class="line"><span>11     const vnodeJSAST = node.children[0].jsNode</span></span>
<span class="line"><span>12     // 创建 render 函数的声明语句节点，将 vnodeJSAST 作为 render 函数体的返回语句</span></span>
<span class="line"><span>13     node.jsNode = {</span></span>
<span class="line"><span>14       type: &#39;FunctionDecl&#39;,</span></span>
<span class="line"><span>15       id: { type: &#39;Identifier&#39;, name: &#39;render&#39; },</span></span>
<span class="line"><span>16       params: [],</span></span>
<span class="line"><span>17       body: [</span></span>
<span class="line"><span>18         {</span></span>
<span class="line"><span>19           type: &#39;ReturnStatement&#39;,</span></span>
<span class="line"><span>20           return: vnodeJSAST</span></span>
<span class="line"><span>21         }</span></span>
<span class="line"><span>22       ]</span></span>
<span class="line"><span>23     }</span></span>
<span class="line"><span>24   }</span></span>
<span class="line"><span>25 }</span></span></code></pre></div><p>经过这一步处理之后，模板 AST 将转换为对应的 JavaScript AST，并且可以通过根节点的 <code>node.jsNode</code> 来访问转换后的 JavaScript AST。下一节我们将讨论如何根据转换后得到的 JavaScript AST 生成渲染函数代码。</p><h3 id="_15-6-代码生成" tabindex="-1">15.6　代码生成 <a class="header-anchor" href="#_15-6-代码生成" aria-label="Permalink to &quot;15.6　代码生成&quot;">​</a></h3><p>在上一节中，我们完成了 JavaScript AST 的构造。本节，我们将讨论如何根据 JavaScript AST 生成渲染函数的代码，即代码生成。代码生成本质上是字符串拼接的艺术。我们需要访问 JavaScript AST 中的节点，为每一种类型的节点生成相符的 JavaScript 代码。</p><p>本节，我们将实现 <code>generate</code> 函数来完成代码生成的任务。代码生成也是编译器的最后一步：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function compile(template) {</span></span>
<span class="line"><span>02   // 模板 AST</span></span>
<span class="line"><span>03   const ast = parse(template)</span></span>
<span class="line"><span>04   // 将模板 AST 转换为 JavaScript AST</span></span>
<span class="line"><span>05   transform(ast)</span></span>
<span class="line"><span>06   // 代码生成</span></span>
<span class="line"><span>07   const code = generate(ast.jsNode)</span></span>
<span class="line"><span>08</span></span>
<span class="line"><span>09   return code</span></span>
<span class="line"><span>10 }</span></span></code></pre></div><p>与 AST 转换一样，代码生成也需要上下文对象。该上下文对象用来维护代码生成过程中程序的运行状态，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function generate(node) {</span></span>
<span class="line"><span>02   const context = {</span></span>
<span class="line"><span>03     // 存储最终生成的渲染函数代码</span></span>
<span class="line"><span>04     code: &#39;&#39;,</span></span>
<span class="line"><span>05     // 在生成代码时，通过调用 push 函数完成代码的拼接</span></span>
<span class="line"><span>06     push(code) {</span></span>
<span class="line"><span>07       context.code += code</span></span>
<span class="line"><span>08     }</span></span>
<span class="line"><span>09   }</span></span>
<span class="line"><span>10</span></span>
<span class="line"><span>11   // 调用 genNode 函数完成代码生成的工作，</span></span>
<span class="line"><span>12   genNode(node, context)</span></span>
<span class="line"><span>13</span></span>
<span class="line"><span>14   // 返回渲染函数代码</span></span>
<span class="line"><span>15   return context.code</span></span>
<span class="line"><span>16 }</span></span></code></pre></div><p>在上面这段 <code>generate</code> 函数的代码中，首先我们定义了上下文对象 <code>context</code>，它包含 <code>context.code</code> 属性，用来存储最终生成的渲染函数代码，还定义了 <code>context.push</code> 函数，用来完成代码拼接，接着调用 <code>genNode</code> 函数完成代码生成的工作，最后将最终生成的渲染函数代码返回。</p><p>另外，我们希望最终生成的代码具有较强的可读性，因此我们应该考虑生成代码的格式，例如缩进和换行等。这就需要我们扩展 <code>context</code> 对象，为其增加用来完成换行和缩进的工具函数，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function generate(node) {</span></span>
<span class="line"><span>02   const context = {</span></span>
<span class="line"><span>03     code: &#39;&#39;,</span></span>
<span class="line"><span>04     push(code) {</span></span>
<span class="line"><span>05       context.code += code</span></span>
<span class="line"><span>06     },</span></span>
<span class="line"><span>07     // 当前缩进的级别，初始值为 0，即没有缩进</span></span>
<span class="line"><span>08     currentIndent: 0,</span></span>
<span class="line"><span>09     // 该函数用来换行，即在代码字符串的后面追加 \n 字符，</span></span>
<span class="line"><span>10     // 另外，换行时应该保留缩进，所以我们还要追加 currentIndent * 2 个空格字符</span></span>
<span class="line"><span>11     newline() {</span></span>
<span class="line"><span>12       context.code += &#39;\n&#39; + `  `.repeat(context.currentIndent)</span></span>
<span class="line"><span>13     },</span></span>
<span class="line"><span>14     // 用来缩进，即让 currentIndent 自增后，调用换行函数</span></span>
<span class="line"><span>15     indent() {</span></span>
<span class="line"><span>16       context.currentIndent++</span></span>
<span class="line"><span>17       context.newline()</span></span>
<span class="line"><span>18     },</span></span>
<span class="line"><span>19     // 取消缩进，即让 currentIndent 自减后，调用换行函数</span></span>
<span class="line"><span>20     deIndent() {</span></span>
<span class="line"><span>21       context.currentIndent--</span></span>
<span class="line"><span>22       context.newline()</span></span>
<span class="line"><span>23     }</span></span>
<span class="line"><span>24   }</span></span>
<span class="line"><span>25</span></span>
<span class="line"><span>26   genNode(node, context)</span></span>
<span class="line"><span>27</span></span>
<span class="line"><span>28   return context.code</span></span>
<span class="line"><span>29 }</span></span></code></pre></div><p>在上面这段代码中，我们增加了 <code>context.currentIndent</code> 属性，它代表缩进的级别，初始值为 <code>0</code>，代表没有缩进，还增加了 <code>context.newline()</code> 函数，每次调用该函数时，都会在代码字符串后面追加换行符 <code>\n</code>。由于换行时需要保留缩进，所以我们还要追加 <code>context.currentIndent * 2</code> 个空格字符。这里我们假设缩进为两个空格字符，后续我们可以将其设计为可配置的。同时，我们还增加了 <code>context.indent()</code> 函数用来完成代码缩进，它的原理很简单，即让缩进级别 <code>context.currentIndent</code> 进行自增，再调用 <code>context.newline()</code> 函数。与之对应的 <code>context.deIndent()</code> 函数则用来取消缩进，即让缩进级别 <code>context.currentIndent</code> 进行自减，再调用 <code>context.newline()</code> 函数。</p><p>有了这些基础能力之后，我们就可以开始编写 <code>genNode</code> 函数来完成代码生成的工作了。代码生成的原理其实很简单，只需要匹配各种类型的 JavaScript AST 节点，并调用对应的生成函数即可，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function genNode(node, context) {</span></span>
<span class="line"><span>02   switch (node.type) {</span></span>
<span class="line"><span>03     case &#39;FunctionDecl&#39;:</span></span>
<span class="line"><span>04       genFunctionDecl(node, context)</span></span>
<span class="line"><span>05       break</span></span>
<span class="line"><span>06     case &#39;ReturnStatement&#39;:</span></span>
<span class="line"><span>07       genReturnStatement(node, context)</span></span>
<span class="line"><span>08       break</span></span>
<span class="line"><span>09     case &#39;CallExpression&#39;:</span></span>
<span class="line"><span>10       genCallExpression(node, context)</span></span>
<span class="line"><span>11       break</span></span>
<span class="line"><span>12     case &#39;StringLiteral&#39;:</span></span>
<span class="line"><span>13       genStringLiteral(node, context)</span></span>
<span class="line"><span>14       break</span></span>
<span class="line"><span>15     case &#39;ArrayExpression&#39;:</span></span>
<span class="line"><span>16       genArrayExpression(node, context)</span></span>
<span class="line"><span>17       break</span></span>
<span class="line"><span>18   }</span></span>
<span class="line"><span>19 }</span></span></code></pre></div><p>在 <code>genNode</code> 函数内部，我们使用 <code>switch</code> 语句来匹配不同类型的节点，并调用与之对应的生成器函数。</p><ul><li>对于 <code>FunctionDecl</code> 节点，使用 <code>genFunctionDecl</code> 函数为该类型节点生成对应的 JavaScript 代码。</li><li>对于 <code>ReturnStatement</code> 节点，使用 <code>genReturnStatement</code> 函数为该类型节点生成对应的 JavaScript 代码。</li><li>对于 <code>CallExpression</code> 节点，使用 <code>genCallExpression</code> 函数为该类型节点生成对应的 JavaScript 代码。</li><li>对于 <code>StringLiteral</code> 节点，使用 <code>genStringLiteral</code> 函数为该类型节点生成对应的 JavaScript 代码。</li><li>对于 <code>ArrayExpression</code> 节点，使用 <code>genArrayExpression</code> 函数为该类型节点生成对应的 JavaScript 代码。</li></ul><p>由于我们目前只涉及这五种类型的 JavaScript 节点，所以现在的 <code>genNode</code> 函数足够完成上述案例。当然，如果后续需要增加节点类型，只需要在 <code>genNode</code> 函数中添加相应的处理分支即可。</p><p>接下来，我们将逐步完善代码生成工作。首先，我们来实现函数声明语句的代码生成，即 <code>genFunctionDecl</code> 函数，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function genFunctionDecl(node, context) {</span></span>
<span class="line"><span>02   // 从 context 对象中取出工具函数</span></span>
<span class="line"><span>03   const { push, indent, deIndent } = context</span></span>
<span class="line"><span>04   // node.id 是一个标识符，用来描述函数的名称，即 node.id.name</span></span>
<span class="line"><span>05   push(`function ${node.id.name} `)</span></span>
<span class="line"><span>06   push(`(`)</span></span>
<span class="line"><span>07   // 调用 genNodeList 为函数的参数生成代码</span></span>
<span class="line"><span>08   genNodeList(node.params, context)</span></span>
<span class="line"><span>09   push(`) `)</span></span>
<span class="line"><span>10   push(`{`)</span></span>
<span class="line"><span>11   // 缩进</span></span>
<span class="line"><span>12   indent()</span></span>
<span class="line"><span>13   // 为函数体生成代码，这里递归地调用了 genNode 函数</span></span>
<span class="line"><span>14   node.body.forEach(n =&gt; genNode(n, context))</span></span>
<span class="line"><span>15   // 取消缩进</span></span>
<span class="line"><span>16   deIndent()</span></span>
<span class="line"><span>17   push(`}`)</span></span>
<span class="line"><span>18 }</span></span></code></pre></div><p><code>genFunctionDecl</code> 函数用来为函数声明类型的节点生成对应的 JavaScript 代码。以渲染函数的声明节点为例，它最终生成的代码将会是：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function render () {</span></span>
<span class="line"><span>02   ... 函数体</span></span>
<span class="line"><span>03 }</span></span></code></pre></div><p>另外我们注意到，在 <code>genFunctionDecl</code> 函数内部调用了 <code>genNodeList</code> 函数来为函数的参数生成对应的代码。它的实现如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function genNodeList(nodes, context) {</span></span>
<span class="line"><span>02   const { push } = context</span></span>
<span class="line"><span>03   for (let i = 0; i &lt; nodes.length; i++) {</span></span>
<span class="line"><span>04     const node = nodes[i]</span></span>
<span class="line"><span>05     genNode(node, context)</span></span>
<span class="line"><span>06     if (i &lt; nodes.length - 1) {</span></span>
<span class="line"><span>07       push(&#39;, &#39;)</span></span>
<span class="line"><span>08     }</span></span>
<span class="line"><span>09   }</span></span>
<span class="line"><span>10 }</span></span></code></pre></div><p><code>genNodeList</code> 函数接收一个节点数组作为参数，并为每一个节点递归地调用 <code>genNode</code> 函数完成代码生成工作。这里要注意的一点是，每处理完一个节点，需要在生成的代码后面拼接逗号字符（<code>,</code>）。举例来说：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 // 如果节点数组为</span></span>
<span class="line"><span>02 const node = [节点 1， 节点 2， 节点 3]</span></span>
<span class="line"><span>03 // 那么生成的代码将类似于</span></span>
<span class="line"><span>04 &#39;节点 1，节点 2，节点 3&#39;</span></span>
<span class="line"><span>05 // 如果在这段代码的前后分别添加圆括号，那么它将可用于函数的参数声明</span></span>
<span class="line"><span>06 (&#39;节点 1，节点 2，节点 3&#39;)</span></span>
<span class="line"><span>07 // 如果在这段代码的前后分别添加方括号，那么它将是一个数组</span></span>
<span class="line"><span>08 [&#39;节点 1，节点 2，节点 3&#39;]</span></span></code></pre></div><p>由上例可知，<code>genNodeList</code> 函数会在节点代码之间补充逗号字符。实际上，<code>genArrayExpression</code> 函数就利用了这个特点来实现对数组表达式的代码生成，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function genArrayExpression(node, context) {</span></span>
<span class="line"><span>02   const { push } = context</span></span>
<span class="line"><span>03   // 追加方括号</span></span>
<span class="line"><span>04   push(&#39;[&#39;)</span></span>
<span class="line"><span>05   // 调用 genNodeList 为数组元素生成代码</span></span>
<span class="line"><span>06   genNodeList(node.elements, context)</span></span>
<span class="line"><span>07   // 补全方括号</span></span>
<span class="line"><span>08   push(&#39;]&#39;)</span></span>
<span class="line"><span>09 }</span></span></code></pre></div><p>不过，由于目前渲染函数暂时没有接收任何参数，所以 <code>genNodeList</code> 函数不会为其生成任何代码。对于 <code>genFunctionDecl</code> 函数，另外需要注意的是，由于函数体本身也是一个节点数组，所以我们需要遍历它并递归地调用 <code>genNode</code> 函数生成代码。</p><p>对于 <code>ReturnStatement</code> 和 <code>StringLiteral</code> 类型的节点来说，为它们生成代码很简单，如下所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function genReturnStatement(node, context) {</span></span>
<span class="line"><span>02   const { push } = context</span></span>
<span class="line"><span>03   // 追加 return 关键字和空格</span></span>
<span class="line"><span>04   push(`return `)</span></span>
<span class="line"><span>05   // 调用 genNode 函数递归地生成返回值代码</span></span>
<span class="line"><span>06   genNode(node.return, context)</span></span>
<span class="line"><span>07 }</span></span>
<span class="line"><span>08</span></span>
<span class="line"><span>09 function genStringLiteral(node, context) {</span></span>
<span class="line"><span>10   const { push } = context</span></span>
<span class="line"><span>11   // 对于字符串字面量，只需要追加与 node.value 对应的字符串即可</span></span>
<span class="line"><span>12   push(`&#39;${node.value}&#39;`)</span></span>
<span class="line"><span>13 }</span></span></code></pre></div><p>最后，只剩下 <code>genCallExpression</code> 函数了，它的实现如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function genCallExpression(node, context) {</span></span>
<span class="line"><span>02   const { push } = context</span></span>
<span class="line"><span>03   // 取得被调用函数名称和参数列表</span></span>
<span class="line"><span>04   const { callee, arguments: args } = node</span></span>
<span class="line"><span>05   // 生成函数调用代码</span></span>
<span class="line"><span>06   push(`${callee.name}(`)</span></span>
<span class="line"><span>07   // 调用 genNodeList 生成参数代码</span></span>
<span class="line"><span>08   genNodeList(args, context)</span></span>
<span class="line"><span>09   // 补全括号</span></span>
<span class="line"><span>10   push(`)`)</span></span>
<span class="line"><span>11 }</span></span></code></pre></div><p>可以看到，在 <code>genCallExpression</code> 函数内，我们也用到了 <code>genNodeList</code> 函数来为函数调用时的参数生成对应的代码。配合上述生成器函数的实现，我们将得到符合预期的渲染函数代码。运行如下测试用例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const ast = parse(`&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;`)</span></span>
<span class="line"><span>02 transform(ast)</span></span>
<span class="line"><span>03 const code = generate(ast.jsNode)</span></span></code></pre></div><p>最终得到的代码字符串如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function render () {</span></span>
<span class="line"><span>02   return h(&#39;div&#39;, [h(&#39;p&#39;, &#39;Vue&#39;), h(&#39;p&#39;, &#39;Template&#39;)])</span></span>
<span class="line"><span>03 }</span></span></code></pre></div><h3 id="_15-7-总结" tabindex="-1">15.7　总结 <a class="header-anchor" href="#_15-7-总结" aria-label="Permalink to &quot;15.7　总结&quot;">​</a></h3><p>在本章中，我们首先讨论了 Vue.js 模板编译器的工作流程。Vue.js 的模板编译器用于把模板编译为渲染函数。它的工作流程大致分为三个步骤。</p><p>(1) 分析模板，将其解析为模板 AST。</p><p>(2) 将模板 AST 转换为用于描述渲染函数的 JavaScript AST。</p><p>(3) 根据 JavaScript AST 生成渲染函数代码。</p><p>接着，我们讨论了 <code>parser</code> 的实现原理，以及如何用有限状态自动机构造一个词法分析器。词法分析的过程就是状态机在不同状态之间迁移的过程。在此过程中，状态机会产生一个个 Token，形成一个 Token 列表。我们将使用该 Token 列表来构造用于描述模板的 AST。具体做法是，扫描 Token 列表并维护一个开始标签栈。每当扫描到一个开始标签节点，就将其压入栈顶。栈顶的节点始终作为下一个扫描的节点的父节点。这样，当所有 Token 扫描完毕后，即可构建出一棵树型 AST。</p><p>然后，我们讨论了 AST 的转换与插件化架构。AST 是树型数据结构，为了访问 AST 中的节点，我们采用深度优先的方式对 AST 进行遍历。在遍历过程中，我们可以对 AST 节点进行各种操作，从而实现对 AST 的转换。为了解耦节点的访问和操作，我们设计了插件化架构，将节点的操作封装到独立的转换函数中。这些转换函数可以通过 <code>context.nodeTransforms</code> 来注册。这里的 <code>context</code> 称为转换上下文。上下文对象中通常会维护程序的当前状态，例如当前访问的节点、当前访问的节点的父节点、当前访问的节点的位置索引等信息。有了上下文对象及其包含的重要信息后，我们即可轻松地实现节点的替换、删除等能力。但有时，当前访问节点的转换工作依赖于其子节点的转换结果，所以为了优先完成子节点的转换，我们将整个转换过程分为“进入阶段”与“退出阶段”。每个转换函数都分两个阶段执行，这样就可以实现更加细粒度的转换控制。</p><p>之后，我们讨论了如何将模板 AST 转换为用于描述渲染函数的 JavaScript AST。模板 AST 用来描述模板，类似地，JavaScript AST 用于描述 JavaScript 代码。只有把模板 AST 转换为 JavaScript AST 后，我们才能据此生成最终的渲染函数代码。</p><p>最后，我们讨论了渲染函数代码的生成工作。代码生成是模板编译器的最后一步工作，生成的代码将作为组件的渲染函数。代码生成的过程就是字符串拼接的过程。我们需要为不同的 AST 节点编写对应的代码生成函数。为了让生成的代码具有更强的可读性，我们还讨论了如何对生成的代码进行缩进和换行。我们将用于缩进和换行的代码封装为工具函数，并且定义到代码生成过程中的上下文对象中。</p><h2 id="第-16-章-解析器" tabindex="-1">第 16 章　解析器 <a class="header-anchor" href="#第-16-章-解析器" aria-label="Permalink to &quot;第 16 章　解析器&quot;">​</a></h2><h3 id="_16-8-总结" tabindex="-1">16.8　总结 <a class="header-anchor" href="#_16-8-总结" aria-label="Permalink to &quot;16.8　总结&quot;">​</a></h3><p>在本章中，我们首先讨论了解析器的文本模式及其对解析器的影响。文本模式指的是解析器在工作时所进入的一些特殊状态，如 <code>RCDATA</code> 模式、<code>CDATA</code> 模式、<code>RAWTEXT</code> 模式，以及初始的 <code>DATA</code> 模式等。在不同模式下，解析器对文本的解析行为会有所不同。</p><p>接着，我们讨论了如何使用递归下降算法构造模板 AST。在 <code>parseChildren</code> 函数运行的过程中，为了处理标签节点，会调用 <code>parseElement</code> 解析函数，这会间接地调用 <code>parseChildren</code> 函数，并产生一个新的状态机。随着标签嵌套层次的增加，新的状态机也会随着 <code>parseChildren</code> 函数被递归地调用而不断创建，这就是“递归下降”中“递归”二字的含义。而上级 <code>parseChildren</code> 函数的调用用于构造上级模板 AST 节点，被递归调用的下级 <code>parseChildren</code> 函数则用于构造下级模板 AST 节点。最终会构造出一棵树型结构的模板 AST，这就是“递归下降”中“下降”二字的含义。</p><p>在解析模板构建 AST 的过程中，<code>parseChildren</code> 函数是核心。每次调用 <code>parseChildren</code> 函数，就意味着新状态机的开启。状态机的结束时机有两个。</p><ul><li>第一个停止时机是当模板内容被解析完毕时。</li><li>第二个停止时机则是遇到结束标签时，这时解析器会取得父级节点栈栈顶的节点作为父节点，检查该结束标签是否与父节点的标签同名，如果相同，则状态机停止运行。</li></ul><p>我们还讨论了文本节点的解析。解析文本节点本身并不复杂，它的复杂点在于，我们需要对解析后的文本内容进行 HTML 实体的解码工作。WHATWG 规范中也定义了解码 HTML 实体过程中的状态迁移流程。HTML 实体类型有两种，分别是命名字符引用和数字字符引用。命名字符引用的解码方案可以总结为两种。</p><ul><li>当存在分号时：执行完整匹配。</li><li>当省略分号时：执行最短匹配。</li></ul><p>对于数字字符引用，则需要按照 WHATWG 规范中定义的规则逐步实现。</p><h2 id="第-17-章-编译优化" tabindex="-1">第 17 章　编译优化 <a class="header-anchor" href="#第-17-章-编译优化" aria-label="Permalink to &quot;第 17 章　编译优化&quot;">​</a></h2><p>编译优化指的是编译器将模板编译为渲染函数的过程中，尽可能多地提取关键信息，并以此指导生成最优代码的过程。编译优化的策略与具体实现是由框架的设计思路所决定的，不同的框架具有不同的设计思路，因此编译优化的策略也不尽相同。但优化的方向基本一致，即尽可能地区分动态内容和静态内容，并针对不同的内容采用不同的优化策略。</p><h3 id="_17-1-动态节点收集与补丁标志" tabindex="-1">17.1　动态节点收集与补丁标志 <a class="header-anchor" href="#_17-1-动态节点收集与补丁标志" aria-label="Permalink to &quot;17.1　动态节点收集与补丁标志&quot;">​</a></h3><h4 id="_17-1-1-传统-diff-算法的问题" tabindex="-1">17.1.1　传统 Diff 算法的问题 <a class="header-anchor" href="#_17-1-1-传统-diff-算法的问题" aria-label="Permalink to &quot;17.1.1　传统 Diff 算法的问题&quot;">​</a></h4><p>我们在第三篇中讲解渲染器的时候，介绍了三种关于传统虚拟 DOM 的 Diff 算法。但无论哪一种 Diff 算法，当它在比对新旧两棵虚拟 DOM 树的时候，总是要按照虚拟 DOM 的层级结构“一层一层”地遍历。举个例子，假设我们有如下模板：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div id=&quot;foo&quot;&gt;</span></span>
<span class="line"><span>02   &lt;p class=&quot;bar&quot;&gt;{{ text }}&lt;/p&gt;</span></span>
<span class="line"><span>03 &lt;/div&gt;</span></span></code></pre></div><p>在上面这段模板中，唯一可能变化的就是 <code>p</code> 标签的文本子节点的内容。也就是说，当响应式数据 <code>text</code> 的值发生变化时，最高效的更新方式就是直接设置 <code>p</code> 标签的文本内容。但传统 Diff 算法显然做不到如此高效，当响应式数据 <code>text</code> 发生变化时，会产生一棵新的虚拟 DOM 树，传统 Diff 算法对比新旧两棵虚拟 DOM 树的过程如下。</p><ul><li>对比 <code>div</code> 节点，以及该节点的属性和子节点。</li><li>对比 <code>p</code> 节点，以及该节点的属性和子节点。</li><li>对比 <code>p</code> 节点的文本子节点，如果文本子节点的内容变了，则更新之，否则什么都不做。</li></ul><p>可以看到，与直接更新 <code>p</code> 标签的文本内容相比，传统 Diff 算法存在很多无意义的比对操作。如果能够跳过这些无意义的操作，性能将会大幅提升。而这就是 Vue.js 3 编译优化的思路来源。</p><p>实际上，模板的结构非常稳定。通过编译手段，我们可以分析出很多关键信息，例如哪些节点是静态的，哪些节点是动态的。结合这些关键信息，编译器可以直接生成原生 DOM 操作的代码，这样甚至能够抛掉虚拟 DOM，从而避免虚拟 DOM 带来的性能开销。但是，考虑到渲染函数的灵活性，以及 Vue.js 2 的兼容问题，Vue.js 3 最终还是选择了保留虚拟 DOM。这样一来，就必然要面临它所带来的额外性能开销。</p><p>那么，为什么虚拟 DOM 会产生额外的性能开销呢？根本原因在于，渲染器在运行时得不到足够的信息。传统 Diff 算法无法利用编译时提取到的任何关键信息，这导致渲染器在运行时不可能去做相关的优化。而 Vue.js 3 的编译器会将编译时得到的关键信息“附着”在它生成的虚拟 DOM 上，这些信息会通过虚拟 DOM 传递给渲染器。最终，渲染器会根据这些关键信息执行“快捷路径”，从而提升运行时的性能。</p><h4 id="_17-1-2-block-与-patchflags" tabindex="-1">17.1.2　<code>Block</code> 与 <code>PatchFlags</code> <a class="header-anchor" href="#_17-1-2-block-与-patchflags" aria-label="Permalink to &quot;17.1.2　`Block` 与 `PatchFlags`&quot;">​</a></h4><p>之所以说传统 Diff 算法无法避免新旧虚拟 DOM 树间无用的比较操作，是因为它在运行时得不到足够的关键信息，从而无法区分动态内容和静态内容。换句话说，只要运行时能够区分动态内容和静态内容，即可实现极致的优化策略。假设我们有如下模板：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div&gt;</span></span>
<span class="line"><span>02   &lt;div&gt;foo&lt;/div&gt;</span></span>
<span class="line"><span>03   &lt;p&gt;{{ bar }}&lt;/p&gt;</span></span>
<span class="line"><span>04 &lt;/div&gt;</span></span></code></pre></div><p>在上面这段模板中，只有 <code></code> 是动态的内容。因此，在理想情况下，当响应式数据 <code>bar</code> 的值变化时，只需要更新 <code>p</code> 标签的文本节点即可。为了实现这个目标，我们需要提供更多信息给运行时，这需要我们从虚拟 DOM 的结构入手。来看一下传统的虚拟 DOM 是如何描述上面那段模板的：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const vnode = {</span></span>
<span class="line"><span>02   tag: &#39;div&#39;,</span></span>
<span class="line"><span>03   children: [</span></span>
<span class="line"><span>04     { tag: &#39;div&#39;, children: &#39;foo&#39; },</span></span>
<span class="line"><span>05     { tag: &#39;p&#39;, children: ctx.bar },</span></span>
<span class="line"><span>06   ]</span></span>
<span class="line"><span>07 }</span></span></code></pre></div><p>传统的虚拟 DOM 中没有任何标志能够体现出节点的动态性。但经过编译优化之后，编译器会将它提取到的关键信息“附着”到虚拟 DOM 节点上，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const vnode = {</span></span>
<span class="line"><span>02   tag: &#39;div&#39;,</span></span>
<span class="line"><span>03   children: [</span></span>
<span class="line"><span>04     { tag: &#39;div&#39;, children: &#39;foo&#39; },</span></span>
<span class="line"><span>05     { tag: &#39;p&#39;, children: ctx.bar, patchFlag: 1 },  // 这是动态节点</span></span>
<span class="line"><span>06   ]</span></span>
<span class="line"><span>07 }</span></span></code></pre></div><p>可以看到，用来描述 <code>p</code> 标签的虚拟节点拥有一个额外的属性，即 <code>patchFlag</code>，它的值是一个数字。只要虚拟节点存在该属性，我们就认为它是一个动态节点。这里的 <code>patchFlag</code> 属性就是所谓的补丁标志。</p><p>我们可以把补丁标志理解为一系列数字标记，并根据数字值的不同赋予它不同的含义，示例如下。</p><ul><li>数字 1：代表节点有动态的 <code>textContent</code>（例如上面模板中的 <code>p</code> 标签）。</li><li>数字 2：代表元素有动态的 <code>class</code> 绑定。</li><li>数字 3：代表元素有动态的 <code>style</code> 绑定。</li><li>数字 4：其他……。</li></ul><p>通常，我们会在运行时的代码中定义补丁标志的映射，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const PatchFlags = {</span></span>
<span class="line"><span>02   TEXT: 1, // 代表节点有动态的 textContent</span></span>
<span class="line"><span>03   CLASS: 2, // 代表元素有动态的 class 绑定</span></span>
<span class="line"><span>04   STYLE: 3</span></span>
<span class="line"><span>05   // 其他……</span></span>
<span class="line"><span>06 }</span></span></code></pre></div><p>有了这项信息，我们就可以在虚拟节点的创建阶段，把它的动态子节点提取出来，并将其存储到该虚拟节点的 <code>dynamicChildren</code> 数组内：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const vnode = {</span></span>
<span class="line"><span>02   tag: &#39;div&#39;,</span></span>
<span class="line"><span>03   children: [</span></span>
<span class="line"><span>04     { tag: &#39;div&#39;, children: &#39;foo&#39; },</span></span>
<span class="line"><span>05     { tag: &#39;p&#39;, children: ctx.bar, patchFlag: PatchFlags.TEXT }  // 这是动态节点</span></span>
<span class="line"><span>06   ],</span></span>
<span class="line"><span>07   // 将 children 中的动态节点提取到 dynamicChildren 数组中</span></span>
<span class="line"><span>08   dynamicChildren: [</span></span>
<span class="line"><span>09     // p 标签具有 patchFlag 属性，因此它是动态节点</span></span>
<span class="line"><span>10     { tag: &#39;p&#39;, children: ctx.bar, patchFlag: PatchFlags.TEXT }</span></span>
<span class="line"><span>11   ]</span></span>
<span class="line"><span>12 }</span></span></code></pre></div><p>我们会在下一节中讨论如何提取动态节点。观察上面的 <code>vnode</code> 对象可以发现，与普通虚拟节点相比，它多出了一个额外的 <code>dynamicChildren</code> 属性。我们把带有该属性的虚拟节点称为“块”，即 <code>Block</code>。所以，一个 <code>Block</code> 本质上也是一个虚拟 DOM 节点，只不过它比普通的虚拟节点多出来一个用来存储动态子节点的 <code>dynamicChildren</code> 属性。这里需要注意的是，一个 <code>Block</code> 不仅能够收集它的直接动态子节点，还能够收集所有动态<strong>子代</strong>节点。举个例子，假设我们有如下模板：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div&gt;</span></span>
<span class="line"><span>02   &lt;div&gt;</span></span>
<span class="line"><span>03     &lt;p&gt;{{ bar }}&lt;/p&gt;</span></span>
<span class="line"><span>04   &lt;/div&gt;</span></span>
<span class="line"><span>05 &lt;/div&gt;</span></span></code></pre></div><p>在这段模板中，<code>p</code> 标签并不是最外层 <code>div</code> 标签的直接子节点，而是它的子代节点。因此，最外层的 <code>div</code> 标签对应的 <code>Block</code> 能够将 <code>p</code> 标签收集到其 <code>dynamicChildren</code> 数组中，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const vnode = {</span></span>
<span class="line"><span>02   tag: &#39;div&#39;,</span></span>
<span class="line"><span>03   children: [</span></span>
<span class="line"><span>04     {</span></span>
<span class="line"><span>05       tag: &#39;div&#39;,</span></span>
<span class="line"><span>06       children: [</span></span>
<span class="line"><span>07         { tag: &#39;p&#39;, children: ctx.bar, patchFlag: PatchFlags.TEXT }  // 这是动态节点</span></span>
<span class="line"><span>08       ]</span></span>
<span class="line"><span>09      },</span></span>
<span class="line"><span>10   ],</span></span>
<span class="line"><span>11   dynamicChildren: [</span></span>
<span class="line"><span>12     // Block 可以收集所有动态子代节点</span></span>
<span class="line"><span>13     { tag: &#39;p&#39;, children: ctx.bar, patchFlag: PatchFlags.TEXT }</span></span>
<span class="line"><span>14   ]</span></span>
<span class="line"><span>15 }</span></span></code></pre></div><p>有了 <code>Block</code> 这个概念之后，渲染器的更新操作将会以 <code>Block</code> 为维度。也就是说，当渲染器在更新一个 <code>Block</code> 时，会忽略虚拟节点的 <code>children</code> 数组，而是直接找到该虚拟节点的 <code>dynamicChildren</code> 数组，并只更新该数组中的动态节点。这样，在更新时就实现了跳过静态内容，只更新动态内容。同时，由于动态节点中存在对应的补丁标志，所以在更新动态节点的时候，也能够做到靶向更新。例如，当一个动态节点的 <code>patchFlag</code> 值为数字 <code>1</code> 时，我们知道它只存在动态的文本节点，所以只需要更新它的文本内容即可。</p><p>既然 <code>Block</code> 的好处这么多，那么什么情况下需要将一个普通的虚拟节点变成 <code>Block</code> 节点呢？实际上，当我们在编写模板代码的时候，所有模板的根节点都会是一个 <code>Block</code> 节点，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;template&gt;</span></span>
<span class="line"><span>02   &lt;!-- 这个 div 标签是一个 Block --&gt;</span></span>
<span class="line"><span>03   &lt;div&gt;</span></span>
<span class="line"><span>04     &lt;!-- 这个 p 标签不是 Block，因为它不是根节点 --&gt;</span></span>
<span class="line"><span>05     &lt;p&gt;{{ bar }}&lt;/p&gt;</span></span>
<span class="line"><span>06   &lt;/div&gt;</span></span>
<span class="line"><span>07   &lt;!-- 这个 h1 标签是一个 Block --&gt;</span></span>
<span class="line"><span>08   &lt;h1&gt;</span></span>
<span class="line"><span>09     &lt;!-- 这个 span 标签不是 Block，因为它不是根节点 --&gt;</span></span>
<span class="line"><span>10     &lt;span :id=&quot;dynamicId&quot;&gt;&lt;/span&gt;</span></span>
<span class="line"><span>11   &lt;/h1&gt;</span></span>
<span class="line"><span>12 &lt;/template&gt;</span></span></code></pre></div><p>实际上，除了模板中的根节点需要作为 <code>Block</code> 角色之外，任何带有 <code>v-for</code>、<code>v-if/v-else-if/v-else</code> 等指令的节点都需要作为 <code>Block</code> 节点，我们会在后续章节中详细讨论。</p><h4 id="_17-1-3-收集动态节点" tabindex="-1">17.1.3　收集动态节点 <a class="header-anchor" href="#_17-1-3-收集动态节点" aria-label="Permalink to &quot;17.1.3　收集动态节点&quot;">​</a></h4><p>在编译器生成的渲染函数代码中，并不会直接包含用来描述虚拟节点的数据结构，而是包含着用来创建虚拟 DOM 节点的辅助函数，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 render() {</span></span>
<span class="line"><span>02   return createVNode(&#39;div&#39;, { id: &#39;foo&#39; }, [</span></span>
<span class="line"><span>03     createVNode(&#39;p&#39;, null, &#39;text&#39;)</span></span>
<span class="line"><span>04   ])</span></span>
<span class="line"><span>05 }</span></span></code></pre></div><p>其中 <code>createVNode</code> 函数就是用来创建虚拟 DOM 节点的辅助函数，它的基本实现类似于：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function createVNode(tag, props, children) {</span></span>
<span class="line"><span>02   const key = props &amp;&amp; props.key</span></span>
<span class="line"><span>03   props &amp;&amp; delete props.key</span></span>
<span class="line"><span>04</span></span>
<span class="line"><span>05   return {</span></span>
<span class="line"><span>06     tag,</span></span>
<span class="line"><span>07     props,</span></span>
<span class="line"><span>08     children,</span></span>
<span class="line"><span>09     key</span></span>
<span class="line"><span>10   }</span></span>
<span class="line"><span>11 }</span></span></code></pre></div><p>可以看到，<code>createVNode</code> 函数的返回值是一个虚拟 DOM 节点。在 <code>createVNode</code> 函数内部，通常还会对 <code>props</code> 和 <code>children</code> 做一些额外的处理工作。</p><p>编译器在优化阶段提取的关键信息会影响最终生成的代码，具体体现在用于创建虚拟 DOM 节点的辅助函数上。假设我们有如下模板：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div id=&quot;foo&quot;&gt;</span></span>
<span class="line"><span>02   &lt;p class=&quot;bar&quot;&gt;{{ text }}&lt;/p&gt;</span></span>
<span class="line"><span>03 &lt;/div&gt;</span></span></code></pre></div><p>编译器在对这段模板进行编译优化后，会生成带有<strong>补丁标志</strong>（patch flag）的渲染函数，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 render() {</span></span>
<span class="line"><span>02   return createVNode(&#39;div&#39;, { id: &#39;foo&#39; }, [</span></span>
<span class="line"><span>03     createVNode(&#39;p&#39;, { class: &#39;bar&#39; }, text, PatchFlags.TEXT) // PatchFlags.TEXT 就是补丁标志</span></span>
<span class="line"><span>04   ])</span></span>
<span class="line"><span>05 }</span></span></code></pre></div><p>在上面这段代码中，用于创建 <code>p</code> 标签的 <code>createVNode</code> 函数调用存在第四个参数，即 <code>PatchFlags.TEXT</code>。这个参数就是所谓的补丁标志，它代表当前虚拟 DOM 节点是一个动态节点，并且动态因素是：具有动态的文本子节点。这样就实现了对动态节点的标记。</p><p>下一步我们要思考的是如何将根节点变成一个 <code>Block</code>，以及如何将动态子代节点收集到该 <code>Block</code> 的 <code>dynamicChildren</code> 数组中。这里有一个重要的事实，即在渲染函数内，对 <code>createVNode</code> 函数的调用是层层的嵌套结构，并且该函数的执行顺序是“内层先执行，外层后执行”，如图 17-1 所示。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/172.jpg" alt="图 17-1 "></p><p><strong>图 17-1　由内向外的执行方式</strong></p><p>当外层 <code>createVNode</code> 函数执行时，内层的 <code>createVNode</code> 函数已经执行完毕了。因此，为了让外层 <code>Block</code> 节点能够收集到内层动态节点，就需要一个栈结构的数据来临时存储内层的动态节点，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 // 动态节点栈</span></span>
<span class="line"><span>02 const dynamicChildrenStack = []</span></span>
<span class="line"><span>03 // 当前动态节点集合</span></span>
<span class="line"><span>04 let currentDynamicChildren = null</span></span>
<span class="line"><span>05 // openBlock 用来创建一个新的动态节点集合，并将该集合压入栈中</span></span>
<span class="line"><span>06 function openBlock() {</span></span>
<span class="line"><span>07   dynamicChildrenStack.push((currentDynamicChildren = []))</span></span>
<span class="line"><span>08 }</span></span>
<span class="line"><span>09 // closeBlock 用来将通过 openBlock 创建的动态节点集合从栈中弹出</span></span>
<span class="line"><span>10 function closeBlock() {</span></span>
<span class="line"><span>11   currentDynamicChildren = dynamicChildrenStack.pop()</span></span>
<span class="line"><span>12 }</span></span></code></pre></div><p>接着，我们还需要调整 <code>createVNode</code> 函数，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function createVNode(tag, props, children, flags) {</span></span>
<span class="line"><span>02   const key = props &amp;&amp; props.key</span></span>
<span class="line"><span>03   props &amp;&amp; delete props.key</span></span>
<span class="line"><span>04</span></span>
<span class="line"><span>05   const vnode = {</span></span>
<span class="line"><span>06     tag,</span></span>
<span class="line"><span>07     props,</span></span>
<span class="line"><span>08     children,</span></span>
<span class="line"><span>09     key,</span></span>
<span class="line"><span>10     patchFlags: flags</span></span>
<span class="line"><span>11   }</span></span>
<span class="line"><span>12</span></span>
<span class="line"><span>13   if (typeof flags !== &#39;undefined&#39; &amp;&amp; currentDynamicChildren) {</span></span>
<span class="line"><span>14     // 动态节点，将其添加到当前动态节点集合中</span></span>
<span class="line"><span>15     currentDynamicChildren.push(vnode)</span></span>
<span class="line"><span>16   }</span></span>
<span class="line"><span>17</span></span>
<span class="line"><span>18   return vnode</span></span>
<span class="line"><span>19 }</span></span></code></pre></div><p>在 <code>createVNode</code> 函数内部，检测节点是否存在补丁标志。如果存在，则说明该节点是动态节点，于是将其添加到当前动态节点集合 <code>currentDynamicChildren</code> 中。</p><p>最后，我们需要重新设计渲染函数的执行方式，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 render() {</span></span>
<span class="line"><span>02   // 1. 使用 createBlock 代替 createVNode 来创建 block</span></span>
<span class="line"><span>03   // 2. 每当调用 createBlock 之前，先调用 openBlock</span></span>
<span class="line"><span>04   return (openBlock(), createBlock(&#39;div&#39;, null, [</span></span>
<span class="line"><span>05     createVNode(&#39;p&#39;, { class: &#39;foo&#39; }, null, 1 /* patch flag */),</span></span>
<span class="line"><span>06     createVNode(&#39;p&#39;, { class: &#39;bar&#39; }, null),</span></span>
<span class="line"><span>07   ]))</span></span>
<span class="line"><span>08 }</span></span>
<span class="line"><span>09</span></span>
<span class="line"><span>10 function createBlock(tag, props, children) {</span></span>
<span class="line"><span>11   // block 本质上也是一个 vnode</span></span>
<span class="line"><span>12   const block = createVNode(tag, props, children)</span></span>
<span class="line"><span>13   // 将当前动态节点集合作为 block.dynamicChildren</span></span>
<span class="line"><span>14   block.dynamicChildren = currentDynamicChildren</span></span>
<span class="line"><span>15</span></span>
<span class="line"><span>16   // 关闭 block</span></span>
<span class="line"><span>17   closeBlock()</span></span>
<span class="line"><span>18   // 返回</span></span>
<span class="line"><span>19   return block</span></span>
<span class="line"><span>20 }</span></span></code></pre></div><p>观察渲染函数内的代码可以发现，我们利用逗号运算符的性质来保证渲染函数的返回值仍然是 <code>VNode</code> 对象。这里的关键点是 <code>createBlock</code> 函数，任何应该作为 <code>Block</code> 角色的虚拟节点，都应该使用该函数来完成虚拟节点的创建。由于 <code>createVNode</code> 函数和 <code>createBlock</code> 函数的执行顺序是从内向外，所以当 <code>createBlock</code> 函数执行时，内层的所有 <code>createVNode</code> 函数已经执行完毕了。这时，<code>currentDynamicChildren</code> 数组中所存储的就是属于当前 <code>Block</code> 的所有动态子代节点。因此，我们只需要将 <code>currentDynamicChildren</code> 数组作为 <code>block.dynamicChildren</code> 属性的值即可。这样，我们就完成了动态节点的收集。</p><h4 id="_17-1-4-渲染器的运行时支持" tabindex="-1">17.1.4　渲染器的运行时支持 <a class="header-anchor" href="#_17-1-4-渲染器的运行时支持" aria-label="Permalink to &quot;17.1.4　渲染器的运行时支持&quot;">​</a></h4><p>现在，我们已经有了动态节点集合 <code>vnode.dynamicChildren</code>，以及附着其上的补丁标志。基于这两点，即可在渲染器中实现靶向更新。</p><p>回顾一下传统的节点更新方式，如下面的 <code>patchElement</code> 函数所示，它取自第三篇所讲解的渲染器：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function patchElement(n1, n2) {</span></span>
<span class="line"><span>02   const el = n2.el = n1.el</span></span>
<span class="line"><span>03   const oldProps = n1.props</span></span>
<span class="line"><span>04   const newProps = n2.props</span></span>
<span class="line"><span>05</span></span>
<span class="line"><span>06   for (const key in newProps) {</span></span>
<span class="line"><span>07     if (newProps[key] !== oldProps[key]) {</span></span>
<span class="line"><span>08       patchProps(el, key, oldProps[key], newProps[key])</span></span>
<span class="line"><span>09     }</span></span>
<span class="line"><span>10   }</span></span>
<span class="line"><span>11   for (const key in oldProps) {</span></span>
<span class="line"><span>12     if (!(key in newProps)) {</span></span>
<span class="line"><span>13       patchProps(el, key, oldProps[key], null)</span></span>
<span class="line"><span>14     }</span></span>
<span class="line"><span>15   }</span></span>
<span class="line"><span>16</span></span>
<span class="line"><span>17   // 在处理 children 时，调用 patchChildren 函数</span></span>
<span class="line"><span>18   patchChildren(n1, n2, el)</span></span>
<span class="line"><span>19 }</span></span></code></pre></div><p>由上面的代码可知，渲染器在更新标签节点时，使用 <code>patchChildren</code> 函数来更新标签的子节点。但该函数会使用传统虚拟 DOM 的 Diff 算法进行更新，这样做效率比较低。有了 <code>dynamicChildren</code> 之后，我们可以直接对比动态节点，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function patchElement(n1, n2) {</span></span>
<span class="line"><span>02   const el = n2.el = n1.el</span></span>
<span class="line"><span>03   const oldProps = n1.props</span></span>
<span class="line"><span>04   const newProps = n2.props</span></span>
<span class="line"><span>05</span></span>
<span class="line"><span>06   // 省略部分代码</span></span>
<span class="line"><span>07</span></span>
<span class="line"><span>08   if (n2.dynamicChildren) {</span></span>
<span class="line"><span>09     // 调用 patchBlockChildren 函数，这样只会更新动态节点</span></span>
<span class="line"><span>10     patchBlockChildren(n1, n2)</span></span>
<span class="line"><span>11   } else {</span></span>
<span class="line"><span>12     patchChildren(n1, n2, el)</span></span>
<span class="line"><span>13   }</span></span>
<span class="line"><span>14 }</span></span>
<span class="line"><span>15</span></span>
<span class="line"><span>16 function patchBlockChildren(n1, n2) {</span></span>
<span class="line"><span>17   // 只更新动态节点即可</span></span>
<span class="line"><span>18   for (let i = 0; i &lt; n2.dynamicChildren.length; i++) {</span></span>
<span class="line"><span>19     patchElement(n1.dynamicChildren[i], n2.dynamicChildren[i])</span></span>
<span class="line"><span>20   }</span></span>
<span class="line"><span>21 }</span></span></code></pre></div><p>在修改后的 <code>patchElement</code> 函数中，我们优先检测虚拟 DOM 是否存在动态节点集合，即 <code>dynamicChildren</code> 数组。如果存在，则直接调用 <code>patchBlockChildren</code> 函数完成更新。这样，渲染器只会更新动态节点，而跳过所有静态节点。</p><p>动态节点集合能够使得渲染器在执行更新时跳过静态节点，但对于单个动态节点的更新来说，由于它存在对应的补丁标志，因此我们可以针对性地完成靶向更新，如以下代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function patchElement(n1, n2) {</span></span>
<span class="line"><span>02   const el = n2.el = n1.el</span></span>
<span class="line"><span>03   const oldProps = n1.props</span></span>
<span class="line"><span>04   const newProps = n2.props</span></span>
<span class="line"><span>05</span></span>
<span class="line"><span>06   if (n2.patchFlags) {</span></span>
<span class="line"><span>07     // 靶向更新</span></span>
<span class="line"><span>08     if (n2.patchFlags === 1) {</span></span>
<span class="line"><span>09       // 只需要更新 class</span></span>
<span class="line"><span>10     } else if (n2.patchFlags === 2) {</span></span>
<span class="line"><span>11       // 只需要更新 style</span></span>
<span class="line"><span>12     } else if (...) {</span></span>
<span class="line"><span>13                // ...</span></span>
<span class="line"><span>14     }</span></span>
<span class="line"><span>15   } else {</span></span>
<span class="line"><span>16     // 全量更新</span></span>
<span class="line"><span>17      for (const key in newProps) {</span></span>
<span class="line"><span>18       if (newProps[key] !== oldProps[key]) {</span></span>
<span class="line"><span>19         patchProps(el, key, oldProps[key], newProps[key])</span></span>
<span class="line"><span>20       }</span></span>
<span class="line"><span>21     }</span></span>
<span class="line"><span>22     for (const key in oldProps) {</span></span>
<span class="line"><span>23       if (!(key in newProps)) {</span></span>
<span class="line"><span>24         patchProps(el, key, oldProps[key], null)</span></span>
<span class="line"><span>25       }</span></span>
<span class="line"><span>26     }</span></span>
<span class="line"><span>27   }</span></span>
<span class="line"><span>28</span></span>
<span class="line"><span>29   // 在处理 children 时，调用 patchChildren 函数</span></span>
<span class="line"><span>30   patchChildren(n1, n2, el)</span></span>
<span class="line"><span>31 }</span></span></code></pre></div><p>可以看到，在 <code>patchElement</code> 函数内，我们通过检测补丁标志实现了 <code>props</code> 的靶向更新。这样就避免了全量的 <code>props</code> 更新，从而最大化地提升性能。</p><h3 id="_17-2-block-树" tabindex="-1">17.2　<code>Block</code> 树 <a class="header-anchor" href="#_17-2-block-树" aria-label="Permalink to &quot;17.2　`Block` 树&quot;">​</a></h3><p>在上一节中，我们约定了组件模板的根节点必须作为 <code>Block</code> 角色。这样，从根节点开始，所有动态子代节点都会被收集到根节点的 <code>dynamicChildren</code> 数组中。但是，如果只有根节点是 <code>Block</code> 角色，是不会形成 <code>Block</code> 树的。既然会形成 <code>Block</code> 树，那就意味着除了根节点之外，还会有其他特殊节点充当 <code>Block</code> 角色。实际上，带有结构化指令的节点，如带有 <code>v-if</code> 和 <code>v-for</code> 指令的节点，都应该作为 <code>Block</code> 角色。接下来，我们就详细讨论原因。</p><h4 id="_17-2-1-带有-v-if-指令的节点" tabindex="-1">17.2.1　带有 <code>v-if</code> 指令的节点 <a class="header-anchor" href="#_17-2-1-带有-v-if-指令的节点" aria-label="Permalink to &quot;17.2.1　带有 `v-if` 指令的节点&quot;">​</a></h4><p>首先，我们来看下面这段模板：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div&gt;</span></span>
<span class="line"><span>02   &lt;section v-if=&quot;foo&quot;&gt;</span></span>
<span class="line"><span>03     &lt;p&gt;{{ a }}&lt;/p&gt;</span></span>
<span class="line"><span>04   &lt;/section&gt;</span></span>
<span class="line"><span>05   &lt;div v-else&gt;</span></span>
<span class="line"><span>06     &lt;p&gt;{{ a }}&lt;/p&gt;</span></span>
<span class="line"><span>07   &lt;/div&gt;</span></span>
<span class="line"><span>08 &lt;/div&gt;</span></span></code></pre></div><p>假设只有最外层的 <code>div</code> 标签会作为 <code>Block</code> 角色。那么，当变量 <code>foo</code> 的值为 <code>true</code> 时，<code>block</code> 收集到的动态节点是：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 cosnt block = {</span></span>
<span class="line"><span>02   tag: &#39;div&#39;,</span></span>
<span class="line"><span>03   dynamicChildren: [</span></span>
<span class="line"><span>04     { tag: &#39;p&#39;, children: ctx.a, patchFlags: 1 }</span></span>
<span class="line"><span>05   ]</span></span>
<span class="line"><span>06   // ...</span></span>
<span class="line"><span>07 }</span></span></code></pre></div><p>而当变量 <code>foo</code> 的值为 <code>false</code> 时，<code>block</code> 收集到的动态节点是：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 cosnt block = {</span></span>
<span class="line"><span>02   tag: &#39;div&#39;,</span></span>
<span class="line"><span>03   dynamicChildren: [</span></span>
<span class="line"><span>04     { tag: &#39;p&#39;, children: ctx.a, patchFlags: 1 }</span></span>
<span class="line"><span>05   ]</span></span>
<span class="line"><span>06   // ...</span></span>
<span class="line"><span>07 }</span></span></code></pre></div><p>可以发现，无论变量 <code>foo</code> 的值是 <code>true</code> 还是 <code>false</code>，<code>block</code> 所收集的动态节点是不变的。这意味着，在 Diff 阶段不会做任何更新。但是我们也看到了，在上面的模板中，带有 <code>v-if</code> 指令的是 <code>&lt;section&gt;</code> 标签，而带有 <code>v-else</code> 指令的是 <code>&lt;div&gt;</code> 标签。很明显，更新前后的标签不同，如果不做任何更新，将产生严重的 bug。不仅如此，下面的模板也会出现同样的问题：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div&gt;</span></span>
<span class="line"><span>02   &lt;section v-if=&quot;foo&quot;&gt;</span></span>
<span class="line"><span>03     &lt;p&gt;{{ a }}&lt;/p&gt;</span></span>
<span class="line"><span>04   &lt;/section&gt;</span></span>
<span class="line"><span>05   &lt;section v-else&gt; &lt;!-- 即使这里是 section --&gt;</span></span>
<span class="line"><span>06        &lt;div&gt; &lt;!-- 这个 div 标签在 Diff 过程中被忽略 --&gt;</span></span>
<span class="line"><span>07             &lt;p&gt;{{ a }}&lt;/p&gt;</span></span>
<span class="line"><span>08         &lt;/div&gt;</span></span>
<span class="line"><span>09   &lt;/section &gt;</span></span>
<span class="line"><span>10 &lt;/div&gt;</span></span></code></pre></div><p>在上面这段模板中，即使带有 <code>v-if</code> 指令的标签与带有 <code>v-else</code> 指令的标签都是 <code>&lt;section&gt;</code> 标签，但由于两个分支的虚拟 DOM 树的结构不同，仍然会导致更新失败。</p><p>实际上，上述问题的根本原因在于，<code>dynamicChildren</code> 数组中收集的动态节点是忽略虚拟 DOM 树层级的。换句话说，结构化指令会导致更新前后模板的结构发生变化，即模板结构不稳定。那么，如何让虚拟 DOM 树的结构变稳定呢？其实很简单，只需要让带有 <code>v-if/v-else-if/v-else</code> 等结构化指令的节点也作为 <code>Block</code> 角色即可。</p><p>以下面的模板为例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div&gt;</span></span>
<span class="line"><span>02   &lt;section v-if=&quot;foo&quot;&gt;</span></span>
<span class="line"><span>03     &lt;p&gt;{{ a }}&lt;/p&gt;</span></span>
<span class="line"><span>04   &lt;/section&gt;</span></span>
<span class="line"><span>05   &lt;section v-else&gt; &lt;!-- 即使这里是 section --&gt;</span></span>
<span class="line"><span>06        &lt;div&gt; &lt;!-- 这个 div 标签在 Diff 过程中被忽略 --&gt;</span></span>
<span class="line"><span>07             &lt;p&gt;{{ a }}&lt;/p&gt;</span></span>
<span class="line"><span>08         &lt;/div&gt;</span></span>
<span class="line"><span>09   &lt;/section &gt;</span></span>
<span class="line"><span>10 &lt;/div&gt;</span></span></code></pre></div><p>如果上面这段模板中的两个 <code>&lt;section&gt;</code> 标签都作为 <code>Block</code> 角色，那么将构成一棵 <code>Block</code> 树：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 Block(Div)</span></span>
<span class="line"><span>02     - Block(Section v-if)</span></span>
<span class="line"><span>03     - Block(Section v-else)</span></span></code></pre></div><p>父级 <code>Block</code> 除了会收集动态子代节点之外，也会收集子 <code>Block</code>。因此，两个子 <code>Block(section)</code> 将作为父级 <code>Block(div)</code> 的动态节点被收集到父级 <code>Block(div)</code> 的 <code>dynamicChildren</code> 数组中，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 cosnt block = {</span></span>
<span class="line"><span>02     tag: &#39;div&#39;,</span></span>
<span class="line"><span>03     dynamicChildren: [</span></span>
<span class="line"><span>04       /* Block(Section v-if) 或者 Block(Section v-else) */</span></span>
<span class="line"><span>05       { tag: &#39;section&#39;, { key: 0 /* key 值会根据不同的 Block 而发生变化 */ }, dynamicChildren: [...]},</span></span>
<span class="line"><span>06     ]</span></span>
<span class="line"><span>07 }</span></span></code></pre></div><p>这样，当 <code>v-if</code> 条件为真时，父级 <code>Block</code> 的 <code>dynamicChildren</code> 数组中包含的是 <code>Block(section v-if)</code>；当 <code>v-if</code> 的条件为假时，父级 <code>Block</code> 的 <code>dynamicChildren</code> 数组中包含的将是 <code>Block(section v-else)</code>。在 Diff 过程中，渲染器能够根据 <code>Block</code> 的 <code>key</code> 值区分出更新前后的两个 <code>Block</code> 是不同的，并使用新的 <code>Block</code> 替换旧的 <code>Block</code>。这样就解决了 DOM 结构不稳定引起的更新问题。</p><h4 id="_17-2-2-带有-v-for-指令的节点" tabindex="-1">17.2.2　带有 <code>v-for</code> 指令的节点 <a class="header-anchor" href="#_17-2-2-带有-v-for-指令的节点" aria-label="Permalink to &quot;17.2.2　带有 `v-for` 指令的节点&quot;">​</a></h4><p>不仅带有 <code>v-if</code> 指令的节点会让虚拟 DOM 树的结构不稳定，带有 <code>v-for</code> 指令的节点也会让虚拟 DOM 树变得不稳定，而后者的情况会稍微复杂一些。</p><p>思考如下模板：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div&gt;</span></span>
<span class="line"><span>02   &lt;p v-for=&quot;item in list&quot;&gt;{{ item }}&lt;/p&gt;</span></span>
<span class="line"><span>03   &lt;i&gt;{{ foo }}&lt;/i&gt;</span></span>
<span class="line"><span>04   &lt;i&gt;{{ bar }}&lt;/i&gt;</span></span>
<span class="line"><span>05 &lt;/div&gt;</span></span></code></pre></div><p>假设 <code>list</code> 是一个数组，在更新过程中，<code>list</code> 数组的值由 <code>[1 ,2]</code> 变为 <code>[1]</code>。按照之前的思路，即只有根节点会作为 <code>Block</code> 角色，那么，上面的模板中，只有最外层的 <code>&lt;div&gt;</code> 标签会作为 <code>Block</code>。所以，这段模板在更新前后对应的 <code>Block</code> 树是：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 // 更新前</span></span>
<span class="line"><span>02 const prevBlock = {</span></span>
<span class="line"><span>03   tag: &#39;div&#39;,</span></span>
<span class="line"><span>04   dynamicChildren: [</span></span>
<span class="line"><span>05     { tag: &#39;p&#39;, children: 1, 1 /* TEXT */ },</span></span>
<span class="line"><span>06     { tag: &#39;p&#39;, children: 2, 1 /* TEXT */ },</span></span>
<span class="line"><span>07     { tag: &#39;i&#39;, children: ctx.foo, 1 /* TEXT */ },</span></span>
<span class="line"><span>08     { tag: &#39;i&#39;, children: ctx.bar, 1 /* TEXT */ },</span></span>
<span class="line"><span>09   ]</span></span>
<span class="line"><span>10 }</span></span>
<span class="line"><span>11</span></span>
<span class="line"><span>12 // 更新后</span></span>
<span class="line"><span>13 const nextBlock = {</span></span>
<span class="line"><span>14   tag: &#39;div&#39;,</span></span>
<span class="line"><span>15   dynamicChildren: [</span></span>
<span class="line"><span>16     { tag: &#39;p&#39;, children: item, 1 /* TEXT */ },</span></span>
<span class="line"><span>17     { tag: &#39;i&#39;, children: ctx.foo, 1 /* TEXT */ },</span></span>
<span class="line"><span>18     { tag: &#39;i&#39;, children: ctx.bar, 1 /* TEXT */ },</span></span>
<span class="line"><span>19   ]</span></span>
<span class="line"><span>20 }</span></span></code></pre></div><p>观察上面这段代码，更新前的 <code>Block</code> 树（<code>prevBlock</code>）中有四个动态节点，而更新后的 <code>Block</code> 树（<code>nextBlock</code>）中只有三个动态节点。这时要如何进行 Diff 操作呢？有人可能会说，使用更新前后的两个 <code>dynamicChildren</code> 数组内的节点进行传统 Diff 不就可以吗？这么做显然是不对的，因为传统 Diff 的一个非常重要的前置条件是：进行 Diff 操作的节点必须是同层级节点。但是 <code>dynamicChildren</code> 数组内的节点未必是同层级的，这一点我们在前面的章节中提到过。</p><p>实际上，解决方法很简单，我们只需要让带有 <code>v-for</code> 指令的标签也作为 <code>Block</code> 角色即可。这样就能够保证虚拟 DOM 树具有稳定的结构，即无论 <code>v-for</code> 在运行时怎样变化，这棵 <code>Block</code> 树看上去都是一样的，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const block = {</span></span>
<span class="line"><span>02   tag: &#39;div&#39;,</span></span>
<span class="line"><span>03   dynamicChildren: [</span></span>
<span class="line"><span>04     // 这是一个 Block，它有 dynamicChildren</span></span>
<span class="line"><span>05     { tag: Fragment, dynamicChildren: [/* v-for 的节点 */] }</span></span>
<span class="line"><span>06     { tag: &#39;i&#39;, children: ctx.foo, 1 /* TEXT */ },</span></span>
<span class="line"><span>07     { tag: &#39;i&#39;, children: ctx.bar, 1 /* TEXT */ },</span></span>
<span class="line"><span>08   ]</span></span>
<span class="line"><span>09 }</span></span></code></pre></div><p>由于 <code>v-for</code> 指令渲染的是一个片段，所以我们需要使用类型为 <code>Fragment</code> 的节点来表达 <code>v-for</code> 指令的渲染结果，并作为 <code>Block</code> 角色。</p><h3 id="_17-3-静态提升" tabindex="-1">17.3　静态提升 <a class="header-anchor" href="#_17-3-静态提升" aria-label="Permalink to &quot;17.3　静态提升&quot;">​</a></h3><p>理解了 <code>Block</code> 树之后，我们再来看看其他方面的优化，其中之一就是静态提升。它能够减少更新时创建虚拟 DOM 带来的性能开销和内存占用。</p><p>假设我们有如下模板：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div&gt;</span></span>
<span class="line"><span>02   &lt;p&gt;static text&lt;/p&gt;</span></span>
<span class="line"><span>03   &lt;p&gt;{{ title }}&lt;/p&gt;</span></span>
<span class="line"><span>04 &lt;/div&gt;</span></span></code></pre></div><p>在没有静态提升的情况下，它对应的渲染函数是：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function render() {</span></span>
<span class="line"><span>02   return (openBlock(), createBlock(&#39;div&#39;, null, [</span></span>
<span class="line"><span>03     createVNode(&#39;p&#39;, null, &#39;static text&#39;),</span></span>
<span class="line"><span>04     createVNode(&#39;p&#39;, null, ctx.title, 1 /* TEXT */)</span></span>
<span class="line"><span>05   ]))</span></span>
<span class="line"><span>06 }</span></span></code></pre></div><p>可以看到，在这段虚拟 DOM 的描述中存在两个 <code>p</code> 标签，一个是纯静态的，而另一个拥有动态文本。当响应式数据 <code>title</code> 的值发生变化时，整个渲染函数会重新执行，并产生新的虚拟 DOM 树。这个过程有一个明显的问题，即纯静态的虚拟节点在更新时也会被重新创建一次。很显然，这是没有必要的，所以我们需要想办法避免由此带来的性能开销。而解决方案就是所谓的“静态提升”，即把纯静态的节点提升到渲染函数之外，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 // 把静态节点提升到渲染函数之外</span></span>
<span class="line"><span>02 const hoist1 = createVNode(&#39;p&#39;, null, &#39;text&#39;)</span></span>
<span class="line"><span>03</span></span>
<span class="line"><span>04 function render() {</span></span>
<span class="line"><span>05   return (openBlock(), createBlock(&#39;div&#39;, null, [</span></span>
<span class="line"><span>06     hoist1, // 静态节点引用</span></span>
<span class="line"><span>07     createVNode(&#39;p&#39;, null, ctx.title, 1 /* TEXT */)</span></span>
<span class="line"><span>08   ]))</span></span>
<span class="line"><span>09 }</span></span></code></pre></div><p>可以看到，当把纯静态的节点提升到渲染函数之外后，在渲染函数内只会持有对静态节点的引用。当响应式数据变化，并使得渲染函数重新执行时，并不会重新创建静态的虚拟节点，从而避免了额外的性能开销。</p><p>需要强调的是，静态提升是以树为单位的。以下面的模板为例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div&gt;</span></span>
<span class="line"><span>02   &lt;section&gt;</span></span>
<span class="line"><span>03     &lt;p&gt;</span></span>
<span class="line"><span>04       &lt;span&gt;abc&lt;/span&gt;</span></span>
<span class="line"><span>05     &lt;/p&gt;</span></span>
<span class="line"><span>06   &lt;/section &gt;</span></span>
<span class="line"><span>07 &lt;/div&gt;</span></span></code></pre></div><p>在上面这段模板中，除了根节点的 <code>div</code> 标签会作为 <code>Block</code> 角色而不可被提升之外，整个 <code>&lt;section&gt;</code> 元素及其子代节点都会被提升。如果我们把上面模板中的静态字符串 <code>abc</code> 换成动态绑定的 <code></code>，那么整棵树都不会被提升。</p><p>虽然包含动态绑定的节点本身不会被提升，但是该动态节点上仍然可能存在纯静态的属性，如下面的模板所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div&gt;</span></span>
<span class="line"><span>02   &lt;p foo=&quot;bar&quot; a=b&gt;{{ text }}&lt;/p&gt;</span></span>
<span class="line"><span>03 &lt;/div&gt;</span></span></code></pre></div><p>在上面这段模板中，<code>p</code> 标签存在动态绑定的文本内容，因此整个节点都不会被静态提升。但该节点的所有 <code>props</code> 都是静态的，因此在最终生成渲染函数时，我们可以将纯静态的 <code>props</code> 提升到渲染函数之外，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 // 静态提升的 props 对象</span></span>
<span class="line"><span>02 const hoistProp = { foo: &#39;bar&#39;, a: &#39;b&#39; }</span></span>
<span class="line"><span>03</span></span>
<span class="line"><span>04 function render(ctx) {</span></span>
<span class="line"><span>05   return (openBlock(), createBlock(&#39;div&#39;, null, [</span></span>
<span class="line"><span>06     createVNode(&#39;p&#39;, hoistProp, ctx.text)</span></span>
<span class="line"><span>07   ]))</span></span>
<span class="line"><span>08 }</span></span></code></pre></div><p>这样做同样可以减少创建虚拟 DOM 产生的开销以及内存占用。</p><h3 id="_17-4-预字符串化" tabindex="-1">17.4　预字符串化 <a class="header-anchor" href="#_17-4-预字符串化" aria-label="Permalink to &quot;17.4　预字符串化&quot;">​</a></h3><p>基于静态提升，我们还可以进一步采用预字符串化的优化手段。预字符串化是基于静态提升的一种优化策略。静态提升的虚拟节点或虚拟节点树本身是静态的，那么，能否将其预字符串化呢？如下面的模板所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div&gt;</span></span>
<span class="line"><span>02   &lt;p&gt;&lt;/p&gt;</span></span>
<span class="line"><span>03   &lt;p&gt;&lt;/p&gt;</span></span>
<span class="line"><span>04   // ... 20 个 p 标签</span></span>
<span class="line"><span>05   &lt;p&gt;&lt;/p&gt;</span></span>
<span class="line"><span>06 &lt;/div&gt;</span></span></code></pre></div><p>假设上面的模板中包含大量连续纯静态的标签节点，当采用了静态提升优化策略时，其编译后的代码如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 cosnt hoist1 = createVNode(&#39;p&#39;, null, null, PatchFlags.HOISTED)</span></span>
<span class="line"><span>02 cosnt hoist2 = createVNode(&#39;p&#39;, null, null, PatchFlags.HOISTED)</span></span>
<span class="line"><span>03 // ... 20 个 hoistx 变量</span></span>
<span class="line"><span>04 cosnt hoist20 = createVNode(&#39;p&#39;, null, null, PatchFlags.HOISTED)</span></span>
<span class="line"><span>05</span></span>
<span class="line"><span>06 render() {</span></span>
<span class="line"><span>07   return (openBlock(), createBlock(&#39;div&#39;, null, [</span></span>
<span class="line"><span>08     hoist1, hoist2, /* ...20 个变量 */, hoist20</span></span>
<span class="line"><span>09   ]))</span></span>
<span class="line"><span>10 }</span></span></code></pre></div><p>预字符串化能够将这些静态节点序列化为字符串，并生成一个 <code>Static</code> 类型的 <code>VNode</code>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 const hoistStatic = createStaticVNode(&#39;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;...20 个...&lt;p&gt;&lt;/p&gt;&#39;)</span></span>
<span class="line"><span>02</span></span>
<span class="line"><span>03 render() {</span></span>
<span class="line"><span>04   return (openBlock(), createBlock(&#39;div&#39;, null, [</span></span>
<span class="line"><span>05     hoistStatic</span></span>
<span class="line"><span>06   ]))</span></span>
<span class="line"><span>07 }</span></span></code></pre></div><p>这么做有几个明显的优势。</p><ul><li>大块的静态内容可以通过 <code>innerHTML</code> 进行设置，在性能上具有一定优势。</li><li>减少创建虚拟节点产生的性能开销。</li><li>减少内存占用。</li></ul><h3 id="_17-5-缓存内联事件处理函数" tabindex="-1">17.5　缓存内联事件处理函数 <a class="header-anchor" href="#_17-5-缓存内联事件处理函数" aria-label="Permalink to &quot;17.5　缓存内联事件处理函数&quot;">​</a></h3><p>提到优化，就不得不提对内联事件处理函数的缓存。缓存内联事件处理函数可以避免不必要的更新。假设模板内容如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;Comp @change=&quot;a + b&quot; /&gt;</span></span></code></pre></div><p>上面这段模板展示的是一个绑定了 <code>change</code> 事件的组件，并且为 <code>change</code> 事件绑定的事件处理程序是一个内联语句。对于这样的模板，编译器会为其创建一个内联事件处理函数，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function render(ctx) {</span></span>
<span class="line"><span>02   return h(Comp, {</span></span>
<span class="line"><span>03     // 内联事件处理函数</span></span>
<span class="line"><span>04     onChange: () =&gt; (ctx.a + ctx.b)</span></span>
<span class="line"><span>05   })</span></span>
<span class="line"><span>06 }</span></span></code></pre></div><p>很显然，每次重新渲染时（即 <code>render</code> 函数重新执行时），都会为 <code>Comp</code> 组件创建一个全新的 <code>props</code> 对象。同时，<code>props</code> 对象中 <code>onChange</code> 属性的值也会是全新的函数。这会导致渲染器对 <code>Comp</code> 组件进行更新，造成额外的性能开销。为了避免这类无用的更新，我们需要对内联事件处理函数进行缓存，如下面的代码所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function render(ctx, cache) {</span></span>
<span class="line"><span>02   return h(Comp, {</span></span>
<span class="line"><span>03     // 将内联事件处理函数缓存到 cache 数组中</span></span>
<span class="line"><span>04     onChange: cache[0] || (cache[0] = ($event) =&gt; (ctx.a + ctx.b))</span></span>
<span class="line"><span>05   })</span></span>
<span class="line"><span>06 }</span></span></code></pre></div><p>渲染函数的第二个参数是一个数组 <code>cache</code>，该数组来自组件实例，我们可以把内联事件处理函数添加到 <code>cache</code> 数组中。这样，当渲染函数重新执行并创建新的虚拟 DOM 树时，会优先读取缓存中的事件处理函数。这样，无论执行多少次渲染函数，<code>props</code> 对象中 <code>onChange</code> 属性的值始终不变，于是就不会触发 <code>Comp</code> 组件更新了。</p><p><em>在这里由于内联函数是全新的函数，造成无用的更新，所以进行了缓存。但是非内联本身就缓存过的，所以不必要处理。</em></p><h3 id="_17-6-v-once" tabindex="-1">17.6　<code>v-once</code> <a class="header-anchor" href="#_17-6-v-once" aria-label="Permalink to &quot;17.6　`v-once`&quot;">​</a></h3><p>Vue.js 3 不仅会缓存内联事件处理函数，配合 <code>v-once</code> 还可实现对虚拟 DOM 的缓存。Vue.js 2 也支持 <code>v-once</code> 指令，当编译器遇到 <code>v-once</code> 指令时，会利用我们上一节介绍的 <code>cache</code> 数组来缓存渲染函数的全部或者部分执行结果，如下面的模板所示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;section&gt;</span></span>
<span class="line"><span>02   &lt;div v-once&gt;{{ foo }}&lt;/div&gt;</span></span>
<span class="line"><span>03 &lt;/section&gt;</span></span></code></pre></div><p>在上面这段模板中，<code>div</code> 标签存在动态绑定的文本内容。但是它被 <code>v-once</code> 指令标记，所以这段模板会被编译为：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 function render(ctx, cache) {</span></span>
<span class="line"><span>02   return (openBlock(), createBlock(&#39;div&#39;, null, [</span></span>
<span class="line"><span>03     cache[1] || (cache[1] = createVNode(&quot;div&quot;, null, ctx.foo, 1 /* TEXT */))</span></span>
<span class="line"><span>04   ]))</span></span>
<span class="line"><span>05 }</span></span></code></pre></div><p>从编译结果中可以看到，该 <code>div</code> 标签对应的虚拟节点被缓存到了 <code>cache</code> 数组中。既然虚拟节点已经被缓存了，那么后续更新导致渲染函数重新执行时，会优先读取缓存的内容，而不会重新创建虚拟节点。同时，由于虚拟节点被缓存，意味着更新前后的虚拟节点不会发生变化，因此也就不需要这些被缓存的虚拟节点参与 Diff 操作了。所以在实际编译后的代码中经常出现下面这段内容：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 render(ctx, cache) {</span></span>
<span class="line"><span>02   return (openBlock(), createBlock(&#39;div&#39;, null, [</span></span>
<span class="line"><span>03     cache[1] || (</span></span>
<span class="line"><span>04       setBlockTracking(-1), // 阻止这段 VNode 被 Block 收集</span></span>
<span class="line"><span>05       cache[1] = h(&quot;div&quot;, null, ctx.foo, 1 /* TEXT */),</span></span>
<span class="line"><span>06       setBlockTracking(1), // 恢复</span></span>
<span class="line"><span>07       cache[1] // 整个表达式的值</span></span>
<span class="line"><span>08     )</span></span>
<span class="line"><span>09   ]))</span></span>
<span class="line"><span>10 }</span></span></code></pre></div><p>注意上面这段代码中的 <code>setBlockTracking(-1)</code> 函数调用，它用来暂停动态节点的收集。换句话说，使用 <code>v-once</code> 包裹的动态节点不会被父级 <code>Block</code> 收集。因此，被 <code>v-once</code> 包裹的动态节点在组件更新时，自然不会参与 Diff 操作。</p><p><code>v-once</code> 指令通常用于不会发生改变的动态绑定中，例如绑定一个常量：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div&gt;{{ SOME_CONSTANT }}&lt;/div&gt;</span></span></code></pre></div><p>为了提升性能，我们可以使用 <code>v-once</code> 来标记这段内容：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>01 &lt;div v-once&gt;{{ SOME_CONSTANT }}&lt;/div&gt;</span></span></code></pre></div><p>这样，在组件更新时就会跳过这段内容的更新，从而提升更新性能。</p><p>实际上，<code>v-once</code> 指令能够从两个方面提升性能。</p><ul><li>避免组件更新时重新创建虚拟 DOM 带来的性能开销。因为虚拟 DOM 被缓存了，所以更新时无须重新创建。</li><li>避免无用的 Diff 开销。这是因为被 <code>v-once</code> 标记的虚拟 DOM 树不会被父级 <code>Block</code> 节点收集。</li></ul><h3 id="_17-7-总结" tabindex="-1">17.7　总结 <a class="header-anchor" href="#_17-7-总结" aria-label="Permalink to &quot;17.7　总结&quot;">​</a></h3><p>本章中，我们主要讨论了 Vue.js 3 在编译优化方面所做的努力。编译优化指的是通过编译的手段提取关键信息，并以此指导生成最优代码的过程。具体来说，Vue.js 3 的编译器会充分分析模板，提取关键信息并将其附着到对应的虚拟节点上。在运行时阶段，渲染器通过这些关键信息执行“快捷路径”，从而提升性能。</p><p>编译优化的核心在于，区分动态节点与静态节点。Vue.js 3 会为动态节点打上补丁标志，即 <code>patchFlag</code>。同时，Vue.js 3 还提出了 <code>Block</code> 的概念，一个 <code>Block</code> 本质上也是一个虚拟节点，但与普通虚拟节点相比，会多出一个 <code>dynamicChildren</code> 数组。该数组用来收集所有动态子代节点，这利用了 <code>createVNode</code> 函数和 <code>createBlock</code> 函数的层层嵌套调用的特点，即以“由内向外”的方式执行。再配合一个用来临时存储动态节点的节点栈，即可完成动态子代节点的收集。</p><p>由于 <code>Block</code> 会收集所有动态子代节点，所以对动态节点的比对操作是忽略 DOM 层级结构的。这会带来额外的问题，即 <code>v-if</code>、<code>v-for</code> 等结构化指令会影响 DOM 层级结构，使之不稳定。这会间接导致基于 <code>Block</code> 树的比对算法失效。而解决方式很简单，只需要让带有 <code>v-if</code>、<code>v-for</code> 等指令的节点也作为 <code>Block</code> 角色即可。</p><p>除了 <code>Block</code> 树以及补丁标志之外，Vue.js 3 在编译优化方面还做了其他努力，具体如下。</p><ul><li>静态提升：能够减少更新时创建虚拟 DOM 带来的性能开销和内存占用。</li><li>预字符串化：在静态提升的基础上，对静态节点进行字符串化。这样做能够减少创建虚拟节点产生的性能开销以及内存占用。</li><li>缓存内联事件处理函数：避免造成不必要的组件更新。</li><li><code>v-once</code> 指令：缓存全部或部分虚拟节点，能够避免组件更新时重新创建虚拟 DOM 带来的性能开销，也可以避免无用的 Diff 操作。</li></ul><h2 id="第-18-章-同构渲染" tabindex="-1">第 18 章　同构渲染 <a class="header-anchor" href="#第-18-章-同构渲染" aria-label="Permalink to &quot;第 18 章　同构渲染&quot;">​</a></h2><h3 id="_18-1-csr、ssr-以及同构渲染" tabindex="-1">18.1　CSR、SSR 以及同构渲染 <a class="header-anchor" href="#_18-1-csr、ssr-以及同构渲染" aria-label="Permalink to &quot;18.1　CSR、SSR 以及同构渲染&quot;">​</a></h3><p><strong>表 18-1　SSR 与 CSR 的比较</strong></p><table><thead><tr><th style="text-align:left;"></th><th style="text-align:left;">SSR</th><th style="text-align:left;">CSR</th></tr></thead><tbody><tr><td style="text-align:left;">SEO</td><td style="text-align:left;">友好</td><td style="text-align:left;">不友好</td></tr><tr><td style="text-align:left;">白屏问题</td><td style="text-align:left;">无</td><td style="text-align:left;">有</td></tr><tr><td style="text-align:left;">占用服务端资源</td><td style="text-align:left;">多</td><td style="text-align:left;">少</td></tr><tr><td style="text-align:left;">用户体验</td><td style="text-align:left;">差</td><td style="text-align:left;">好</td></tr></tbody></table><h3 id="_18-6-总结" tabindex="-1">18.6　总结 <a class="header-anchor" href="#_18-6-总结" aria-label="Permalink to &quot;18.6　总结&quot;">​</a></h3><p>在本章中，我们首先讨论了 CSR、SSR 和同构渲染的工作机制，以及它们各自的优缺点。具体可以总结为表 18-3。</p><p><strong>表 18-3　CSR 和 SSR 的比较</strong></p><table><thead><tr><th style="text-align:left;"></th><th style="text-align:left;">SSR</th><th style="text-align:left;">CSR</th></tr></thead><tbody><tr><td style="text-align:left;">SEO</td><td style="text-align:left;">友好</td><td style="text-align:left;">不友好</td></tr><tr><td style="text-align:left;">白屏问题</td><td style="text-align:left;">无</td><td style="text-align:left;">有</td></tr><tr><td style="text-align:left;">占用服务端资源</td><td style="text-align:left;">多</td><td style="text-align:left;">少</td></tr><tr><td style="text-align:left;">用户体验</td><td style="text-align:left;">差</td><td style="text-align:left;">好</td></tr></tbody></table><p>当我们为应用程序选择渲染架构时，需要结合软件的需求及场景，选择合适的渲染方案。</p><p>接着，我们讨论了 Vue.js 是如何把虚拟节点渲染为字符串的。以普通标签节点为例，在将其渲染为字符串时，要考虑以下内容。</p><ul><li>自闭合标签的处理。对于自闭合标签，无须为其渲染闭合标签部分，也无须处理其子节点。</li><li>属性名称的合法性，以及属性值的转义。</li><li>文本子节点的转义。</li></ul><p>具体的转义规则如下。</p><ul><li>对于普通内容，应该对文本中的以下字符进行转义。 <ul><li>将字符 <code>&amp;</code> 转义为实体 <code>&amp;</code>。</li><li>将字符 <code>&lt;</code> 转义为实体 <code>&lt;</code>。</li><li>将字符 <code>&gt;</code> 转义为实体 <code>&gt;</code>。</li></ul></li><li>对于属性值，除了上述三个字符应该转义之外，还应该转义下面两个字符。 <ul><li>将字符 <code>&quot;</code> 转义为实体 <code>&quot;</code>。</li><li>将字符 <code>&#39;</code> 转义为实体 <code>&#39;</code>。</li></ul></li></ul><p>然后，我们讨论了如何将组件渲染为 HTML 字符串。在服务端渲染组件与渲染普通标签并没有本质区别。我们只需要通过执行组件的 <code>render</code> 函数，得到该组件所渲染的 <code>subTree</code> 并将其渲染为 HTML 字符串即可。另外，在渲染组件时，需要考虑以下几点。</p><ul><li>服务端渲染不存在数据变更后的重新渲染，所以无须调用 <code>reactive</code> 函数对 <code>data</code> 等数据进行包装，也无须使用 <code>shallowReactive</code> 函数对 <code>props</code> 数据进行包装。正因如此，我们也无须调用 <code>beforeUpdate</code> 和 <code>updated</code> 钩子。</li><li>服务端渲染时，由于不需要渲染真实 DOM 元素，所以无须调用组件的 <code>beforeMount</code> 和 <code>mounted</code> 钩子。</li></ul><p>之后，我们讨论了客户端激活的原理。在同构渲染过程中，组件的代码会分别在服务端和浏览器中执行一次。在服务端，组件会被渲染为静态的 HTML 字符串，并发送给浏览器。浏览器则会渲染由服务端返回的静态的 HTML 内容，并下载打包在静态资源中的组件代码。当下载完毕后，浏览器会解释并执行该组件代码。当组件代码在客户端执行时，由于页面中已经存在对应的 DOM 元素，所以渲染器并不会执行创建 DOM 元素的逻辑，而是会执行激活操作。激活操作可以总结为两个步骤。</p><ul><li>在虚拟节点与真实 DOM 元素之间建立联系，即 <code>vnode.el = el</code>。这样才能保证后续更新程序正确运行。</li><li>为 DOM 元素添加事件绑定。</li></ul><p>最后，我们讨论了如何编写同构的组件代码。由于组件代码既运行于服务端，也运行于客户端，所以当我们编写组件代码时要额外注意。具体可以总结为以下几点。</p><ul><li>注意组件的生命周期。<code>beforeUpdate</code>、<code>updated</code>、<code>beforeMount</code>、<code>mounted</code>、<code>beforeUnmount</code>、<code>unmounted</code> 等生命周期钩子函数不会在服务端执行。</li><li>使用跨平台的 API。由于组件的代码既要在浏览器中运行，也要在服务器中运行，所以编写组件代码时，要额外注意代码的跨平台性。通常我们在选择第三方库的时候，会选择支持跨平台的库，例如使用 Axios 作为网络请求库。</li><li>特定端的实现。无论在客户端还是在服务端，都应该保证功能的一致性。例如，组件需要读取 cookie 信息。在客户端，我们可以通过 <code>document.cookie</code> 来实现读取；而在服务端，则需要根据请求头来实现读取。所以，很多功能模块需要我们为客户端和服务端分别实现。</li><li>避免交叉请求引起的状态污染。状态污染既可以是应用级的，也可以是模块级的。对于应用，我们应该为每一个请求创建一个独立的应用实例。对于模块，我们应该避免使用模块级的全局变量。这是因为在不做特殊处理的情况下，多个请求会共用模块级的全局变量，造成请求间的交叉污染。</li><li>仅在客户端渲染组件中的部分内容。这需要我们自行封装 <code>&lt;ClientOnly&gt;</code> 组件，被该组件包裹的内容仅在客户端才会被渲染。</li></ul></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-d4a0bba5><!--[--><!--]--><!----><!----></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter" data-v-5d98c3a5 data-v-e315a0ad><div class="container" data-v-e315a0ad><!----><p class="copyright" data-v-e315a0ad>Copyright © 2019-present 544402029</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"o6iEpeIN\",\"zhufeng_前端工程化.md\":\"2CLevtWq\",\"前端笔记_http协议原理_实践 web开发工程师必学.md\":\"BGHwo2db\",\"前端笔记_javascript正则迷你书.md\":\"DfGTdC20\",\"vue源码_vue源码day1.md\":\"B9KyTtWN\",\"vue源码_vue源码day4.md\":\"D2Ri60OZ\",\"前端笔记_electron_vue3_ai_云存储--实战跨平台桌面应用.md\":\"DYZ3XcUI\",\"vue源码_vue源码day3.md\":\"DppU8LyA\",\"前端笔记_git.md\":\"Dg2y4KfD\",\"前端笔记_koa2新浪博客.md\":\"BvaeeP9q\",\"vue源码_vue源码day2.md\":\"C71WKbD_\",\"vue源码_vue源码day5.md\":\"B26w6rmK\",\"面试题库_node.js.md\":\"BnHG0puZ\",\"前端笔记_后台通用提效解决方案.md\":\"CUVIYIBm\",\"面试题库_vue全家桶.md\":\"CX0royJz\",\"面试题库_其它.md\":\"BzgIoFVS\",\"前端笔记_node.js从零开发webserver博客项目_前端晋升全栈工程师必备.md\":\"CDNEQPib\",\"前端笔记_计算机网络通关29讲.md\":\"DFetsAZ5\",\"zhufeng_node.js核心.md\":\"tCDjQsS6\",\"面试题库_html.md\":\"t_-ClRjF\",\"前端笔记_linux命令.md\":\"BhaCr7oR\",\"前端笔记_node.js_koa2从0到1打造超好用web框架一步到位_掌握koa2服务端开发.md\":\"C6rkvpsV\",\"前端笔记_正则表达式.md\":\"DDSymi3D\",\"前端笔记_微信小程序.md\":\"DFBQqs6-\",\"面试题库_vue的diff算法.md\":\"V-hRw3Xo\",\"前端笔记_vue使用.md\":\"CGX7lEFq\",\"前端笔记_vue全家桶_ssr_koa2全栈开发美团网.md\":\"Bdf170Uf\",\"前端笔记_图解http.md\":\"BJurDo2A\",\"面试题库_vue3.md\":\"DKdGBxM4\",\"面试题库_通信类.md\":\"DP4OW9X8\",\"面试题库_面试真题2022.md\":\"D4CTVJr0\",\"前端笔记_javascript 设计模式核⼼原理与应⽤实践.md\":\"8v4vONiw\",\"前端笔记_typescript.md\":\"14RWCQXB\",\"面试题库_笔试题.md\":\"BudI4vYn\",\"面试题库_css.md\":\"BmQWHz8r\",\"常用代码片段_js常用代码片段.md\":\"BcxFBGIQ\",\"面试题库_vue.md\":\"C7h9lSPc\",\"面试题库_javascript.md\":\"Dyc3QMdl\",\"前端笔记_webpack.md\":\"BGiUtbl8\",\"常用代码片段_css常用代码片段.md\":\"By7o8vYn\",\"面试题库_面试题合集2025.md\":\"BnxlMLKI\",\"前端笔记_深入理解 es6.md\":\"Dv72dQXf\",\"前端笔记_vue.js设计与实现.md\":\"Bm9ioqNK\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"似若秋叶\",\"description\":\"专注写作前端博客，记录日常所得。\",\"base\":\"/blog/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"footer\":{\"copyright\":\"Copyright © 2019-present 544402029\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"search\":{\"provider\":\"local\"},\"nav\":[{\"text\":\"首页\",\"link\":\"/index.md\"},{\"text\":\"常用代码片段\",\"items\":[{\"text\":\"CSS常用代码片段\",\"link\":\"/常用代码片段/CSS常用代码片段.md\"},{\"text\":\"JS常用代码片段\",\"link\":\"/常用代码片段/JS常用代码片段.md\"}]},{\"text\":\"前端笔记\",\"items\":[{\"text\":\"Vue使用\",\"link\":\"/前端笔记/vue使用.md\"},{\"text\":\"Git\",\"link\":\"/前端笔记/Git.md\"},{\"text\":\"微信小程序\",\"link\":\"/前端笔记/微信小程序.md\"},{\"text\":\"深入理解ES6\",\"link\":\"/前端笔记/深入理解 ES6.md\"},{\"text\":\"正则表达式\",\"link\":\"/前端笔记/正则表达式.md\"},{\"text\":\"JavaScript正则迷你书\",\"link\":\"/前端笔记/JavaScript正则迷你书.md\"},{\"text\":\"JavaScript 设计模式核⼼原理与应⽤实践\",\"link\":\"/前端笔记/JavaScript 设计模式核⼼原理与应⽤实践.md\"},{\"text\":\"Webpack\",\"link\":\"/前端笔记/Webpack.md\"},{\"text\":\"TypeScript\",\"link\":\"/前端笔记/TypeScript.md\"},{\"text\":\"Node.js从零开发Web Server博客项目\",\"link\":\"/前端笔记/Node.js从零开发WebServer博客项目,前端晋升全栈工程师必备.md\"},{\"text\":\"Node.js+KOA2 从0到1打造超好用Web框架一步到位\",\"link\":\"/前端笔记/Node.js+KOA2从0到1打造超好用Web框架一步到位,掌握KOA2服务端开发.md\"},{\"text\":\"Vue全家桶+SSR+Koa2全栈开发美团网\",\"link\":\"/前端笔记/Vue全家桶+SSR+Koa2全栈开发美团网.md\"},{\"text\":\"Koa2新浪博客\",\"link\":\"/前端笔记/Koa2新浪博客.md\"},{\"text\":\"linux命令\",\"link\":\"/前端笔记/linux命令.md\"},{\"text\":\"图解HTTP\",\"link\":\"/前端笔记/图解HTTP.md\"},{\"text\":\"HTTP协议原理\",\"link\":\"/前端笔记/HTTP协议原理+实践 Web开发工程师必学.md\"},{\"text\":\"计算机网络通关29讲\",\"link\":\"/前端笔记/计算机网络通关29讲.md\"},{\"text\":\"后台通用提效解决方案\",\"link\":\"/前端笔记/后台通用提效解决方案.md\"},{\"text\":\"Electron+Vue3+AI+云存储--实战跨平台桌面应用\",\"link\":\"/前端笔记/Electron+Vue3+AI+云存储--实战跨平台桌面应用.md\"},{\"text\":\"Vue.js设计与实现\",\"link\":\"/前端笔记/Vue.js设计与实现.md\"}]},{\"text\":\"Vue源码\",\"items\":[{\"text\":\"Vue源码day1\",\"link\":\"/vue源码/vue源码day1.md\"},{\"text\":\"Vue源码day2\",\"link\":\"/vue源码/vue源码day2.md\"},{\"text\":\"Vue源码day3\",\"link\":\"/vue源码/vue源码day3.md\"},{\"text\":\"Vue源码day4\",\"link\":\"/vue源码/vue源码day4.md\"},{\"text\":\"Vue源码day5\",\"link\":\"/vue源码/vue源码day5.md\"}]},{\"text\":\"珠峰架构\",\"items\":[{\"text\":\"Node.js核心\",\"link\":\"/zhufeng/Node.js核心.md\"},{\"text\":\"前端工程化\",\"link\":\"/zhufeng/前端工程化.md\"}]},{\"text\":\"面试题库\",\"items\":[{\"text\":\"通信类\",\"link\":\"/面试题库/通信类.md\"},{\"text\":\"HTML\",\"link\":\"/面试题库/HTML.md\"},{\"text\":\"CSS\",\"link\":\"/面试题库/CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/面试题库/JavaScript.md\"},{\"text\":\"笔试题\",\"link\":\"/面试题库/笔试题.md\"},{\"text\":\"Vue\",\"link\":\"/面试题库/Vue.md\"},{\"text\":\"Vue3\",\"link\":\"/面试题库/Vue3.md\"},{\"text\":\"Node.js\",\"link\":\"/面试题库/Node.js.md\"},{\"text\":\"其它\",\"link\":\"/面试题库/其它.md\"},{\"text\":\"vue的diff算法\",\"link\":\"/面试题库/vue的diff算法.md\"},{\"text\":\"Vue全家桶\",\"link\":\"/面试题库/vue全家桶.md\"},{\"text\":\"面试真题2022\",\"link\":\"/面试题库/面试真题2022.md\"},{\"text\":\"面试题合集2025\",\"link\":\"/面试题库/面试题合集2025.md\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/544402029/blog\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>