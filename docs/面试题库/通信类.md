---
prev: 面试真题2022
next: HTML
---

## 浏览器

### HTTP 协议类

<a name="e7a007ed"></a>

#### HTTP 协议的主要特点?

1.  简单快速 (每个资源都是固定的 URI)
1.  灵活 (通过一个 HTTP 协议可以完成不同数据类型的传输)
1.  **无连接 (连接一次断掉 , 不会一直连接)**
1.  **无状态 (客户端和服务端是两种身份，一次连接后就断开，下次再连接，服务端无法区分两次是否由同一客户端发起的请求)**

<a name="d1b3f61a"></a>

#### HTTP 报文的组成部分?

**由请求报文和响应报文组成:**

1.  请求报文：请求行、请求头、空行、请求体

- 请求行包含：地址、http 方法、协议以及版本 (`GET` / `HTTP1.1`)
- 请求头：就是一些 key\value 值 , **告诉服务端我要什么内容** , 和要注意什么类型
- 空行：遇到空行就能知道 下面不是请求头的部分了
- 请求体：数据

2.  响应报文：状态行，响应头、空行、响应体

- 状态行: HTTP 协议、状态码 (`HTTP1.1`/ `200` ok)
- 其它都是与请求报文大同小异的

<a name="4e20fa4e"></a>

#### HTTP 方法有哪些?

- GET---------获取资源
- POST-------传输资源
- PUT---------更新资源
- DELETE------删除资源
- HEAD--------获取报文首部

<a name="68c050e4"></a>

#### Get 请求和 Post 请求的区别是什么?主要作用在哪?

1. `get`点击浏览器回退按钮**不会再次提交** , `post`**会再次提交请求**
1. `get`请求会被浏览器主动**缓存** , `post`不会 (除非手动设置)
1. `get`的参数可以保留在浏览器**历史记录** , `post`不会
1. `get`产生的 URL 地址可以被**收藏**，`post`不可以
1. `get`参数通过 url 传递 ，是**明文显示**的, `post`通过`Request body`, `post`传递敏感信息相对更安全
1. `get`传送参数**长度**是有限制的(2kb) , `post`无限制（浏览器规定的长度）
1. `post` 支持更多的**编码类型**, 且不对数据类型限制

<a name="4d49b476"></a>

#### http 首部

首部分为请求首部和响应首部，并且部分首部两种通用。

**通用首部**<br />![](https://gitee.com/l544402029/res/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621410618962.png#crop=0&crop=0&crop=1&crop=1&id=YPJst&originHeight=458&originWidth=600&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

**请求首部**<br />![](https://gitee.com/l544402029/res/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621410593330.png#crop=0&crop=0&crop=1&crop=1&id=dEWT0&originHeight=853&originWidth=601&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

**响应首部**<br />![](https://gitee.com/l544402029/res/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621410659764.png#crop=0&crop=0&crop=1&crop=1&id=tH4Aa&originHeight=428&originWidth=599&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

**实体首部**<br />![](https://gitee.com/l544402029/res/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1621410695691.png#crop=0&crop=0&crop=1&crop=1&id=o3ugx&originHeight=567&originWidth=599&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

<a name="ceb95077"></a>

#### 什么是持久链接?

持久连接 `Keep-alive`

非`Keep-ailve`模式时，每个请求/应答客户端和服务器都要新建一个连接，完成后就断开

当`Keep-ailve`模式（又称持久连接、连接重用）时，客户端到服务器端的**连接持续有效**，避免后续请求时，重新建立连接。<br />并且必须是**http1.1**版本才支持持久连接。

<a name="0fe1dfce"></a>

#### 什么是管线化?

- **GET** 和 **HEAD** 可以管线化 ， **POST 是有所限制**
- 初次创建连接时不应该启动管线机制， 因为对方（服务器）不一定支持 HTTP/1.1 版本的协议

持久连接：请求 1 -》响应 1-》请求 2-》响应 2-》请求 3 -》响应 3

管线化：请求 1-》请求 2-》请求 3-》响应 1-》响应 2-》响应 3 把现在的请求一次打包传输过去，响应也是一次性返回过来，并且是在持久连接的情况下完成的， 管线化是通过持久连接完成，仅 HTTP/1.1 支持此技术。

<a name="8ccda5c8"></a>

#### HTTP 与 HTTPS 的区别？

- HTTP 协议通常**承载于 TCP 协议**之上，在 HTTP 和 TCP 之间添加一个**安全协议层**（SSL 或 TLS），就成了我们常说的 HTTPS。
- 默认 HTTP 的端口号为`80`，HTTPS 的端口号为`443`。

<a name="21bde80c"></a>

#### 为什么 HTTPS 安全？

因为网络请求需要中间有很多的**服务器路由器的转发**。中间的节点很有可能篡改信息，而如果使用 HTTPS，密钥在你和终点站才有。<br />https 之所以比 http 安全，是因为他利用了 `ssl/tls` 协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，`refer` 传递等，保障了传输过程的安全性。

<a name="e7bf778b"></a>

#### contentType 有哪几种类型?

1.  `application/json`
1.  `text/xml`
1.  `multipart/form-data`
1.  `application/x-www-form-urlencoded`

<a name="cb3edea1"></a>

#### 如何保持登录状态？

- `cookie`+`session`

`cookie`的特点：`cookie`会伴随每次请求，在浏览器和服务器之间来回传递；

![](https://gitee.com/l544402029/res/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/cookie.png#crop=0&crop=0&crop=1&crop=1&id=qKcuy&originHeight=599&originWidth=1203&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

- `token` 令牌机制

非 web 端，没有 `cookie` ，因此不能用 `cookie` + `sessionid` 这种机制实现状态保持。<br />但是我们可以借鉴这个实现思路，自己模拟 `cookie` 和 `session` 的机制，`token`机制（令牌机制）。
<a name="f4dfd761"></a>

####

<a name="c0d5ec40"></a>

#### status 状态码

- 1xx 指示信息
  - 表示请求一接收，继续处理
- 2xx 表示成功处理请求
  - `200`表示客户端请求成功
  - `206`表示范围请求（视频，音频文件很大的时候，基本返回的都是 206）
- 3xx 重定向
  - `301`永久重定向，被分配新的 url
  - `302`临时重定向，临时分配新 url
  - `304`表示使用缓存
- 4xx 客户端请求错误
  - `400`语法错误，不能被服务器所理解
  - `401`请求未经授权
  - `403`请求页面的访问被禁止
  - `404`请求资源不存在
- 5xx 服务器端错误
  - `500`服务器执行请求发生错误
  - `501`服务器不支持当前请求所需的某个功能
  - `503`服务器过载或宕机

<a name="YztWL"></a>

#### 简述三次握手是什么？

HTTP 协议是使用 TCP 协议作为其传输层协议的，在拿到服务器的 IP 地址后，浏览器客户端会与服务器建立 TCP 连接。该过程包括三次握手：

1. 建立连接时，客户端向服务器**发送请求报文**
1. 服务器收到请求报文后，**如同意连接**，则向客户端**发送确认报文**
1. 客户端收到服务器的确认后，**再次向服务器发出确认报文**，完成连接。

三次握手主要是为了防止已经失效的请求报文字段发送给服务器，浪费资源。

<a name="zrMV1"></a>

#### 简述四次挥手是什么？

1. 客户端**想断开连接**，发送消息给服务器
1. 服务器通知客户端已经接收到断开连接请求，但**还没做好断开连接准备（服务器可能还在向客户端发送数据）**
1. 服务器已经**做好断开连接准备**，通知客户端
1. 客户端**发送消息**给服务器，**确定断开连接**，服务器关闭连接

<a name="11669476"></a>

#### UDP 与 TCP 的区别是什么？

首先 UDP 协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方。然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且 UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便。

**面向无连接**<br />首先 UDP 是不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。

并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。

具体来说就是：

- 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
- 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作

**不可靠性**

首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。

并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。

再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。

**高效**<br />虽然 UDP 协议不是那么的可靠，但是正是因为它不是那么的可靠，所以也就没有 TCP 那么复杂了，需要保证数据不丢失且有序到达。

**传输方式**<br />UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

**适合使用的场景**

UDP 虽然对比 TCP 有很多缺点，但是正是因为这些缺点造就了它高效的特性，在很多实时性要求高的地方都可以看到 UDP 的身影。

- 直播<br />想必大家都看过直播吧，大家可以考虑下如果直播使用了基于 TCP 的协议会发生什么事情？

TCP 会严格控制传输的正确性，一旦有某一个数据对端没有收到，就会停止下来直到对端收到这个数据。这种问题在网络条件不错的情况下可能并不会发生什么事情，但是在网络情况差的时候就会变成画面卡住，然后再继续播放下一帧的情况。

但是对于直播来说，用户肯定关注的是最新的画面，而不是因为网络条件差而丢失的老旧画面，所以 TCP 在这种情况下无用武之地，只会降低用户体验。

- 王者荣耀<br />虽然不知道王者荣耀底层使用了什么协议，但是对于这类实时性要求很高的游戏来说，UDP 是跑不了的。

为什么这样说呢？首先对于王者荣耀来说，用户体量是相当大的，如果使用 TCP 连接的话，就可能会出现服务器不够用的情况，因为每台服务器可供支撑的 TCP 连接数量是有限制的。

再者，因为 TCP 会严格控制传输的正确性，如果因为用户网络条件不好就造成页面卡顿然后再传输旧的游戏画面是肯定不能接受的，毕竟对于这类实时性要求很高的游戏来说，最新的游戏画面才是最需要的，而不是老旧的画面，否则角色都不知道死多少次了。

**小结：**

- UDP 相比 TCP 更加简单，不需要**建立连接**，不需要**验证数据报文**，不需要**流量控制**，只会把想发的数据报文一股脑的丢给对端
- UDP 并没有 TCP 传输来的**准确**，但是能在很多实时性要求高的地方有所作为（直播，王者荣耀）

<a name="33aafee3"></a>

#### 为什么 TCP 建立连接需要三次握手，明明两次就可以建立起连接？

解释：

弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。

- 第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
- 第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
- 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。

试想如果是用两次握手，则会出现下面这种情况：

> 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端**，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一直等待客户端发送数据，浪费资源。

<a name="52fd83b7"></a>

### 通信类

<a name="1822eba5"></a>

#### 什么是同源策略及限制？

- 同源：**协议**，**域名**，**端口**三者必须一致！

同源策略限制两个不同源加载的文档和脚本进行交互，它是一个隔离潜在恶意文件的安全机制。

- 限制：
  - cookie LocalStorage IndexDB 无法获取
  - DOM 无法取得
  - Ajax 不能发送

前端： `http://a.com:8080/`<br />server： `https://b.com/api/xxx`

`http` `https`是协议 ， `a.com`是域名 ， 默认端口是`80`。<br />如上， 协议， 域名， 端口都不相同， 无法发送请求。

<a name="a0fb3f58"></a>

#### 为什么浏览器要使用同源策略？

那么是出于什么安全考虑才会引入这种机制呢？ 其实主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求。

也就是说，没有同源策略的情况下，A 网站可以被任意其他来源的 Ajax 访问到内容。如果你当前 A 网站还存在登录态，那么对方就可以通过 Ajax 获得你的任何信息。当然跨域并不能完全阻止 CSRF。

然后我们来考虑一个问题，请求跨域了，那么请求到底发出去没有？ 请求必然是发出去了，但是浏览器**拦截了响应**。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会。因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。

**加载图片，js，css 可无视同源策略**

- `<img/>`可用于统计打点，可使用第三方统计服务
- `<link/>`、`<script/>`可使用 CDN， CDN 一般都是外域
- `<script/>`可实现 JSONP

<a name="673c91f0"></a>

#### 你有几种方式可以解决跨域问题？

- JSONP

利用 `<script>` 标签没有跨域限制。通过 `<script>` 标签指向一个需要访问的地址并提供一个回调函数来接收数据。

JSONP 使用简单且兼容性不错，但是只限于 `get` 请求。

```javascript
<script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
<script>
    function jsonp(data) {
    	console.log(data)
	}
</script>
```

服务器返回的东西类似于以下代码

```
jsonp({})
```

<a name="1b1c7365"></a>

##### 手动封装 SONP

在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP，以下是简单实现:

```javascript
function jsonp(url, jsonpCallback, success) {
  let script = document.createElement("script");
  script.src = url;
  script.async = true;
  script.type = "text/javascript";
  window[jsonpCallback] = function (data) {
    success && success(data);
  };
  document.body.appendChild(script);
}
jsonp(
  "https://webapi.amap.com/maps?v=1.4.10&key=76&callback=onmaploaded",
  "onmaploaded",
  function (value) {
    console.log(value);
  }
);
```

**原理：**

1. jsonp 发送的不是 ajax 请求。
1. jsonp 动态创建一个`script`标签， 因为`script`标签是没有同源策略限制的，是可以跨域的。
1. 把这个`script`标签的 src 指向我们请求的服务端地址， 这个地址会携带一个参数：callback。 一个回调函数 ， 服务端会把数据通过这个回调函数返回给客户端，但是客户端没有这个函数怎么接受呢？ 所以在发送请求之前，要在全局（window）注册这样一个方法， 利用这个方法， 来获得数据。
1. 这个回调函数名需要跟服务器约定好， 是一致的。

- CORS

CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。

浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

![](https://gitee.com/l544402029/res/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1582717982532.png#crop=0&crop=0&crop=1&crop=1&id=n2raG&originHeight=460&originWidth=1403&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。

- 简单请求<br />以 Ajax 为例，当满足以下条件时，会触发简单请求

1.  使用下列方法之一：

- GET
- HEAD
- POST

2.  `Content-Type` 的值仅限于下列三者之一：

- text/plain
- multipart/form-data
- application/x-www-form-urlencoded

请求中的任意 `XMLHttpRequestUpload` 对象均没有注册任何事件监听器； `XMLHttpRequestUpload` 对象可以使用 `XMLHttpRequest.upload` 属性访问。

- 复杂请求

那么很显然，不符合以上条件的请求就肯定是复杂请求了。

对于复杂请求来说，首先会发起一个预检请求，该请求是 `option` 方法的，通过该请求来知道服务端是否允许跨域请求。

对于预检请求来说，如果你使用过 Node 来设置 CORS 的话，可能会遇到过这么一个坑

以下以 express 框架举例：

```javascript
app.use((req, res, next) => {
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Methods", "PUT, GET, POST, DELETE, OPTIONS");
  res.header(
    "Access-Control-Allow-Headers",
    "Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials"
  );
  next();
});
```

该请求会验证你的 Authorization 字段，没有的话就会报错。

当前端发起了复杂请求后，你会发现就算你代码是正确的，返回结果也永远是报错的。因为预检请求也会进入回调中，也会触发 next 方法，因为预检请求并不包含 Authorization 字段，所以服务端会报错。

想解决这个问题很简单，只需要在回调中过滤 option 方法即可

```javascript
res.statusCode = 204;
res.setHeader("Content-Length", "0");
res.end();
```

- postmessage

获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息

```javascript
// 发送消息端
window.parent.postMessage("message", "http://test.com");
// 接收消息端
var mc = new MessageChannel();
mc.addEventListener("message", (event) => {
  var origin = event.origin || event.originalEvent.origin;
  if (origin === "http://test.com") {
    console.log("验证通过");
  }
});
```

- document.domain

该方式只能用于二级域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式。

只需要给页面添加 `document.domain = 'test.com'` 表示二级域名都相同就可以实现跨域

<a name="43782d4b"></a>

#### Ajax 原理

`Ajax`的原理简单来说是在用户和服务器之间**加了—个中间层(**`**AJAX**`**引擎)**，通过`XmlHttpRequest`对象来**向服务器发异步请求**，从服务器**获得数据**，然后用`JS`来**操作**`**DOM**`**而更新页面**。使用户操作与服务器响应**异步化**。`XMLHttpRequest`是`ajax`的核心机制。

<a name="6136c183"></a>

#### Ajax 具体怎么实现?

```javascript
let xhr = new XMLHttpRequest();
xhr.onreadystatechange = function () {
  if (xhr.readyState == 4) {
    try {
      if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
        alert(xhr.responseText);
      } else {
        alert("Request was unsuccessful: " + xhr.status);
      }
    } catch (ex) {
      // 假设由ontimeout处理
    }
  }
};

xhr.open("get", "timeout.php", true);
xhr.timeout = 1000; // 设置1秒超时
xhr.ontimeout = function () {
  alert("Request did not return in a second.");
};
xhr.send(null);
```

<a name="pOQ6f"></a>

#### readyState 状态码

- 0 - 未初始化 , 还**没有**调用`send`方法
- 1 - 载入 **已调用**`send`方法,**正在发送请求**
- 2 - 载入完成 `send`方法**执行完成** , 已**接收到全部**响应内容
- 3 - 交互 正在**解析**响应内容
- 4 - 完成 **响应内容解析完成** , 可以在客户端**调用**
  <a name="07e0c5bf"></a>

### 安全防范

<a name="e9e9f3e9"></a>

#### 什么是 XSS 攻击？如何防范 XSS 攻击？

基本概念: **跨域脚本攻击**

XSS 简单点来说，就是攻击者将可以执行的代码注入到网页中。

**举例：**

- 一个博客网站, 我发表一篇博客， 其中嵌入`<script>`脚本
- 脚本内容： 获取 cookie ， 发送到我的服务器（服务器配合跨域）
- 发布这篇博客， 有人查看它， 我轻松收割访问者的 cookie

<a name="55f0d2c0"></a>

##### 防范:

转义输入输出的内容，对于引号、尖括号、斜杠进行转义

<a name="a2b01aa4"></a>

#### 什么是 CSRF 攻击？如何防范 CSRF 攻击？

CSRF , 通常称为**跨站请求伪造**

**原理:**

原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。

举个例子，假设网站中有一个通过 GET 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口

```html
<img src="http://www.domain.com/xxx?comment='attack'" />
```

那么你是否会想到使用 POST 方式提交请求是不是就没有这个问题了呢？其实并不是，使用这种方式也不是百分百安全的，攻击者同样可以诱导用户进入某个页面，在页面中通过表单提交 POST 请求。

**预防：**

1. Get 请求不对数据进行修改
1. 不让第三方网站访问到用户 `Cookie`
1. 阻止第三方网站请求接口
1. 请求时附带验证信息，比如验证码或者 Token
   1. token 验证：登陆成功后服务器下发 token 令牌存到用户本地，再次访问时要**主动发送 token**，浏览器只能主动发`cookie`，做不到主动发`token`
   1. referer 验证：判断页面来源是否自己站点的页面，不是不执行请求
   1. 隐藏令牌： 令牌放在`http header`头中，而不是链接中 (和`token`类似)
   1. 验证码。

**SameSite**<br />可以对 `Cookie` 设置 `SameSite` 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。

**验证 Referer**<br />对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。

**Token**<br />服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。

<a name="4b8b8e9e"></a>

#### CSRF 与 XSS 的区别：

CSRF 需要用户登陆，利用网站自己的接口漏洞进行攻击

xss 通过注入脚本执行自己的代码

<a name="d90cfc6b"></a>

#### 什么是点击劫持？如何防范点击劫持？

点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 `iframe` 嵌套的方式嵌入自己的网页中，并将 `iframe` 设置为透明，在页面中透出一个按钮诱导用户点击。

- X-FRAME-OPTIONS<br />`X-FRAME-OPTIONS` 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 `iframe` 嵌套的点击劫持攻击。

该响应头有三个值可选，分别是

- `DENY`，表示页面不允许通过 iframe 的方式展示
- `SAMEORIGIN`，表示页面可以在相同域名下通过 iframe 的方式展示
- `ALLOW-FROM`，表示页面可以在指定来源的 iframe 中展示

JS 防御<br />对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。

```html
<head>
  <style id="click-jack">
    html {
      display: none !important;
    }
  </style>
</head>
<body>
  <script>
    if (self == top) {
      var style = document.getElementById("click-jack");
      document.body.removeChild(style);
    } else {
      top.location = self.location;
    }
  </script>
</body>
```

以上代码的作用就是当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。

<a name="6e8b18fe"></a>

#### 什么是中间人攻击？如何防范中间人攻击？

中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。

通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。

当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。

<a name="a39cf1ca"></a>

### 存储

<a name="17ab6a0b"></a>

#### 有几种方式可以实现存储功能，分别有什么优缺点？

cookie，localStorage，sessionStorage，indexDB

我们先来通过表格学习下这几种存储方式的区别:

![](https://gitee.com/l544402029/res/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1584256285204.png#crop=0&crop=0&crop=1&crop=1&id=ZqrxU&originHeight=321&originWidth=848&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

从上表可以看到，`cookie` 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 `localStorage` 和 `sessionStorage` 。对于不怎么改变的数据尽量使用 `localStorage` 存储，否则可以用 `sessionStorage` 存储。

对于`cookie` 来说，我们还需要注意安全性。

![](https://gitee.com/l544402029/res/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1584256604881.png#crop=0&crop=0&crop=1&crop=1&id=DKCmY&originHeight=299&originWidth=679&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

<a name="5f841be4"></a>

### 浏览器渲染原理

<a name="77834e33"></a>

#### 输入 URL 到页面渲染的整个流程

<a name="cd4f975f"></a>

##### 一. 首先浏览器根据请求的 URL 交给 DNS 域名解析

DNS 的作用就是通过域名查询到具体的 IP。

因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。

在 TCP 握手之前就已经进行了 DNS 查询，这个查询是操作系统自己做的。当你在浏览器中想访问 `www.google.com` 时，会进行一下操作：

- DNS 查询解析的详细过程

过程：`. -> .com -> google.com. -> www.google.com`

1. 首先在**本地域名服务器**中查询 IP 地址
1. 如果没有找到的情况下，本地域名会向**根域名服务器**发送请求
1. 如果根域名服务器也不存在该域名时，本地域名会向**com 顶级域名服务器**发送请求
1. 依次类推下去。直到最后本地域名服务器得到`google`的 IP 地址并把它缓存到本地，供下次查询使用。

<a name="2d4d2f60"></a>

##### 二. 接下来是 TCP 三次握手：

1. 得到 ip 地址后向服务器**发送请求报文**
1. 服务器收到请求报文后，**如同意连接**，则向客户端**发送确认报文**
1. 客户端收到服务器的确认后，**再次向服务器发出确认报文**，完成连接。

<a name="7f6ed4fc"></a>

##### 三. 浏览器接收相应的数据后开始解析文件

数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件。

首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。

浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。

文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。

如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP/2 协议的话会极大的提高多图的下载效率。

CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西

在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。

- 根据 HTML 构建 DOM 树。
- 有 CSS 的话会去构建 CSSOM 树。
- 如果遇到 script 标签的话，会判断是否存在 `async` 或者 `defer` ，`async`的话并行下载并执行 JS，`defer`的话会先下载文件，然后等待 HTML 解析完成后按顺序执行。
- CSSOM 树和 DOM 树构建完成后结合后生成 Render 树，确定页面元素的布局、样式等。在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将要显示的节点显示在页面。

<a name="89f1ebfe"></a>

#### 浏览器渲染过程？

> 我们知道执行 JS 有一个 JS 引擎，那么执行渲染也有一个渲染引擎。同样，渲染引擎在不同的浏览器中也不是都相同的。比如在 Firefox 中叫做 **Gecko**，在 Chrome 和 Safari 中都是基于 **WebKit** 开发的。在这一章节中，我们也会主要学习关于 **WebKit** 的这部分渲染引擎内容。

<a name="053e91ed"></a>

##### 浏览器接收到 HTML 文件并转换为 DOM 树

`字节数据 => 字符串 => Token => Node => DOM`

- 当我们打开网页时，浏览器先去请求对应的 HTML 文件。HTML 只是字符串，计算机不识别，网络传输内容都是`0`和`1`这样的**字节数据**。浏览器会先把**字节数据转换为字符串**，也就是我们写的代码。
- 然后将字符串**语法分析**转换为**标记**（token）。这一过程在词法分析中叫做标记化（tokenization）。
- 标记化后紧接着转换为**Node**
- 然后根据 Node 之间的联系构建成**DOM 树**。
- 在解析 HTML 文件的时候，浏览器还会遇到 CSS 和 JS 文件，这时候浏览器也会去下载并解析这些文件。

![](https://gitee.com/l544402029/res/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1620463115865.png#crop=0&crop=0&crop=1&crop=1&id=PvQwB&originHeight=274&originWidth=622&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

<br />什么是标记呢？？这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，是构成代码的**最小单位**。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。<br />![](https://gitee.com/l544402029/res/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1620462997739.png#crop=0&crop=0&crop=1&crop=1&id=RVwqB&originHeight=214&originWidth=519&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />:::

<a name="80d93484"></a>

##### 将 CSS 文件转换为 CSSOM 树

- 和转化 DOM 树基本相似，浏览器会**先确定每个节点的样式**，样式可以自行设置，也是可以继承的。（**很消耗资源**）
- 浏览器需要**递归 CSSOM** 树，确定元素的具体样式。
- 由于递归过程是很复杂的，我们应该避免写**过于具体**的 CSS 选择器，HTML 也不要添加无意义标签，保证**层级扁平**。

<a name="6fadc942"></a>

##### 生成渲染树

- 当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。
- 渲染树只会渲染**需要显示的节点**，如果`display: none`就不会显示。
- 然后开始进行布局，（也可以叫做回流），调用 GPU 绘制，合成图层，显示在页面。

<a name="5ffa0267"></a>

#### 加载一个资源的过程

1. 浏览器根据 DNS 服务器获取域名的 IP 地址
1. 向这个 IP 的服务器发送 http 请求
1. 服务器收到,处理,并返回 http 请求
1. 浏览器得到返回内容

<a name="1b85ea5a"></a>

#### 为什么操作 DOM 慢？

想必大家都听过操作 DOM 性能很差，但是这其中的原因是什么呢？

因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了**两个线程之间的通信**，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来**重绘回流**的情况，所以也就导致了性能上的问题。

<a name="59e33a31"></a>

#### 插入几万个 DOM，如何实现页面不卡顿？

使用[虚拟滚动（virtualized scroller）](https://github.com/bvaughn/react-virtualized)。<br />这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。

<a name="18ae2db4"></a>

#### 什么情况阻塞渲染?

首先渲染的前提是生成渲染树，所以 **HTML** 和 **CSS** 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的**文件大小**，并且**扁平层级**，**优化选择器**。

然后当浏览器在解析到 `script`标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 `script`标签放在 `body` 标签底部的原因。

当然在当下，并不是说 `script`标签必须放在底部，因为你可以给 `script`标签添加 `defer`或者 `async`属性。

当 `script`标签加上 `defer` 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 `script`标签放在任意位置。

`async` 属性下载完就立即执行，会阻塞 html 解析

<a name="c2f42bd2"></a>

### 性能优化

<a name="7b90e593"></a>

#### 如何进行性能优化?

1.  多使用内存 , 缓存 , 减少 cpu 计算

- 强缓存表示在缓存期间，不需要请求，`State Code`为 200，`Cache-Control`可以组合使用多个
- 强缓存可以通过设置`Expires` `Cache-Control`来实现。如果两个都有以后者为准。
- 协商缓存： 协商缓存表示如果缓存过期了，那么就需要重新发起请求验证资源是否有更新，
- 可通过设置`HTTP Header`的`Last-Modified`和`ETag`来实现，如果资源没有改变，`State Code`为`304`

2.  资源压缩 ,合并, 减少 http 请求
3.  非核心代码异步加载  
    <a name="647063a7"></a>

##### 异步加载的方式

1.  动态脚本加载：动态创建 script 标签添加到页面
1.  `defer`: 在 html 解析完成执行 , 如果是多个 , 则按照加载顺序执行
1.  `async`: 加载完成后立即执行 , 如果是多个 , 执行顺序与加载顺序无关

1.  使用 CDN：

CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。

因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。

5. DNS 预解析

DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。

```html
<meta http-equiv="x-dns-prefetch-control" content="on" />
//在https中强制打开a标签预解析

<link rel="dns-prefetch" href="//baidu.com" /> //dns预解析
```

<a name="fb6799d6"></a>

#### 图片类:

1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。
1. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
1. 小图使用 base64 格式
1. 将多个图标文件整合到一张图片中（雪碧图）
1. 选择正确的图片格式：
   - 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
   - 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
   - 照片使用 JPEG

<a name="9d525f15"></a>

#### CSS 类:

1.  css 放在 head 里 (先加载 css 然后渲染 否则渲染两次)
1.  不使用 css 表达式
1.  正确使用选择器 (应从右向左匹配 , 避免层级过多 , 扁平化)

<a name="032bffd4"></a>

#### JS 类:

1.  JS 放在 body 最下面 (不会阻塞渲染过程 性能优化问题； 再执行 JS script 能拿到所有标签)
1.  减少 DOM 操作 , 对 DOM 查询进行缓存
1.  频繁 DOM 操作， 合并到一起插入 DOM 结构
1.  尽早在 dom 渲染完就执行，用 DOMContentLoaded 触发
1.  删除不需要的脚本
1.  节流
1.  防抖
1.  预加载:

- 优点:降低首屏加载时间
- 缺点:兼容性不好

如果有些资源需要马上使用，可以使用如下代码实现，预加载不会阻塞`onload`事件

```html
<link rel="preload" href="http://example.com" />
```

9. 预渲染:
   - 要确保用户大概率会打开的资源进行预渲染，可以提升网页的加载速度

可以通过预渲染将下载的文件预先在后台渲染，

```html
<link rel="prerender" href="http://example.com" />
```

10. 懒加载:

懒加载就是将不关键的资源延后加载。

对于图片来说，先设置图片标签的 `src` 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 `src` 属性，这样图片就会去下载资源，实现了图片懒加载。

懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。

```javascript
var myImage = (function () {
  var imgNode = document.createElement("img");
  document.body.appendChild(imgNode);
  var img = new Image();
  img.onload = function () {
    imgNode.src = img.src;
  };
  return {
    setSrc: function (src) {
      imgNode.src = "loading.gif";
      img.src = src;
    },
  };
})();
myImage.setSrc("https://img1.sycdn.imooc.com/5c09123400014ba418720632.jpg");
```

<a name="dfd62077"></a>

### 浏览器缓存机制

缓存可以说是性能优化中**简单高效**的一种优化方式了，它可以**显著减少网络传输所带来的损耗。**

对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。

<a name="f4c11fa9"></a>

#### 缓存位置

从缓存位置上来说分为四种，并且各自有**优先级**，当依次查找缓存且都没有命中的时候，才会去请求网络

1. Service Worker
1. Memory Cache
1. Disk Cache
1. Push Cache
1. 网络请求

<a name="17145319"></a>

##### Service Worker

Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。<br />当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。

<a name="58220c57"></a>

##### Memory Cache

Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。<br />当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存<br />那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？

先说结论，这是不可能的。首先计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。内存中其实可以存储大部分的文件，比如说 JSS、HTML、CSS、图片等等。但是浏览器会把哪些文件丢进内存这个过程就很玄学了，我查阅了很多资料都没有一个定论。

当然，我通过一些实践和猜测也得出了一些结论：

- 对于大文件来说，大概率是不存储在内存中的，反之优先
- 当前系统内存使用率高的话，文件优先存储进硬盘

<a name="382dfda1"></a>

##### Disk Cache

Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。

在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。

<a name="173bde88"></a>

##### Push Cache

Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。

Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及，但是 HTTP/2 将会是日后的一个趋势。这里推荐阅读  [HTTP/2 push is tougher than I thought](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/) 这篇文章，但是内容是英文的，我翻译一下文章中的几个结论，有能力的同学还是推荐自己阅读

- 所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好
- 可以推送 no-cache 和 no-store 的资源
- 一旦连接被关闭，Push Cache 就被释放
- 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存
- Push Cache 中的缓存只能被使用一次
- 浏览器可以拒绝接受已经存在的资源推送
- 你可以给其他域名推送资源

<a name="b02c5964"></a>

##### 网络请求

如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。

那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，接下来我们就来学习缓存策略这部分的内容。

<a name="e1b848a0"></a>

#### 缓存策略

通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。

<a name="7e6073e2"></a>

##### 强缓存

强缓存可以通过设置两种 HTTP Header 实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，`state code` 为 200。

- Expires

```http
Expires: Wed, 22 Oct 2018 08:41:00 GMT
```

`Expires` 是 HTTP/1 的产物，表示资源会在 `Wed, 22 Oct 2018 08:41:00 GMT` 后过期，需要再次请求。并且 `Expires` **受限于本地时间**，如果修改了本地时间，可能会造成缓存失效。

- Cache-control

```http
Cache-control: max-age=30
```

`Cache-Control` 出现于 HTTP/1.1，**优先级高于** `Expires` 。该属性值表示资源会在 30 秒后过期，需要再次请求。

`Cache-Control` **可以在请求头或者响应头中设置**，并且可以组合使用多种指令

![](https://gitee.com/l544402029/res/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1620460652836.png#crop=0&crop=0&crop=1&crop=1&id=eUHZk&originHeight=600&originWidth=595&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

从图中我们可以看到，我们可以将**多个指令配合起来一起使用**，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。

接下来我们就来学习一些常见指令的作用

![](https://gitee.com/l544402029/res/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1620460740234.png#crop=0&crop=0&crop=1&crop=1&id=RHG4x&originHeight=486&originWidth=770&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

<a name="f9465812"></a>

##### 协商缓存

如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：`Last-Modified` 和 `ETag` 。

当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 304 状态码，并且更新浏览器缓存有效期。

![](https://gitee.com/l544402029/res/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1620460988968.png#crop=0&crop=0&crop=1&crop=1&id=EyA7f&originHeight=215&originWidth=474&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

- Last-Modified 和 If-Modified-Since

`Last-Modified` 表示本地文件最后修改日期，`If-Modified-Since` 会将 `Last-Modified` 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。

但是 Last-Modified 存在一些弊端：

- 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 `Last-Modified` 被修改，服务端不能命中缓存导致发送相同的资源
- 因为 `Last-Modified` 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源<br />因为以上这些弊端，所以在 HTTP / 1.1 出现了 `ETag` 。
- ETag 和 If-None-Match<br />`ETag` 类似于文件指纹，`If-None-Match` 会将当前 `ETag` 发送给服务器，询问该资源 `ETag` 是否变动，有变动的话就将新的资源发送回来。并且 `ETag` 优先级比 `Last-Modified` 高。

以上就是缓存策略的所有内容了，看到这里，不知道你是否存在这样一个疑问。如果什么缓存策略都没设置，那么浏览器会怎么处理？

对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 `Date` 减去 `Last-Modified` 值的 10% 作为缓存时间。

<a name="fe113466"></a>

##### 实际场景应用缓存策略

单纯了解理论而不付诸于实践是没有意义的，接下来我们来通过几个场景学习下如何使用这些理论。

- 频繁变动的资源<br />对于频繁变动的资源，首先需要使用 `Cache-Control: no-cache` 使浏览器每次都请求服务器，然后配合 `ETag` 或者 `Last-Modified` 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。
- 代码文件<br />这里特指除了 HTML 外的代码文件，因为 HTML 文件一般不缓存或者缓存时间很短。

  一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 `Cache-Control: max-age=31536000`，这样只有当 HTML 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存。

<a name="137be314"></a>

### 前端监控

<a name="1c02c7ce"></a>

#### 前端监控一般分为哪几种？

前端监控一般分为三种，分别为页面埋点、性能监控以及异常监控。

<a name="9a6f91c8"></a>

#### 前端错误的分类

- 即时运行错误：代码错误
- 资源加载错误

<a name="88aa1644"></a>

#### 错误的捕获方式

- 即时运行错误：代码错误
  - try..catch
  - window.onerror
- 资源加载错误
  - object.onerror
  - performance.getEntries()
  - Error 事件**捕获**

<a name="0abced30"></a>

#### 跨域的 js 运行错误可以捕获吗？错误提示什么？应该怎么处理

![](https://gitee.com/l544402029/res/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1587443059574.png#crop=0&crop=0&crop=1&crop=1&id=MPQtu&originHeight=254&originWidth=703&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

1. 在 script 标签增加`crossorigin`属性 `<script src="..." crossorigin ></script>`
1. 设置 js 资源响应头 Access-Control-Allow-Origin:\*

<a name="9f5fb3b0"></a>

#### 上报错误的基本原理

1. 采用 Ajax 通信的方式上报
1. 利用 Image 对象上报

```javascript
new Image().src = "http://baidu.com/tesjk?r=tksjk";
```

<a name="ada114bb"></a>

### 浏览器内核

<a name="d77169e1"></a>

#### 能介绍一下你对浏览器内核的理解吗？

主要分成两部分：渲染引擎(`layout engineer或Rendering Engine`)和 JS 引擎

- 渲染引擎：

负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。

浏览器的内核的不同对于网页的语法解释会有不同，渲染的效果也会不相同。

- JS 引擎：

解析和执行 javascript 来实现网页的动态效果

<a name="SEO"></a>

### SEO

<a name="e88a1c1a"></a>

#### 前端需要注意哪些 SEO?

- 合理的`title`、`keywords` 。`title` 值强调重点即可，不同页面 title 要有所不同，重要关键词出现不要超过 2 次，而且要靠前
- **语义化**的 HTML 代码，符合 W3C 规范，让搜索引擎容易理解网页
- 重要内容 HTML 代码**放在最前**：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
- 重要内容**不要用 js 输出**， 爬虫不会执行 js 获取内容
- **少用**`**iframe**`，搜索引擎不会抓取 `iframe` 中的内容
- **非装饰性图片**必须加`alt`
- 提高**网站速度**：网站速度是搜索引擎排序的一个重要指标

---
