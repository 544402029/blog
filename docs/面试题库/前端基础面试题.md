# 前端基础面试题库

## HTTP 协议的主要特点?

1.  简单快速 (每个资源都是固定的 URI)
1.  灵活 (通过一个 HTTP 协议可以完成不同数据类型的传输)
1.  **无连接 (连接一次断掉 , 不会一直连接)**
1.  **无状态 (客户端和服务端是两种身份，一次连接后就断开，下次再连接，服务端无法区分两次是否由同一客户端发起的请求)**



## HTTP 报文的组成部分?

**由请求报文和响应报文组成:**

1.  请求报文：请求行、请求头、空行、请求体

- 请求行包含：地址、http 方法、协议以及版本 (`GET` / `HTTP1.1`)
- 请求头：就是一些 key\value 值 , **告诉服务端我要什么内容** , 和要注意什么类型
- 空行：遇到空行就能知道 下面不是请求头的部分了
- 请求体：数据

2.  响应报文：状态行，响应头、空行、响应体

- 状态行: HTTP 协议、状态码 (`HTTP1.1`/ `200` ok)
- 其它都是与请求报文大同小异的



## HTTP 方法有哪些?

- GET---------获取资源
- POST-------传输资源
- PUT---------更新资源
- DELETE------删除资源
- HEAD--------获取报文首部



## Get 请求和 Post 请求的区别是什么?主要作用在哪?

1. `get`点击浏览器回退按钮**不会再次提交** , `post`**会再次提交请求**
1. `get`请求会被浏览器主动**缓存** , `post`不会 (除非手动设置)
1. `get`的参数可以保留在浏览器**历史记录** , `post`不会
1. `get`产生的 URL 地址可以被**收藏**，`post`不可以
1. `get`参数通过 url 传递 ，是**明文显示**的, `post`通过`Request body`, `post`传递敏感信息相对更安全
1. `get`传送参数**长度**是有限制的(2kb) , `post`无限制（浏览器规定的长度）
1. `post` 支持更多的**编码类型**, 且不对数据类型限制



#### http 首部

首部分为请求首部和响应首部，并且部分首部两种通用。

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/tongyongshoubu.png)

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/qingqiushoubu.png)

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/xiangyingshoubu.png)

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/shitishoubu.png)



## 什么是持久链接?

持久连接 `Keep-alive`

非`Keep-ailve`模式时，每个请求/应答客户端和服务器都要新建一个连接，完成后就断开

当`Keep-ailve`模式（又称持久连接、连接重用）时，客户端到服务器端的**连接持续有效**，避免后续请求时，重新建立连接。

并且必须是**http1.1**版本才支持持久连接。



## 什么是管线化?

- **GET** 和 **HEAD** 可以管线化 ， **POST 是有所限制**
- 初次创建连接时不应该启动管线机制， 因为对方（服务器）不一定支持 HTTP/1.1 版本的协议

持久连接：请求 1 -》响应 1-》请求 2-》响应 2-》请求 3 -》响应 3

管线化：请求 1-》请求 2-》请求 3-》响应 1-》响应 2-》响应 3 把现在的请求一次打包传输过去，响应也是一次性返回过来，并且是在持久连接的情况下完成的， 管线化是通过持久连接完成，仅 HTTP/1.1 支持此技术。



## HTTP 与 HTTPS 的区别？

- HTTP 协议通常**承载于 TCP 协议**之上，在 HTTP 和 TCP 之间添加一个**安全协议层**（SSL 或 TLS），就成了我们常说的 HTTPS。
- 默认 HTTP 的端口号为`80`，HTTPS 的端口号为`443`。



## 为什么 HTTPS 安全？

因为网络请求需要中间有很多的**服务器路由器的转发**。中间的节点很有可能篡改信息，而如果使用 HTTPS，密钥在你和终点站才有。<br />https 之所以比 http 安全，是因为他利用了 `ssl/tls` 协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，`refer` 传递等，保障了传输过程的安全性。



## contentType 有哪几种类型?

1.  `application/json`
1.  `text/xml`
1.  `multipart/form-data`
1.  `application/x-www-form-urlencoded`



## 如何保持登录状态？

- `cookie`+`session`

`cookie`的特点：`cookie`会伴随每次请求，在浏览器和服务器之间来回传递；

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/cookietoken.png)

- `token` 令牌机制

非 web 端，没有 `cookie` ，因此不能用 `cookie` + `sessionid` 这种机制实现状态保持。

但是我们可以借鉴这个实现思路，自己模拟 `cookie` 和 `session` 的机制，`token`机制（令牌机制）。




## status 状态码

- 1xx 指示信息
  - 表示请求一接收，继续处理
- 2xx 表示成功处理请求
  - `200`表示客户端请求成功
  - `206`表示范围请求（视频，音频文件很大的时候，基本返回的都是 206）
- 3xx 重定向
  - `301`永久重定向，被分配新的 url
  - `302`临时重定向，临时分配新 url
  - `304`表示使用缓存
- 4xx 客户端请求错误
  - `400`语法错误，不能被服务器所理解
  - `401`请求未经授权
  - `403`请求页面的访问被禁止
  - `404`请求资源不存在
- 5xx 服务器端错误
  - `500`服务器执行请求发生错误
  - `501`服务器不支持当前请求所需的某个功能
  - `503`服务器过载或宕机



## 简述三次握手是什么？

HTTP 协议是使用 TCP 协议作为其传输层协议的，在拿到服务器的 IP 地址后，浏览器客户端会与服务器建立 TCP 连接。该过程包括三次握手：

1. 建立连接时，客户端向服务器**发送请求报文**
1. 服务器收到请求报文后，**如同意连接**，则向客户端**发送确认报文**
1. 客户端收到服务器的确认后，**再次向服务器发出确认报文**，完成连接。

三次握手主要是为了防止已经失效的请求报文字段发送给服务器，浪费资源。



## 简述四次挥手是什么？

1. 客户端**想断开连接**，发送消息给服务器
1. 服务器通知客户端已经接收到断开连接请求，但**还没做好断开连接准备（服务器可能还在向客户端发送数据）**
1. 服务器已经**做好断开连接准备**，通知客户端
1. 客户端**发送消息**给服务器，**确定断开连接**，服务器关闭连接



## UDP 与 TCP 的区别是什么？

首先 UDP 协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方。然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且 UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便。

**面向无连接**

首先 UDP 是不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。

并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。

具体来说就是：

- 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
- 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作

**不可靠性**

首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。

并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。

再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。

**高效**

虽然 UDP 协议不是那么的可靠，但是正是因为它不是那么的可靠，所以也就没有 TCP 那么复杂了，需要保证数据不丢失且有序到达。

**传输方式**

UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

**适合使用的场景**

UDP 虽然对比 TCP 有很多缺点，但是正是因为这些缺点造就了它高效的特性，在很多实时性要求高的地方都可以看到 UDP 的身影。

- 直播

  想必大家都看过直播吧，大家可以考虑下如果直播使用了基于 TCP 的协议会发生什么事情？

TCP 会严格控制传输的正确性，一旦有某一个数据对端没有收到，就会停止下来直到对端收到这个数据。这种问题在网络条件不错的情况下可能并不会发生什么事情，但是在网络情况差的时候就会变成画面卡住，然后再继续播放下一帧的情况。

但是对于直播来说，用户肯定关注的是最新的画面，而不是因为网络条件差而丢失的老旧画面，所以 TCP 在这种情况下无用武之地，只会降低用户体验。

- 王者荣耀

  虽然不知道王者荣耀底层使用了什么协议，但是对于这类实时性要求很高的游戏来说，UDP 是跑不了的。

为什么这样说呢？首先对于王者荣耀来说，用户体量是相当大的，如果使用 TCP 连接的话，就可能会出现服务器不够用的情况，因为每台服务器可供支撑的 TCP 连接数量是有限制的。

再者，因为 TCP 会严格控制传输的正确性，如果因为用户网络条件不好就造成页面卡顿然后再传输旧的游戏画面是肯定不能接受的，毕竟对于这类实时性要求很高的游戏来说，最新的游戏画面才是最需要的，而不是老旧的画面，否则角色都不知道死多少次了。

**小结：**

- UDP 相比 TCP 更加简单，不需要**建立连接**，不需要**验证数据报文**，不需要**流量控制**，只会把想发的数据报文一股脑的丢给对端
- UDP 并没有 TCP 传输来的**准确**，但是能在很多实时性要求高的地方有所作为（直播，王者荣耀）



## 为什么 TCP 建立连接需要三次握手，明明两次就可以建立起连接？

解释：

弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。

- 第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
- 第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
- 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。

试想如果是用两次握手，则会出现下面这种情况：

> 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端**，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一直等待客户端发送数据，浪费资源。





## 什么是同源策略及限制？

- 同源：**协议**，**域名**，**端口**三者必须一致！

同源策略限制两个不同源加载的文档和脚本进行交互，它是一个隔离潜在恶意文件的安全机制。

- 限制：
  - cookie LocalStorage IndexDB 无法获取
  - DOM 无法取得
  - Ajax 不能发送

前端： `http://a.com:8080/`

server： `https://b.com/api/xxx`

`http` `https`是协议 ， `a.com`是域名 ， 默认端口是`80`。

如上， 协议， 域名， 端口都不相同， 无法发送请求。



## 为什么浏览器要使用同源策略？

那么是出于什么安全考虑才会引入这种机制呢？ 其实主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求。

也就是说，没有同源策略的情况下，A 网站可以被任意其他来源的 Ajax 访问到内容。如果你当前 A 网站还存在登录态，那么对方就可以通过 Ajax 获得你的任何信息。当然跨域并不能完全阻止 CSRF。

然后我们来考虑一个问题，请求跨域了，那么请求到底发出去没有？ 请求必然是发出去了，但是浏览器**拦截了响应**。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会。因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。

**加载图片，js，css 可无视同源策略**

- `<img/>`可用于统计打点，可使用第三方统计服务
- `<link/>`、`<script/>`可使用 CDN， CDN 一般都是外域
- `<script/>`可实现 JSONP



## 你有几种方式可以解决跨域问题？

- JSONP

利用 `<script>` 标签没有跨域限制。通过 `<script>` 标签指向一个需要访问的地址并提供一个回调函数来接收数据。

JSONP 使用简单且兼容性不错，但是只限于 `get` 请求。

```javascript
<script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
<script>
    function jsonp(data) {
    	console.log(data)
	}
</script>
```

服务器返回的东西类似于以下代码

```
jsonp({})
```



## 手动封装 SONP

在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP，以下是简单实现:

```javascript
function jsonp(url, jsonpCallback, success) {
  let script = document.createElement("script");
  script.src = url;
  script.async = true;
  script.type = "text/javascript";
  window[jsonpCallback] = function (data) {
    success && success(data);
  };
  document.body.appendChild(script);
}
jsonp(
  "https://webapi.amap.com/maps?v=1.4.10&key=76&callback=onmaploaded",
  "onmaploaded",
  function (value) {
    console.log(value);
  }
);
```

**原理：**

1. jsonp 发送的不是 ajax 请求。
1. jsonp 动态创建一个`script`标签， 因为`script`标签是没有同源策略限制的，是可以跨域的。
1. 把这个`script`标签的 src 指向我们请求的服务端地址， 这个地址会携带一个参数：callback。 一个回调函数 ， 服务端会把数据通过这个回调函数返回给客户端，但是客户端没有这个函数怎么接受呢？ 所以在发送请求之前，要在全局（window）注册这样一个方法， 利用这个方法， 来获得数据。
1. 这个回调函数名需要跟服务器约定好， 是一致的。

- CORS

CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。

浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/cors.png)

虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。

- 简单请求

  以 Ajax 为例，当满足以下条件时，会触发简单请求

1.  使用下列方法之一：

- GET
- HEAD
- POST

2.  `Content-Type` 的值仅限于下列三者之一：

- text/plain
- multipart/form-data
- application/x-www-form-urlencoded

请求中的任意 `XMLHttpRequestUpload` 对象均没有注册任何事件监听器； `XMLHttpRequestUpload` 对象可以使用 `XMLHttpRequest.upload` 属性访问。

- 复杂请求

那么很显然，不符合以上条件的请求就肯定是复杂请求了。

对于复杂请求来说，首先会发起一个预检请求，该请求是 `option` 方法的，通过该请求来知道服务端是否允许跨域请求。

对于预检请求来说，如果你使用过 Node 来设置 CORS 的话，可能会遇到过这么一个坑

以下以 express 框架举例：

```javascript
app.use((req, res, next) => {
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Methods", "PUT, GET, POST, DELETE, OPTIONS");
  res.header(
    "Access-Control-Allow-Headers",
    "Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials"
  );
  next();
});
```

该请求会验证你的 Authorization 字段，没有的话就会报错。

当前端发起了复杂请求后，你会发现就算你代码是正确的，返回结果也永远是报错的。因为预检请求也会进入回调中，也会触发 next 方法，因为预检请求并不包含 Authorization 字段，所以服务端会报错。

想解决这个问题很简单，只需要在回调中过滤 option 方法即可

```javascript
res.statusCode = 204;
res.setHeader("Content-Length", "0");
res.end();
```

- postmessage

获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息

```javascript
// 发送消息端
window.parent.postMessage("message", "http://test.com");
// 接收消息端
var mc = new MessageChannel();
mc.addEventListener("message", (event) => {
  var origin = event.origin || event.originalEvent.origin;
  if (origin === "http://test.com") {
    console.log("验证通过");
  }
});
```

- document.domain

该方式只能用于二级域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式。

只需要给页面添加 `document.domain = 'test.com'` 表示二级域名都相同就可以实现跨域



## Ajax 原理

`Ajax`的原理简单来说是在用户和服务器之间**加了—个中间层(**`**AJAX**`**引擎)**，通过`XmlHttpRequest`对象来**向服务器发异步请求**，从服务器**获得数据**，然后用`JS`来**操作**`**DOM**`**而更新页面**。使用户操作与服务器响应**异步化**。`XMLHttpRequest`是`ajax`的核心机制。



## Ajax 具体怎么实现?

```javascript
let xhr = new XMLHttpRequest();
xhr.onreadystatechange = function () {
  if (xhr.readyState == 4) {
    try {
      if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
        alert(xhr.responseText);
      } else {
        alert("Request was unsuccessful: " + xhr.status);
      }
    } catch (ex) {
      // 假设由ontimeout处理
    }
  }
};

xhr.open("get", "timeout.php", true);
xhr.timeout = 1000; // 设置1秒超时
xhr.ontimeout = function () {
  alert("Request did not return in a second.");
};
xhr.send(null);
```



## readyState 状态码

- 0 - 未初始化 , 还**没有**调用`send`方法
- 1 - 载入 **已调用**`send`方法,**正在发送请求**
- 2 - 载入完成 `send`方法**执行完成** , 已**接收到全部**响应内容
- 3 - 交互 正在**解析**响应内容
- 4 - 完成 **响应内容解析完成** , 可以在客户端**调用**



## 什么是 XSS 攻击？如何防范 XSS 攻击？

基本概念: **跨域脚本攻击**

XSS 简单点来说，就是攻击者将可以执行的代码注入到网页中。

**举例：**

- 一个博客网站, 我发表一篇博客， 其中嵌入`<script>`脚本
- 脚本内容： 获取 cookie ， 发送到我的服务器（服务器配合跨域）
- 发布这篇博客， 有人查看它， 我轻松收割访问者的 cookie



#### 防范:

转义输入输出的内容，对于引号、尖括号、斜杠进行转义



## 什么是 CSRF 攻击？如何防范 CSRF 攻击？

CSRF , 通常称为**跨站请求伪造**

**原理:**

原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。

举个例子，假设网站中有一个通过 GET 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口

```html
<img src="http://www.domain.com/xxx?comment='attack'" />
```

那么你是否会想到使用 POST 方式提交请求是不是就没有这个问题了呢？其实并不是，使用这种方式也不是百分百安全的，攻击者同样可以诱导用户进入某个页面，在页面中通过表单提交 POST 请求。

**预防：**

1. Get 请求不对数据进行修改
1. 不让第三方网站访问到用户 `Cookie`
1. 阻止第三方网站请求接口
1. 请求时附带验证信息，比如验证码或者 Token
   1. token 验证：登陆成功后服务器下发 token 令牌存到用户本地，再次访问时要**主动发送 token**，浏览器只能主动发`cookie`，做不到主动发`token`
   1. referer 验证：判断页面来源是否自己站点的页面，不是不执行请求
   1. 隐藏令牌： 令牌放在`http header`头中，而不是链接中 (和`token`类似)
   1. 验证码。

**SameSite**

可以对 `Cookie` 设置 `SameSite` 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。

**验证 Referer**

对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。

**Token**

服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。



## CSRF 与 XSS 的区别：

CSRF 需要用户登陆，利用网站自己的接口漏洞进行攻击

xss 通过注入脚本执行自己的代码



## 什么是点击劫持？如何防范点击劫持？

点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 `iframe` 嵌套的方式嵌入自己的网页中，并将 `iframe` 设置为透明，在页面中透出一个按钮诱导用户点击。

- X-FRAME-OPTIONS
- `X-FRAME-OPTIONS` 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 `iframe` 嵌套的点击劫持攻击。

该响应头有三个值可选，分别是

- `DENY`，表示页面不允许通过 iframe 的方式展示
- `SAMEORIGIN`，表示页面可以在相同域名下通过 iframe 的方式展示
- `ALLOW-FROM`，表示页面可以在指定来源的 iframe 中展示

JS 防御

对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。

```html
<head>
  <style id="click-jack">
    html {
      display: none !important;
    }
  </style>
</head>
<body>
  <script>
    if (self == top) {
      var style = document.getElementById("click-jack");
      document.body.removeChild(style);
    } else {
      top.location = self.location;
    }
  </script>
</body>
```

以上代码的作用就是当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。



## 什么是中间人攻击？如何防范中间人攻击？

中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。

通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。

当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。





## 有几种方式可以实现存储功能，分别有什么优缺点？

cookie，localStorage，sessionStorage，indexDB

我们先来通过表格学习下这几种存储方式的区别:

![image-20220809090252494](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20220809090252494.png)



从上表可以看到，`cookie` 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 `localStorage` 和 `sessionStorage` 。对于不怎么改变的数据尽量使用 `localStorage` 存储，否则可以用 `sessionStorage` 存储。

对于`cookie` 来说，我们还需要注意安全性。

![image-20220809090303937](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20220809090303937.png)



## 输入 URL 到页面渲染的整个流程



#### 一. 首先浏览器根据请求的 URL 交给 DNS 域名解析

DNS 的作用就是通过域名查询到具体的 IP。

因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。

在 TCP 握手之前就已经进行了 DNS 查询，这个查询是操作系统自己做的。当你在浏览器中想访问 `www.google.com` 时，会进行一下操作：

- DNS 查询解析的详细过程

过程：`. -> .com -> google.com. -> www.google.com`

1. 首先在**本地域名服务器**中查询 IP 地址
1. 如果没有找到的情况下，本地域名会向**根域名服务器**发送请求
1. 如果根域名服务器也不存在该域名时，本地域名会向**com 顶级域名服务器**发送请求
1. 依次类推下去。直到最后本地域名服务器得到`google`的 IP 地址并把它缓存到本地，供下次查询使用。



#### 二. 接下来是 TCP 三次握手：

1. 得到 ip 地址后向服务器**发送请求报文**
1. 服务器收到请求报文后，**如同意连接**，则向客户端**发送确认报文**
1. 客户端收到服务器的确认后，**再次向服务器发出确认报文**，完成连接。



#### 三. 浏览器接收相应的数据后开始解析文件

数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件。

首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。

浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。

文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。

如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP/2 协议的话会极大的提高多图的下载效率。

CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西

在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。

- 根据 HTML 构建 DOM 树。
- 有 CSS 的话会去构建 CSSOM 树。
- 如果遇到 script 标签的话，会判断是否存在 `async` 或者 `defer` ，`async`的话并行下载并执行 JS，`defer`的话会先下载文件，然后等待 HTML 解析完成后按顺序执行。
- CSSOM 树和 DOM 树构建完成后结合后生成 Render 树，确定页面元素的布局、样式等。在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将要显示的节点显示在页面。



## 浏览器渲染过程？

> 我们知道执行 JS 有一个 JS 引擎，那么执行渲染也有一个渲染引擎。同样，渲染引擎在不同的浏览器中也不是都相同的。比如在 Firefox 中叫做 **Gecko**，在 Chrome 和 Safari 中都是基于 **WebKit** 开发的。在这一章节中，我们也会主要学习关于 **WebKit** 的这部分渲染引擎内容。



#### 浏览器接收到 HTML 文件并转换为 DOM 树

`字节数据 => 字符串 => Token => Node => DOM`

- 当我们打开网页时，浏览器先去请求对应的 HTML 文件。HTML 只是字符串，计算机不识别，网络传输内容都是`0`和`1`这样的**字节数据**。浏览器会先把**字节数据转换为字符串**，也就是我们写的代码。
- 然后将字符串**语法分析**转换为**标记**（token）。这一过程在词法分析中叫做标记化（tokenization）。
- 标记化后紧接着转换为**Node**
- 然后根据 Node 之间的联系构建成**DOM 树**。
- 在解析 HTML 文件的时候，浏览器还会遇到 CSS 和 JS 文件，这时候浏览器也会去下载并解析这些文件。

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/htmltoken.png)

什么是标记呢？？这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，是构成代码的**最小单位**。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。<br />![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/imageabaioqian.png)



#### 将 CSS 文件转换为 CSSOM 树

- 和转化 DOM 树基本相似，浏览器会**先确定每个节点的样式**，样式可以自行设置，也是可以继承的。（**很消耗资源**）
- 浏览器需要**递归 CSSOM** 树，确定元素的具体样式。
- 由于递归过程是很复杂的，我们应该避免写**过于具体**的 CSS 选择器，HTML 也不要添加无意义标签，保证**层级扁平**。



#### 生成渲染树

- 当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。
- 渲染树只会渲染**需要显示的节点**，如果`display: none`就不会显示。
- 然后开始进行布局，（也可以叫做回流），调用 GPU 绘制，合成图层，显示在页面。



## 加载一个资源的过程

1. 浏览器根据 DNS 服务器获取域名的 IP 地址
1. 向这个 IP 的服务器发送 http 请求
1. 服务器收到,处理,并返回 http 请求
1. 浏览器得到返回内容



## 为什么操作 DOM 慢？

想必大家都听过操作 DOM 性能很差，但是这其中的原因是什么呢？

因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了**两个线程之间的通信**，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来**重绘回流**的情况，所以也就导致了性能上的问题。



## 插入几万个 DOM，如何实现页面不卡顿？

使用[虚拟滚动（virtualized scroller）](https://github.com/bvaughn/react-virtualized)。

这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。



## 什么情况阻塞渲染?

首先渲染的前提是生成渲染树，所以 **HTML** 和 **CSS** 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的**文件大小**，并且**扁平层级**，**优化选择器**。

然后当浏览器在解析到 `script`标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 `script`标签放在 `body` 标签底部的原因。

当然在当下，并不是说 `script`标签必须放在底部，因为你可以给 `script`标签添加 `defer`或者 `async`属性。

当 `script`标签加上 `defer` 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 `script`标签放在任意位置。

`async` 属性下载完就立即执行，会阻塞 html 解析



## 如何进行性能优化?

1.  多使用内存 , 缓存 , 减少 cpu 计算

- 强缓存表示在缓存期间，不需要请求，`State Code`为 200，`Cache-Control`可以组合使用多个
- 强缓存可以通过设置`Expires` `Cache-Control`来实现。如果两个都有以后者为准。
- 协商缓存： 协商缓存表示如果缓存过期了，那么就需要重新发起请求验证资源是否有更新，
- 可通过设置`HTTP Header`的`Last-Modified`和`ETag`来实现，如果资源没有改变，`State Code`为`304`

2.  资源压缩 ,合并, 减少 http 请求
3.  非核心代码异步加载  

#### 异步加载的方式

1.  动态脚本加载：动态创建 script 标签添加到页面
1.  `defer`: 在 html 解析完成执行 , 如果是多个 , 则按照加载顺序执行
1.  `async`: 加载完成后立即执行 , 如果是多个 , 执行顺序与加载顺序无关

1.  使用 CDN：

CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。

因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。

5. DNS 预解析

DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。

```html
<meta http-equiv="x-dns-prefetch-control" content="on" />
//在https中强制打开a标签预解析

<link rel="dns-prefetch" href="//baidu.com" /> //dns预解析
```



### 图片类:

1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。
1. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
1. 小图使用 base64 格式
1. 将多个图标文件整合到一张图片中（雪碧图）
1. 选择正确的图片格式：
   - 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
   - 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
   - 照片使用 JPEG



### CSS 类:

1.  css 放在 head 里 (先加载 css 然后渲染 否则渲染两次)
1.  不使用 css 表达式
1.  正确使用选择器 (应从右向左匹配 , 避免层级过多 , 扁平化)



### JS 类:

1.  JS 放在 body 最下面 (不会阻塞渲染过程 性能优化问题； 再执行 JS script 能拿到所有标签)
1.  减少 DOM 操作 , 对 DOM 查询进行缓存
1.  频繁 DOM 操作， 合并到一起插入 DOM 结构
1.  尽早在 dom 渲染完就执行，用 DOMContentLoaded 触发
1.  删除不需要的脚本
1.  节流
1.  防抖
1.  预加载:

- 优点:降低首屏加载时间
- 缺点:兼容性不好

如果有些资源需要马上使用，可以使用如下代码实现，预加载不会阻塞`onload`事件

```html
<link rel="preload" href="http://example.com" />
```

9. 预渲染:
   - 要确保用户大概率会打开的资源进行预渲染，可以提升网页的加载速度

可以通过预渲染将下载的文件预先在后台渲染，

```html
<link rel="prerender" href="http://example.com" />
```

10. 懒加载:

懒加载就是将不关键的资源延后加载。

对于图片来说，先设置图片标签的 `src` 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 `src` 属性，这样图片就会去下载资源，实现了图片懒加载。

懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。

```javascript
var myImage = (function () {
  var imgNode = document.createElement("img");
  document.body.appendChild(imgNode);
  var img = new Image();
  img.onload = function () {
    imgNode.src = img.src;
  };
  return {
    setSrc: function (src) {
      imgNode.src = "loading.gif";
      img.src = src;
    },
  };
})();
myImage.setSrc("https://img1.sycdn.imooc.com/5c09123400014ba418720632.jpg");
```



## 浏览器缓存机制

缓存可以说是性能优化中**简单高效**的一种优化方式了，它可以**显著减少网络传输所带来的损耗。**

对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。



### 缓存位置

从缓存位置上来说分为四种，并且各自有**优先级**，当依次查找缓存且都没有命中的时候，才会去请求网络

1. Service Worker
1. Memory Cache
1. Disk Cache
1. Push Cache
1. 网络请求



#### Service Worker

Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。<br />当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。



#### Memory Cache

Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。<br />当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存<br />那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？

先说结论，这是不可能的。首先计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。内存中其实可以存储大部分的文件，比如说 JSS、HTML、CSS、图片等等。但是浏览器会把哪些文件丢进内存这个过程就很玄学了，我查阅了很多资料都没有一个定论。

当然，我通过一些实践和猜测也得出了一些结论：

- 对于大文件来说，大概率是不存储在内存中的，反之优先
- 当前系统内存使用率高的话，文件优先存储进硬盘



#### Disk Cache

Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。

在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。



#### Push Cache

Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。

Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及，但是 HTTP/2 将会是日后的一个趋势。这里推荐阅读  [HTTP/2 push is tougher than I thought](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/) 这篇文章，但是内容是英文的，我翻译一下文章中的几个结论，有能力的同学还是推荐自己阅读

- 所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好
- 可以推送 no-cache 和 no-store 的资源
- 一旦连接被关闭，Push Cache 就被释放
- 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存
- Push Cache 中的缓存只能被使用一次
- 浏览器可以拒绝接受已经存在的资源推送
- 你可以给其他域名推送资源



#### 网络请求

如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。

那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，接下来我们就来学习缓存策略这部分的内容。



## 缓存策略

通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。



#### 强缓存

强缓存可以通过设置两种 HTTP Header 实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，`state code` 为 200。

- Expires

```http
Expires: Wed, 22 Oct 2018 08:41:00 GMT
```

`Expires` 是 HTTP/1 的产物，表示资源会在 `Wed, 22 Oct 2018 08:41:00 GMT` 后过期，需要再次请求。并且 `Expires` **受限于本地时间**，如果修改了本地时间，可能会造成缓存失效。

- Cache-control

```http
Cache-control: max-age=30
```

`Cache-Control` 出现于 HTTP/1.1，**优先级高于** `Expires` 。该属性值表示资源会在 30 秒后过期，需要再次请求。

`Cache-Control` **可以在请求头或者响应头中设置**，并且可以组合使用多种指令

![image-20220808170938315](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20220808170938315.png)

从图中我们可以看到，我们可以将**多个指令配合起来一起使用**，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。

接下来我们就来学习一些常见指令的作用

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/httpzhiling.png)



#### 协商缓存

如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：`Last-Modified` 和 `ETag` 。

当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 304 状态码，并且更新浏览器缓存有效期。

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/skdjlkasjdlas.png)

- Last-Modified 和 If-Modified-Since

`Last-Modified` 表示本地文件最后修改日期，`If-Modified-Since` 会将 `Last-Modified` 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。

但是 Last-Modified 存在一些弊端：

- 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 `Last-Modified` 被修改，服务端不能命中缓存导致发送相同的资源

- 因为 `Last-Modified` 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源<br />因为以上这些弊端，所以在 HTTP / 1.1 出现了 `ETag` 。

- ETag 和 If-None-Match

  `ETag` 类似于文件指纹，`If-None-Match` 会将当前 `ETag` 发送给服务器，询问该资源 `ETag` 是否变动，有变动的话就将新的资源发送回来。并且 `ETag` 优先级比 `Last-Modified` 高。

以上就是缓存策略的所有内容了，看到这里，不知道你是否存在这样一个疑问。如果什么缓存策略都没设置，那么浏览器会怎么处理？

对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 `Date` 减去 `Last-Modified` 值的 10% 作为缓存时间。



#### 实际场景应用缓存策略

单纯了解理论而不付诸于实践是没有意义的，接下来我们来通过几个场景学习下如何使用这些理论。

- 频繁变动的资源

  对于频繁变动的资源，首先需要使用 `Cache-Control: no-cache` 使浏览器每次都请求服务器，然后配合 `ETag` 或者 `Last-Modified` 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。

- 代码文件

  这里特指除了 HTML 外的代码文件，因为 HTML 文件一般不缓存或者缓存时间很短。

  一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 `Cache-Control: max-age=31536000`，这样只有当 HTML 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存。



## 前端监控一般分为哪几种？

前端监控一般分为三种，分别为页面埋点、性能监控以及异常监控。



### 前端错误的分类

- 即时运行错误：代码错误
- 资源加载错误



### 错误的捕获方式

- 即时运行错误：代码错误
  - try..catch
  - window.onerror
- 资源加载错误
  - object.onerror
  - performance.getEntries()
  - Error 事件**捕获**



### 跨域的 js 运行错误可以捕获吗？错误提示什么？应该怎么处理

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/jskuayu.png)

1. 在 script 标签增加`crossorigin`属性 `<script src="..." crossorigin ></script>`
1. 设置 js 资源响应头 Access-Control-Allow-Origin:\*



### 上报错误的基本原理

1. 采用 Ajax 通信的方式上报
1. 利用 Image 对象上报

```javascript
new Image().src = "http://baidu.com/tesjk?r=tksjk";
```





## 能介绍一下你对浏览器内核的理解吗？

主要分成两部分：渲染引擎(`layout engineer或Rendering Engine`)和 JS 引擎

- 渲染引擎：

负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。

浏览器的内核的不同对于网页的语法解释会有不同，渲染的效果也会不相同。

- JS 引擎：

解析和执行 javascript 来实现网页的动态效果



## 前端需要注意哪些 SEO?

- 合理的`title`、`keywords` 。`title` 值强调重点即可，不同页面 title 要有所不同，重要关键词出现不要超过 2 次，而且要靠前
- **语义化**的 HTML 代码，符合 W3C 规范，让搜索引擎容易理解网页
- 重要内容 HTML 代码**放在最前**：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
- 重要内容**不要用 js 输出**， 爬虫不会执行 js 获取内容
- **少用**`iframe`，搜索引擎不会抓取 `iframe` 中的内容
- **非装饰性图片**必须加`alt`
- 提高**网站速度**：网站速度是搜索引擎排序的一个重要指标



## WEB 标准以及 W3C 标准是什么?

1. 标签闭合
1. 标签小写
1. 不乱嵌套
1. 使用外链 css 和 js
1. 结构行为表现的分离



## 谈谈你对语义化的理解？

- 用**正确**的标签做正确的事情！
- 语义化就是让页面的**内容结构化**，便于对浏览器、搜索引擎解析。
- 在没有样式 CSS 情况下也以一种**文档格式显**示，并且是容易阅读的。
- **搜索引擎**的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。
- **源代码**更容易阅读、维护、理解。



## xhtml 和 html

- 一个是功能上的差别
  - 主要是 XHTML 可兼容各大浏览器、手机以及 PDA，并且浏览器也能快速正确地编译网页
- 另外是书写习惯的差别
  - XHTML 元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素



## HTML 全局属性(global attribute)有哪些？

- `id`: 元素 id，文档内唯一
- `class`: 为元素设置类标识
- `style`: 行内 css 样式
- `title`: 元素相关的建议信息
- `lang`: 元素内容的的语言
- `data-*`: 为元素增加自定义属性
- `draggable`: 设置元素是否可拖拽



## 什么是 DOCTYPE 及作用？

```html
<!DOCTYPE html>
```

- DOCTYPE: 是用来声明文档类型和 DTD 规范的
- DTD: 定义文档类型，浏览器会根据它来决定用哪种协议来解析以及切换浏览器模式。

HTML4.0 有传统模式和严格模式。

传统模式包含所有 HTML 元素和属性，包括展示性和弃用的元素。（如 `font`）

严格模式包含所有 HTML 元素和属性，但不包括展示性和弃用的元素。（如 `font`）



## HTML5 为什么只需要写 <!DOCTYPE html>？

- HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要`DOCTYPE`来规范浏览器的行为
- 而 HTML4.01 基于 SGML，所以需要对 DTD 进行引用，才能告知浏览器所使用的文档类型



## html5 有哪些新特性？

HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加

- 绘画 `canvas`
- 用于媒介回放的 `video` 和 `audio` 元素
- 本地离线存储 `localStorage` ,`sessionStorage`
- 语意化更好的内容元素，比如`article`、`footer`、`header`、`nav`、`section`
- 表单控件，`date`、`time`、`email`、`url`、`search`
- 新的技术`webworker`, `websocket`



## html5 有移除的元素?

- 纯表现的元素：`basefont`，`font`, `big`，`center`，`s`
- 对可用性产生负面影响的元素：`frame`



## Canvas 和 SVG 有什么区别？

- `svg`输出的图形是**矢量图形**，它绘制出来的每一个图形元素都是独立的 DOM 节点，能够方便的绑定事件或用来修改。,也可以修改参数来自由放大缩小，不会**失真和有锯齿**。
- 而`canvas`输出**标量画布**，就像一张图片一样，放大会失真或者锯齿



## 



## 解释一下 CSS 里的两个单位：em 和 rem，你一般怎么使用它们？

1em，等于本元素的字体大小，所以在不同的元素里 1em 的绝对大小是不一样的。

而 1rem，等于根元素的字体大小，在一个页面中，无论在哪个元素上 1rem 都是一样的。

em 适合于用在需要大小需要跟随字体变化的属性上，比如 padding、margin、height、width 等等，元素继承了不同的字体大小，这些属性最好也能跟着变化；

大多数人可能会认为 em 相对于父元素的字体大小，但是实际上取决于应用在什么 CSS 属性上。对于 font-size 来说，em 相对于父元素的字体大小；`line-height` 中，em 却相对于自身字体的大小。

rem 适用于字体，这样就可以通过改变根元素的字体大小来改变整个页面的字体大小。



## px， em， rem 的区别？

- px 是绝对长度单位。像素 px 是根据显示器屏幕分辨率显示的。
- em 是相对长度单位。相对于当前对象内文本的字体尺寸;（参考物是父元素的 font-size）。如当前父元素的字体尺寸未设置，则相对于浏览器的默认字体尺寸
- rem 是相对于 HTML 根元素的字体大小（font-size）来计算的长度单位。



## % 相对于谁

```css
.wp {
  position: relative;
}
.box {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```

- 第一处 50% 是指 .wrap 相对定位元素宽度和高度的 50%，而 `transform` 中的 50% 是指自身元素的宽高的一半。
- 对于设置绝对定位 `position absolute` 的元素，我们可以使用 `left` `right` 表示其偏移量，我们把这个元素的祖先元素中第一个存在定位属性的元素成为参照物元素，其中的 % 是相对于参照物的，`left` 相对于参照物的 `width`，`top` 相对于这个参照物的 `height`。
- 对于设置相对定位 `position relative` 的元素，% 的数值是相对与自身的，left 相对于自己的 width，top 相对于自己的 height。
- 对于设置固定定位 `position fixed` 的元素，% 的数值是相对于视口的，left 相对于视口的 width，top 相对于视口的 height。
- `margin` 和 `padding` 当中的 % 非常特殊，它是相对于父元素的宽度。没错，`margin-top: 30%`，相当于父元素宽度的 30%。
- `font-size` 的 %相对于父元素的字体大小。
- `line-height` 设置行高时，如果单位为 %，则相对于该元素的 `font-size` 数值。
- `text-indent` 这个属性可以设置首行缩进，当使用 % 时，它是相对于父元素的 `width`。
- `border-radius: 50%`得到一个圆形，因此不难发现这里的 % 也是相对于自身宽高的。
- `background-size` 的百分比和 `border-radius` 一样，也是相对于自身的宽高。
- `transform` 的 `translate` 属性 % 是相对于自身的宽高，这也是我们上述代码能够实现居中的原因。



## 什么是 flex？写出常见属性，以及作用？

flex：弹性布局。

常见属性及作用：

- flex-direction 属性决定主轴的方向（即项目的排列方向）。
- justify-content 属性定义了项目在主轴上的对齐方式。
- align-items 属性定义项目在交叉轴上如何对齐。
- align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

项目属性：

- order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。
- flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。
- align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。



## display 有哪些值？说明他们的作用？

- none：   元素不会被显示
- block： 此元素将显示为块级元素，此元素前后会带有换行符。
- inline： 默认。此元素会被显示为内联元素，元素前后没有换行符。
- inline-block： 像行内元素一样显示，但其内容像块类型元素一样显示。可以设置宽高，可以设置 margin 和 padding。
- flex： 弹性盒子布局
- inline-flex：内联的弹性盒子布局
- table： 此元素会作为块级表格来显示（类似 `<table>`），表格前后带有换行符。
- inline-table： 此元素会作为内联表格来显示（类似 `<table>`），表格前后没有换行符。
- table-row： 此元素会作为一个表格行显示（类似 `<tr>`）。
- table-cell：此元素会作为一个表格单元格显示（类似 `<td>` 和 `<th>`）
- grid： 网格布局
- inherit 规定应该从父元素继承 display 属性的值。



## 隐藏一个元素有多少种方法？

1. `display:none;`
1. `opacity:0;`
1. `visibility：hidden;`
1. `position:absolute;clip(0,0,0,0);`
1. `overflow:hidden;`
1. `width: 0px;height: 0px;`



## `display: none` 与 `visibility: hidden`区别在哪？

联系：它们都能让元素不可见

区别：

1. `display:none`会让元素完全从渲染树中消失，渲染的时候**不占据任何空间**；`visibility: hidden`不会让元素从渲染树消失，渲染元素**继续占据空间**，只是内容不可见
1. `display: none`是**非继承属性**，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；`visibility: hidden`**是继承属性**，子孙节点消失由于继承了 hidden，通过设置`visibility: visible`可以让子孙节点显示
1. 修改常规流中元素的`display`通常会造成文档**回流**。修改`visibility`属性只会造成本元素的**重绘**。
1. **读屏器**不会读取`display: none`元素内容；会读取`visibility: hidden`元素内容



## 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？

- 标准模型`width`不计算`padding`和`border`
- IE 模型`width`计算`padding`和`border`。

`box-sizing` : `content-box`(标准模型-默认)/`border-box`(IE 模型)



## js 中如何获取盒模型宽高?

1.  `dom.style.width`（只能取内联宽高)
1.  `dom.currentStyle.width` (浏览器渲染之后的取值，只有 IE 支持)
1.  `window.getComputedStyle(dom).width` (浏览器渲染之后的取值，兼容性更好)
1.  `dom.getBoundingClientRect().width/height/left/top` (常用于计算位置)



## 什么是 BFC?(概念)

块级格式化上下文



## 对 BFC 规范的理解？

它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用



## BFC 的原理？

1.  同一 BFC 内块级元素之间的垂直方向边距会发生重叠。
1.  浮动元素区域不会与 BFC 重叠
1.  BFC 在页面上是一个独立的容器，外面的元素不会影响里面的元素，里面的元素也不会影响外面的元素
1.  计算 BFC 高度时，浮动元素也会参与计算



## 如何创建 BFC？

- `<html>` 根元素。
- `float` 的值不为 `none` 。
- `overflow`为 `auto`、` scroll`、`hidden`
- `position` 为 `absolute` 或 `fixed`
- `display` 为 `inline-block`、`table-cell`、`table-caption` 、`flex`、`inline-flex`中的任何一个



## BFC 使用场景?

1.  解决垂直方向的边距重叠
1.  清除浮动



## 行内元素`float:left`后是否变为块级元素？

浮动后，行内元素不会成为块状元素，但是可以设置宽高。行内元素要想变成块状元素，占一行，直接设置`display:block`。但如果元素设置了浮动后再设置`display:block`那就不会占一行



## 为什么要清除浮动？

不清除浮动会发生高度塌陷：

父元素不写高度时，子元素写了浮动后，父元素会发生高度塌陷。



## 清除浮动有几种方式？

1.  添加空 div，在浮动元素下方添加空 div，并给该元素写 CSS 样式`clear:both`

- 优点： 简单，代码少，浏览器支持好，不容易出现怪问题
- 缺点： 页面浮动布局多，就要增加很多空 div

2.  父级设置高度

- 优点：简单，代码少
- 缺点： 只适合高度固定的布局

3.  父级同时浮动（需要给父级同级元素添加浮动）

- 优点： 无
- 缺点： 产生新的浮动问题

4.  给父级添加`overflow:hidden` 清除浮动方法

- 优点： 简单，代码少，浏览器支持好
- 缺点： 不能和 position 配合使用，因为超出的尺寸的会被隐藏

5.  父级元素定义 after 伪类 （现在主流方法，推荐使用）

- 优点： 浏览器支持好，不容易出现怪问题
- 缺点： 代码多

```css
.fix:after {
  content: "";
  display: table;
  clear: both;
}
//兼容ie6,7
.fix {
  *zoom: 1;
}
```



## 重绘（Repaint）和回流（Reflow）

重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。



### 重绘与回流

- 重绘(Repaint)是当节点需要更改外观而不会影响布局的，比如改变 `color` 就叫称为重绘
- 回流(Reflow)是布局或者几何属性需要改变就称为回流。

回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

**以下几个动作可能会导致性能问题：**

- 改变 `window` 大小
- 改变字体
- 添加或删除样式
- 文字改变
- 定位或者浮动
- 盒模型

并且很多人不知道的是，重绘和回流其实也和 Eventloop 有关。

1. 当 Eventloop 执行完 Microtasks（微任务） 后，会判断 `document` 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次。
1. 然后判断是否有 `resize` 或者 `scroll` 事件，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 16ms 才会触发一次，并且自带节流功能。
1. 判断是否触发了 media query(媒体查询)
1. 更新动画并且发送事件
1. 判断是否有全屏操作事件
1. 执行 `requestAnimationFrame` 回调
1. 执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
1. 更新界面
1. 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 `requestIdleCallback` 回调。

以上内容来自于 [HTML 文档](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)。



### 减少 重绘与回流

1. 使用 `transform` 替代 `top`
1. 使用 `visibility` 替换 `display: none` (前者只会引起重绘，后者会引发回流)
1. 不要把节点的属性值放在一个循环里当成循环里的变量

```javascript
for (let i = 0; i < 1000; i++) {
  // 获取 offsetTop 会导致回流，因为需要去获取正确的值
  console.log(document.querySelector(".test").style.offsetTop);
}
```

4. 不要使用 `table` 布局，可能很小的一个小改动会造成整个 `table` 的重新布局
5. 动画实现的速度的选择，动画速度越快，回流次数越多，可以选择使用 `requestAnimationFrame`
6. CSS 选择符**从右往左**匹配查找，避免节点层级过多
7. 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 `video` 标签来说，浏览器会自动将该节点变为图层;<br />以下常用属性可以生成新图层:
   - `will-change`
   - `video、iframe` 标签
8. 不要重复添加 DOM， 如果有多个操作合并在一起添加到页面



## 什么是 FOUC?如何避免?

`Flash Of Unstyled Content`：用户定义样式表加载之前浏览器使用默认样式显示文档，CSS 样式加载后再次渲染文档，造成页面闪烁。

解决方法：把样式表放到文档的 head



## css sprite 是什么,有什么优缺点

概念：将多个小图片拼接到一个图片中。通过`background-position`和元素尺寸调节显示需要的背景图案。

优点：

- 减少 HTTP 请求数，提高页面加载速度
- 减少图片大小
- 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现

缺点：

- 图片合并麻烦
- 维护麻烦，修改一个图片可能需要从新布局整个图片，样式



## CSS3 有哪些新特性

- 新增各种 CSS 选择器
- 边框圆角 `border-radius`
- 多列布局
- 阴影和反射
- 文字特效`text-shadow`
- 线性渐变
- 旋转`transform`
- 过渡`transition`
- 动画`animation`



## CSS3 新增伪类有那些？

```css
* p:first-of-type 选择属于其父元素的首个<p>元素的每个<p> 元素。
* p:last-of-type 选择属于其父元素的最后 <p> 元素的每个<p> 元素。
* p:only-of-type 选择属于其父元素唯一的 <p>元素的每个 <p> 元素。
* p:only-child 选择属于其父元素的唯一子元素的每个 <p> 元素。
* p:nth-child(2) 选择属于其父元素的第二个子元素的每个 <p> 元素。
* :before 在元素之前添加内容
* :after 在元素之后添加内容,也可以用来做清除浮动。
* :enabled 选择器匹配每个启用的的元素（主要用于表单元素）。
* :disabled 控制表单控件的禁用状态。
* :checked 单选框或复选框被选中
```



## 如何用 css 实现一行文字后面...的情况?

```css
overflow: hidden; //超出隐藏
white-space: nowrap; //不允许换行
text-overflow: ellipsis; //超出部分用...代替
//多行的情况请添加如下设置
display: -webkit-box;
-webkit-line-clamp: 1; //多行情况下可以设置哪一行多余部分用...代替。这里设置的是第一行
-webkit-box-orient: vertical;
```



## css3 如何实现 0.5px 的细线?

```css
.line {
  position: relative;
}
.line:after {
  content: "";
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 1px;
  background-color: #000000;
  -webkit-transform: scaleY(0.5);
  transform: scaleY(0.5); //在Y轴缩小一半
}
```

```html
<div class="line"></div>
```



## css 如何实现三角形?

```css
span {
  border-top: 40px solid transparent;
  border-left: 40px solid transparent;
  border-right: 40px solid transparent;
  border-bottom: 40px solid #ff0000;
}
```



## 宽高已知，如何实现 div 水平垂直居中?



#### 第一种方案

```css
.box {
  width: 400px;
  height: 200px;
  position: relative;
  background: red;
}
.content {
  width: 200px;
  height: 100px;
  position: absolute;
  top: 50%;
  left: 50%;
  margin-left: -100px;
  margin-top: -50px;
  background: green;
}
```



#### 第二种方案

```css
.box {
  height: 200px;
  position: relative;
  background: red;
}
.box div {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100px;
  height: 100px;
  margin: auto;
  background: green;
}
```

```html
<div class="box">
  <div class="content">水平垂直居中</div>
</div>
```



## 宽高未知，如何实现 div 水平垂直居中?



#### 第一种方案

```css
.box {
  width: 400px;
  height: 200px;
  position: relative;
  background: red;
}
.content {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: green;
}
```



#### flex 解决方案:

```css
.box {
  width: 400px;
  height: 200px;
  background: red;
  display: flex;
  justify-content: center;
  align-items: center;
}
.content {
  width: 200px;
  height: 100px;
  background: green;
}
```



## 假设高度已知，请写出三栏布局(圣杯布局)，其中左栏、右栏宽度各为 100px，中间自适应

以下布局如果条件是高度未知,依然适用的布局有 flex, table 布局。

- 浮动:
  - 缺点：脱离文档流，需清除浮动。处理不好会带来很多问题。
  - 优点：兼容性好。

```css
<style>
    .box1 div{
      min-height: 50px;
    }
    .box1 .left{
        float: left;
        width: 100px;
        background: red;
    }
    .box1 .right{
        float: right;
        width: 100px;
        background: green;
    }
    .box1 .center{
        background: yellow;
        margin: 0 100px;
    }
</style>
<section class="box1">
    <div class="left"></div>
    <div class="right"></div>
    <div class="center">浮动自适应部分</div>
</section>
```

- 绝对定位:
  - 缺点：绝对定位脱离文档流，导致了其子元素都脱离了文档流，可使用性很差。
  - 优点：快捷！

```css
<style>
    .box2{
        min-height: 50px;
    }
    .box2 div{
        position: absolute;
        min-height: 50px;
    }
    .box2 .left{
        width: 100px;
        left: 0;
        background: red;
    }
    .box2 .center{
        left: 100px;
        right: 100px;
        background: yellow;
    }
    .box2 .right{
        right: 0;
        width: 100px;
        background: green;
    }
</style>
<section class="box2">
    <div class="left"> </div>
    <div class="center">绝对定位自适应部分</div>
    <div class="right"></div>
</section>
```

- flex:
  - 缺点：只兼容到 ie9。
  - 优点：比较完美的方案。

```css
<style>
    .box3{
        display: flex;
        min-height: 50px;
    }
    .box3 .left{
        width: 100px;
        background: red;
    }
    .box3 .center{
        flex: 1;
        background: yellow;
    }
    .box3 .right{
        width: 100px;
        background: green;
    }

</style>
<section class="box3">
    <div class="left"></div>
    <div class="center">flex自适应部分</div>
    <div class="right"></div>
</section>
```

- 表格:
  - 缺点：多栏布局时，某个单元格高度超出，会使其他单元格高度一起增加。操作繁琐，SEO 不友好。
  - 优点：兼容性好，兼容 ie8。

```css
<style>
    .box4 {
        display: table;
        width: 100%;
        min-height: 50px;
    }
    .box4 div{
        display: table-cell;
    }
    .box4 .left{
        width: 100px;
        min-height: 50px;
        background: red;
    }
    .box4 .center{
        min-height: 50px;
        background: yellow;
    }
    .box4 .right{
        width: 100px;
        min-height: 50px;
        background: green;
    }
</style>
<section class="box4">
    <div class="left"></div>
    <div class="center">表格自适应部分</div>
    <div class="right"></div>
</section>
```

- 网格布局:
  - 优点:新技术，代码量少
  - 缺点:兼容性不好， 不兼容 IE

```css
<style>
    .box5{
        display: grid;
        width: 100%;
        grid-template-rows:50px;
        grid-template-columns:100px auto  100px;
    }
    .box5 .left{
        background: red;
    }
    .box5 .center{
        background: yellow;
    }
    .box5 .right{
        background: green;
    }
</style>
<section class="box5">
    <div class="left"></div>
    <div class="center">网格自适应部分</div>
    <div class="right"></div>
</section>
```



## 如何实现下图九宫格的效果?鼠标滑过边框显示红色?

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/jiugongge.png)

## 



## 说几条写 JavaScript 的基本规范？

- 不要在同一行声明多个变量
- 请使用`===/!==`来比较`true/false`或者数值
- 使用对象字面量替代`new Array`这种形式
- 不要使用全局函数
- `Switch`语句必须带有`default`分支
- `If`语句必须使用大括号
- `for-in`循环中的变量 应该使用`let`关键字明确限定作用域，从而避免作用域污染



## W3C 对 JS 的规定有哪些?

- DOM
- BOM
- 事件绑定
- ajax 请求(包括 http 协议)
- 存储



## 原始类型有哪些？

字符串（`String`）、数值（`Number`）、布尔值（`Boolean`）、`Undefined`、`Null`、 `symbol`

占用空间固定，保存在栈中，存储的是值。

原始类型存储的是值，是没有函数可以调用的。之所以 `'1'.toString()` 可以被调用，是因为它做了一层封装。被强制转换成了 `String` 类型，也就是对象类型,   所以可以调用`toString`函数。

`string` 类型是不可变的，无论你在 `string` 类型上调用何种方法，都不会对值有改变。



## 对象类型有哪些？

对象（`Object`）、数组（`Array`）、函数（`Function`）

占用空间不固定，地址存在栈内存，值保存在堆中, 复制的是地址, 指向同一块内存空间。 使用 `instanceof` 检测数据类型



## 为什么值类型赋值是直接赋值， 而引用类型是直接赋值一个内存地址？

主要考虑到性能/存储问题，因为值类型占用空间比较少。它可以直接赋值， 不会对性能造成太大影响。而一般来说， 引用类型存储的空间占用较大，不好管理。如果我们直接复制会导致复制过程非常慢。所以说， 计算机所有的程序，所有的代码，所有的语言，都是采用这种方式。



## 原始类型和对象类型区别?

1. 原始类型存储的是值,保留在栈内存(空间固定)，相等都要重新创建一份
1. 对象类型存储的是指针，保留在堆内存(空间不固定)，相等时引用的是同一份指针



## typeof 都能识别哪些类型？

- 识别除了`null`之外的所有值类型
- 识别函数
- 判断是否是引用类型（不可再细分）



## 类数组和数组的区别是什么？

类数组: 拥有 length 属性，不具有数组所具有的方法。



## 类数组如何转换为数组？

```javascript
//第一种方法
Array.prototype.slice.call(arrayLike);
//第二种方法
[...arrayLike];
//第三种方法:
Array.from(arrayLike);
```



## JS 内置函数是什么?

内置函数: `Object`, `Array` , `Function` , `Boolean` , `Number` , `String` , `Date` , `RegExp` , `Error` , `Json` .

作用: 作为构造器函数



## 函数参数是对象会发生什么?

函数参数是对象指针的副本，当参数重新分配对象时，参数的指针会发生变化。两个变量的值也会不相同



## null 和 undefined 的区别是什么?

- `null`表示空对象指针
  - 如果定义的变量准备用来保存对象，那么最好初始化为`null`
- `undefined`表示未赋值的变量
- 在使用`==`会发生类型转换.导致相等



## null 是对象嘛？

null 并不是对象类型 。虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。



## instanceof 的原理:

沿着原型链一层一层向上找, 看是否能找到对应的`prototype`



## 自己实现一个 instanceof

```javascript
function myInstanceof(left, right) {
  let prototype = right.prototype;
  left = left.__proto__;
  while (true) {
    if (left === null || left === undefined) return false;
    if (prototype === left) return true;
    left = left.__proto__;
  }
}
```



## 怎么实现浅拷贝？

浅拷贝是指只拷贝所有属性到新对象,如果属性值是对象,只拷贝地址.

浅拷贝通过`object.assign()`,扩展运算符`...`来解决

```javascript
var newObj = Object.assign({}, obj);
var newObj = { ...obj };
```



## 怎么实现深拷贝？

- 通过 JSON.parse(JSON.stringify(object)) 来解决

```javascript
var newObj = JSON.parse(JSON.stringify(obj));
```

但是：会忽略 `undefined`、 `symbol`、不能序列化函数、不能解决循环引用的对象



## 哪些情况下会发生类型转换?

- ==
- 逻辑运算符
- if
- 字符串拼接

首先我们要知道，在 JS 中类型转换只有三种情况，分别是：

- 转换为布尔值
- 转换为数字
- 转换为字符串

**类型转换表格**

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/boolean.png)



### 转 Boolean

在条件判断时，除了 `undefined`，`null`， `false`，`NaN`， `''`， `0`， `-0`，其他所有值都转为 `true`，包括所有对象。



## JavaScript 中如何进行隐式类型转换？

首先要介绍 `ToPrimitive` 方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：

```javascript
/**
 * @obj 需要转换的对象
 * @type 期望的结果类型
 */
ToPrimitive(obj, type);
```



#### `type` 的值为 `number` 或者 `string`。

当 `type` 为 `number` 时规则如下：

1. 调用 `obj` 的 `valueOf` 方法，如果为原始值，则返回，否则下一步；
1. 调用 `obj` 的 `toString` 方法，后续同上；
1. 抛出 `TypeError` 异常



#### 当 `type` 为 `string` 时规则如下：

1. 调用 `obj` 的 `toString` 方法，如果为原始值，则返回，否则下一步；
1. 调用 `obj` 的 `valueOf` 方法，后续同上；
1. 抛出 `TypeError` 异常。

可以看出两者的主要区别在于调用 `toString` 和 `valueOf` 的先后顺序。默认情况下：

1. 如果对象为 `Date` 对象，则 `type` 默认为 `string`；
1. 其他情况下，`type` 默认为 `number`。

而 JavaScript 中的隐式类型转换主要发生在 `+、-、*、/` 以及 `==、>、<` 这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用 `ToPrimitive` 转换成基本类型，再进行操作。



### 四则运算符

加法运算符不同于其他几个运算符，它有以下几个特点：

- 运算中其中一方为字符串，那么就会把另一方也转换为字符串
- 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

```javascript
1 + "1"; // '11'
true + true; // 2
4 + [1, 2, 3]; // "41,2,3"
```

如果你对于答案有疑问的话，请看解析：

- 对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 '11'
- 对于第二行代码来说，触发特点二，所以将 true 转为数字 1
- 对于第三行代码来说，触发特点二，所以将数组通过 toString 转为字符串 1,2,3，得到结果 41,2,3

另外对于加法还需要注意这个表达式 'a' + + 'b'

`'a' + + 'b' // -> "aNaN"`

因为`+ 'b'` 等于 `NaN`，所以结果为 `"aNaN"`，你可能也会在一些代码中看到过 `+ '1'` 的形式来快速获取 number 类型。

除了加法运算，只要其中一方为数字，另一方必定转为数字。

```javascript
4 * "3"; // 12
4 * []; // 0
4 * [1, 2]; // NaN
```



### 比较运算符

1. 如果是对象，就通过 toPrimitive 转换对象
1. 如果是字符串，就通过 unicode 字符索引来比较

```javascript
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return "1";
  },
};
a > -1; // true
```

在以上代码中，因为`a`是对象，所以会通过 `valueOf` 转换为原始类型再比较值。



## == 和 === 有什么区别？

首先使用 `==` 是会发生隐式类型转换的。 一般只有判断一个变量是不是`null`和`undefined`时会使用`==`。其它地方一律用`===`。

`==`运算流程图

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/yuansuanliuchengtu.png)



## 怎么理解 json?

是内置的 js 对象,也是一种数据格式

它有两个方法:

```javascript
JSON.stringify({ a: 10, b: 11 }); //把对象变成字符串

JSON.parse("{a:10,b:11}"); //把字符串变成对象
```



## XML 与 JSON 的区别?

JSON 数据体积小 , 传递快 , 与 JavaScript 交互更加方便 , 容易解析 。

但是数据描述性差 , 不如 XML



## DOM 的本质?

> DOM: Document Object Model 文档对象模型。
>
> HTML 代码就是一个字符串，但是浏览器已经把字符串结构化成树形结构了。

DOM 本质就是浏览器拿到 HTML 代码后，DOM 把 HTML 代码结构化成浏览器及 JS 可识别的模型 。



## DOM 是哪种数据结构?

它是从 HTML 文件解译出来的一棵 DOM **树形结构**。



## DOM 结构操作有哪些？

- 新增节点 `document.createElement(node)`
- 获取父元素 `childNode.parentElement`
- 获取子元素 `parentNode.childNodes`
- 删除节点 `parentNode.removeChild(childNode)`



## childNodes 和 children 的区别?

`childNodes` 属性返回所有的节点，包括文本节点、注释节点；

`children` 属性只返回元素节点；



## Attribute 和 property 有何区别?

- `attribute` (自定义)属性在 HTML 上设置修改， 会直接反应到 HTML 上， 两者同步。
- `porperty` (固有)属性可以看做是 DOM 对象的键值对， 用点操作符对他们进行操作。 实际编程中， 基本的 DOM 操作都是使用 `peoperty` 的点操作符。
- 对于 HTML 的标准属性来说，`attribute`和`property`是同步的，是会自动更新的
- 对于自定义的属性来说，它们是不同步的



## offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别?

- `offsetWidth/offsetHeight`返回值包含`content` + `padding` + `border`
- `clientWidth/clientHeight`返回值只包含`content` + `padding`
- `scrollWidth/scrollHeight`返回值包含`content`+ `padding` + 溢出内容的尺寸



## 作用域是什么？

**一个函数的父级作用域是在它定义的时候的作用域，而非它执行时候的作用域。**

作用域其实就是代表了一个变量合法的使用范围。如果超出了范围就会报错。

作用域分为局部作用域和全局作用域，处在局部作用域里面可以访问到全局作用域的变量，而在局部作用域外面就访问不到局部作用域里面所声明的变量。

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/zuoyongyu.png)



## 作用域链是什么?

在局部作用域访问变量 , 如果访问不到 , 自由变量会一直向父级作用域寻找，这样的链条称之为作用域链。



## 自由变量是什么？

- 一个变量在当前作用域没有定义， 但被使用了。
- 向上级作用域， 一层一层依次寻找， 直到找到为止。
- 如果到全局作用域都没找到， 则报错 `xx is not defined`



## 什么是闭包呢?

闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

```javascript
function A() {
  let a = 1;
  window.B = function () {
    console.log(a);
  };
}
A();
B(); // 1
```

在 JS 中，**闭包存在的意义就是让我们可以间接访问函数内部的变量。**

两道考题：

```javascript
function create() {
  const a = 100;
  return function () {
    console.log(a);
  };
}

const fn = create();
const a = 200;
fn(); //100
```

```javascript
function print(fn) {
  const a = 200;
  fn();
}
const a = 100;
function fn() {
  console.log(a);
}
print(fn); //100
```

无论出什么样的考题， 我们都一定要记住！

**所有的自由变量的查找， 是在函数定义的地方向上级作用域查找， 而不是在执行的地方！！！**



## 闭包有哪些优点和缺点?

优点: 封装性强，使得变量始终保持在内存中。

缺点: 内存的消耗导致的性能问题（不用的闭包设置为`null`清除闭包）



## 闭包使用场景?

使用场景:

- 函数作为**返回值**
- 函数作为**参数**传递
- 可以**隐藏数据**
- **缓存**计算结果



## 循环中使用闭包解决 var 定义函数的问题?

- 闭包解决方案

```javascript
for (var i = 1; i <= 5; i++) {
  (function (j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```

- 使用 setTimeout 的第三个参数

```javascript
for (var i = 1; i <= 5; i++) {
  setTimeout(
    function timer(j) {
      console.log(j);
    },
    i * 1000,
    i
  );
}
```

- let 解决方案（推荐）

```javascript
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```



## 实际开发中闭包的应用有哪些？

- 隐藏数据， 只提供 API
- 做一个简单的 cache 工具

```javascript
//闭包隐藏数据，只提供API
function createCache() {
  const data = {}; //闭包中的数据被隐藏， 不被外界访问
  return {
    set: function (key, val) {
      data[key] = val;
    },
    get: function (key) {
      return data[key];
    },
  };
}

const c = createCache();
c.set("a", 100);
console.log(c.get("a")); //100
```



## 内存泄漏

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/neicunxielou.png)

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/neicunxielou2.png)

## this 全解析

> this 取值是在执行的时候确认的， 而不是在定义的时候。



## this 有哪几种调用方式？

- 作为普通函数
- 作为 `call, apply, bind`
- 作为对象方法调用
- 在 class 方法中调用
- 箭头函数



## this 有哪些使用场景?

1. 作为对象属性执行
1. 作为构造函数执行
1. 作为普通函数执行
1. `call apply bind`



## this 指向如何判断?

- 函数直接调用指向`window`
- 对象调用,`this`指向调用的对象
- `new`方式直接指向它的实例对象
- 箭头函数无`this`,取决于上下文的`this`
- `bind`的`this`永远指向第一次指定的对象



## this 优先级

1. `new`优先级最高
1. `bind`次之
1. 然后是`obj.foo()`对象调用
1. 最后是`foo（）`直接调用，同时箭头函数 `this`一旦绑定，不会再改变



## 以下代码 this 指向谁？

```javascript
<div class="table" onclick="callback()"></div>;

function callback() {
  console.log(this);
}
```

这个调用场景适用于将函数用作独立函数调用，`callback` 中的 `this` 在非严格模式下指向 `windows`，严格模式下指向`undefined`。

如果想要打印当前元素,需要在调用 `callback(this)` 时添加上 `this` 参数。



## 写出打印结果，并解释为什么？

1. 

```javascript
let length = 10;
function fn() {
  console.log(this.length);
}
var obj = {
  length: 5,
  method: function (fn) {
    fn();
    arguments[0]();
  },
};
obj.method(fn, "l");
```

第一次打印 1， 此时 `this` 指向 `window` , `window.length` 指的是 `frame` `iframe`的窗口数量。

第二次打印 2， 此时 `this` 指向 `arguments` 对象。 此时 `arguments` 参数长度是 2。

2. 

```javascript
const o1 = {
  text: "o1",
  fn: function () {
    return this.text;
  },
};
const o2 = {
  text: "o2",
  fn: function () {
    return o1.fn();
  },
};
const o3 = {
  text: "o3",
  fn: function () {
    var fn = o1.fn;
    return fn();
  },
};

console.log(o1.fn());
console.log(o2.fn());
console.log(o3.fn());
```

答案是：o1、o1、undefined

3.

```javascript
function Foo() {
  this.user = "Lucas";
  return 1;
}
const instance = new Foo();
console.log(instance.user);
```

将会输出 Lucas，也就是说此时 instance 是返回的目标对象实例 this。<br />结论：如果构造函数中显式返回一个值，且返回的是一个对象，那么 this 就指向这个返回的对象；如果返回的不是一个对象，那么 this 仍然指向实例。



## 原型与原型链的理解,它们有什么特点?

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/yuanxinglian.png)

**原型:**

每个函数都有一个`prototype`属性, 这个属性指向的就是原型。 每一个实例对象都有一个 `__proto__` （隐式原型）,它指向的就是构造函数的原型。

**原型链:**

- 当调用一个对象的属性时 , 如果自身对象未找到 , 会去对象的`__proto__`属性(隐式原型对象)里去找 。
- 然后原型本身也是一个对象 , 拥有`__proto__` 属性 , 所以会继续向上查找 。
- 一直找到`Object.prototype.proto===null`， 这样的链条称之为原型链。

**原型链的特点:**

原型对象上的方法是被不同实例共有的 . 当我们修改原型时，与之相关的对象也会继承这一改变。



## new 的原理是什么？

- 新生成了一个对象
- 链接到原型
- 构造函数执行，绑定 `this`
- 如果构造函数返回了一个对象，那么会取代 new 出来的结果。
- 如果构造函数没有返回对象，那么返回新生成的对象。

对于对象来说，其实都是通过 `new` 产生的，无论是 `function Foo() 还是 let a = { b : 1 }`



## 通过 new 的方式创建对象和通过字面量创建有什么区别?

区别:

更推荐使用字面量的方式创建对象（无论性能上还是可读性）。

因为你使用 `new Object()` 的方式创建对象需要通过作用域链一层层找到 `Object`，但是你使用字面量的方式就没这个问题。



## 面向对象编程思想？

使用**对象**，**类**，**继承**，**封装**等基本概念来进行程序设计

## 什么是面向对象编程及面向过程编程？

- 面向过程就是分析出解决问题的步骤，然后用函数把这些步骤一步一步实现，使用的时候依次调用。
- 面向对象是以功能来划分问题，建立对象的目的不是为了完成一个步骤，而是把步骤统一封装在对象内，对外统一提供调用接口。

## 面向对象的异同和优缺点

- 优点
  - 易维护
    - 采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，维护非常方便。
  - 易扩展
  - 复用性、继承性高.

## 创建对象有几种方法?

```javascript
//字面量
var o1 = { name: "o1" };
//类的实例化
var o1 = new Object({ name: "o1" });

//构造函数
var O = function (name) {
  this.name = name;
};
var o2 = new O("o2");

//Obejct.create()
var o = { name: "o3" };
var o3 = Object.create(o);
```



## 如何声明一个类?

```javascript
function Animal(name) {
  this.name = name;
}
new Animal(); //实例化

//ES6
class Animal2 {
  constructor(name) {
    this.name = name;
  }
}
new Animal2(); //实例化
```



## 如何实现继承?继承有哪几种方式?

- 构造函数实现继承:
  - 缺点: 无法继承父类原型对象上的属性方法

```javascript
function Parent() {
  this.name = name;
}
//无法继承say方法
//Parent.prototype.say=function(){};

function Child() {
  Parent.call(this); //把父类的this指向新创建的实例
  this.type = "child";
}

console.log(new Child());
```

- 原型链继承:
  - 缺点 : 原型链上的原型对象是共用的, 原型对象某个属性发生改变， 所有的实例也会随之改变

```javascript
function Parent1() {
  this.name = "parent1";
}

function Child1() {
  this.type = "child1";
}

Child1.prototype = new Parent1();

console.log(new Child1());
```

- 组合继承:

```javascript
function Parent1() {
  this.name = "parent1";
  this.play = [1, 2, 3];
}

function Child1() {
  Parent1.call(this);
  this.type = "child1";
}
//父级的构造函数执行了两次,并把父类的constructor也继承了，浪费内存。(组合继承1)
//Child1.prototype=new Parent1();
//无法判断实例对象的直接构造函数是哪一个,此时constructor指向父类。(组合继承2)
//Child1.prototype=Parent1.prototype;
Child1.prototype = Object.create(Parent1.prototype);
Child1.prototype.constructor = Child1;
var c1 = new Child1("child1");
var c2 = new Child1("child2");
c1.play.push("4");
console.log(c1.play); //[1, 2, 3, "4"]
console.log(c2.play); // [1, 2, 3]
```

- ES6 (Class 类继承):

```javascript
class Parent {
  constructor(name) {
    this.name = name;
    this.type = ["parent"];
  }
  play() {
    console.log(this.name);
  }
}

class Child extends Parent {
  constructor(name) {
    super(name);
  }
}

var c1 = new Child("child1");
var c2 = new Child("child2");
c1.type.push("child");
console.log(c1.type); //["parent", "child"]
console.log(c2.type); //["parent"]
console.log(c1.play()); //child1
```



## 工厂模式

```javascript
class Man {
  constructor(name) {
    this.name = name;
  }
  alertName() {
    alert(this.name);
  }
}

class Factory {
  static create(name) {
    return new Man(name);
  }
}

Factory.create("yck").alertName();
```

可以想象一个场景。假设有一份很复杂的代码需要用户去调用，但是用户并不关心这些复杂的代码，只需要你提供给我一个接口去调用，用户只负责传递需要的参数，至于这些参数怎么使用，内部有什么逻辑是不关心的，只需要你最后返回我一个实例。这个构造过程就是工厂。

工厂起到的作用就是隐藏了创建实例的复杂度，只需要提供一个接口，简单清晰。

在 Vue 源码中，你也可以看到工厂模式的使用，比如创建异步组件

```javascript
export function createComponent(
  Ctor: Class<Component> | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag?: string
): VNode | Array<VNode> | void {
  // 逻辑处理...

  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ""}`,
    data,
    undefined,
    undefined,
    undefined,
    context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  );

  return vnode;
}
```

在上述代码中，我们可以看到我们只需要调用 `createComponent` 传入参数就能创建一个组件实例，但是创建这个实例是很复杂的一个过程，工厂帮助我们隐藏了这个复杂的过程，只需要一句代码调用就能实现功能。



## 单例模式

单例模式很常用，比如全局缓存、全局状态管理等等这些只需要一个对象，就可以使用单例模式。

单例模式的核心就是保证全局只有一个对象可以访问。因为 JS 是门无类的语言，所以别的语言实现单例的方式并不能套入 JS 中，我们只需要用一个变量确保实例只创建一次就行，以下是如何实现单例模式的例子

```javascript
class Singleton {
  constructor() {}
}

Singleton.getInstance = (function () {
  let instance;
  return function () {
    if (!instance) {
      instance = new Singleton();
    }
    return instance;
  };
})();

let s1 = Singleton.getInstance();
let s2 = Singleton.getInstance();
console.log(s1 === s2); // true
```

在 Vuex 源码中，你也可以看到单例模式的使用，虽然它的实现方式不大一样，通过一个外部变量来控制只安装一次 Vuex

```javascript
let Vue; // bind on install

export function install(_Vue) {
  if (Vue && _Vue === Vue) {
    // 如果发现 Vue 有值，就不重新创建实例了
    return;
  }
  Vue = _Vue;
  applyMixin(Vue);
}
```



## 发布-订阅模式

发布-订阅模式也叫做观察者模式。通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会收到通知。在现实生活中，也有很多类似场景，比如我需要在购物网站上购买一个产品，但是发现该产品目前处于缺货状态，这时候我可以点击有货通知的按钮，让网站在产品有货的时候通过短信通知我。

在实际代码中其实发布-订阅模式也很常见，比如我们点击一个按钮触发了点击事件就是使用了该模式

```javascript
<ul id="ul"></ul>
<script>
    let ul = document.querySelector('#ul')
    ul.addEventListener('click', (event) => {
        console.log(event.target);
    })
</script>
```

在 Vue 中，如何实现响应式也是使用了该模式。对于需要实现响应式的对象来说，在 `get` 的时候会进行依赖收集，当改变了对象的属性时，就会触发派发更新。



## 实现一个 Storage

实现 Storage，使得该对象为单例，基于 localStorage 进行封装。实现方法 setItem(key,value) 和 getItem(key)。

首先要记起来 getInstance 方法和 instance 这个变量是干啥的。最好能把闭包的版本也写出来！

- 实现：静态方法版

```javascript
// 定义Storage
class Storage {
  static getInstance() {
    // 判断是否已经new过1个实例
    if (!Storage.instance) {
      // 若这个唯一的实例不存在，那么先创建它
      Storage.instance = new Storage();
    }
    // 如果这个唯一的实例已经存在，则直接返回
    return Storage.instance;
  }
  getItem(key) {
    return localStorage.getItem(key);
  }
  setItem(key, value) {
    return localStorage.setItem(key, value);
  }
}

const storage1 = Storage.getInstance();
const storage2 = Storage.getInstance();

storage1.setItem("name", "李雷");
// 李雷
storage1.getItem("name");
// 也是李雷
storage2.getItem("name");

// 返回true
storage1 === storage2;
```

- 实现： 闭包版

```javascript
// 先实现一个基础的StorageBase类，把getItem和setItem方法放在它的原型链上
function StorageBase() {}
StorageBase.prototype.getItem = function (key) {
  return localStorage.getItem(key);
};
StorageBase.prototype.setItem = function (key, value) {
  return localStorage.setItem(key, value);
};

// 以闭包的形式创建一个引用自由变量的构造函数
const Storage = (function () {
  let instance = null;
  return function () {
    // 判断自由变量是否为null
    if (!instance) {
      // 如果为null则new出唯一实例
      instance = new StorageBase();
    }
    return instance;
  };
})();

// 这里其实不用 new Storage 的形式调用，直接 Storage() 也会有一样的效果
const storage1 = new Storage();
const storage2 = new Storage();

storage1.setItem("name", "李雷");
// 李雷
storage1.getItem("name");
// 也是李雷
storage2.getItem("name");

// 返回true
storage1 === storage2;
```



## 实现一个全局的模态框

实现一个全局唯一的 Modal 弹框

记住 getInstance 方法、记住 instance 变量、记住闭包和静态方法

- ES6 版本

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>单例模式弹框</title>
  </head>
  <style>
    #modal {
      height: 200px;
      width: 200px;
      line-height: 200px;
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border: 1px solid black;
      text-align: center;
    }
  </style>
  <body>
    <button id="open">打开弹框</button>
    <button id="close">关闭弹框</button>
  </body>
  <script>
    // 核心逻辑，这里采用了闭包思路来实现单例模式
    class Modal {
      constructor() {
        this.dom = null;
        if (!Modal.instance) {
          this.dom = document.createElement("div");
          this.dom.innerHTML = "我是一个全局唯一的Modal";
          this.dom.id = "modal";
          this.dom.style.display = "none";
          document.body.appendChild(this.dom);
          this.dom.showModal = this.show.bind(this);
          this.dom.hideModal = this.hide.bind(this);
          Modal.instance = this.dom;
        }
        return Modal.instance;
      }
      show() {
        this.dom.style.display = "block";
      }
      hide() {
        this.dom.style.display = "none";
      }
    }

    // 点击打开按钮展示模态框
    document.getElementById("open").addEventListener("click", function () {
      // 未点击则不创建modal实例，避免不必要的内存占用;此处不用 new Modal 的形式调用也可以，和 Storage 同理
      const modal = new Modal();
      modal.showModal();
    });

    // 点击关闭按钮隐藏模态框
    document.getElementById("close").addEventListener("click", function () {
      const modal = new Modal();
      if (modal) {
        modal.hideModal();
      }
    });
  </script>
</html>
```

- ES5 版本

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>单例模式弹框</title>
  </head>
  <style>
    #modal {
      height: 200px;
      width: 200px;
      line-height: 200px;
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border: 1px solid black;
      text-align: center;
    }
  </style>
  <body>
    <button id="open">打开弹框</button>
    <button id="close">关闭弹框</button>
  </body>
  <script>
    // 核心逻辑，这里采用了闭包思路来实现单例模式
    const Modal = (function () {
      let modal = null;
      return function () {
        if (!modal) {
          modal = document.createElement("div");
          modal.innerHTML = "我是一个全局唯一的Modal";
          modal.id = "modal";
          modal.style.display = "none";
          document.body.appendChild(modal);
        }
        return modal;
      };
    })();

    // 点击打开按钮展示模态框
    document.getElementById("open").addEventListener("click", function () {
      // 未点击则不创建modal实例，避免不必要的内存占用;此处不用 new Modal 的形式调用也可以，和 Storage 同理
      const modal = new Modal();
      modal.style.display = "block";
    });

    // 点击关闭按钮隐藏模态框
    document.getElementById("close").addEventListener("click", function () {
      const modal = new Modal();
      if (modal) {
        modal.style.display = "none";
      }
    });
  </script>
</html>
```



## 为什么要使用模块化？

- 解决命名冲突
- 提供复用性
- 提高代码可维护性

**立即执行函数**

在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题

```javascript
(function (globalVariable) {
  globalVariable.test = function () {};
  // ... 声明各种变量、函数都不会污染全局作用域
})(globalVariable);
```

**AMD 和 CMD**

```javascript
// AMD
define(["./a", "./b"], function (a, b) {
  // 加载模块完毕可以使用
  a.do();
  b.do();
});
// CMD
define(function (require, exports, module) {
  // 加载模块
  // 可以把 require 写在函数体的任意地方实现延迟加载
  var a = require("./a");
  a.doSomething();
});
```

**CommonJS**

CommonJS 最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中你就能见到它，当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了。

```javascript
// a.js
module.exports = {
  a: 1,
};
// or
exports.a = 1;

// b.js
var module = require("./a.js");
module.a; // -> log 1
```

因为 CommonJS 还是会使用到的，所以这里会对一些疑难点进行解析

先说 `require` 吧:

```javascript
var module = require("./a.js");
module.a;
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
  a: 1,
};
// module 基本实现
var module = {
  id: "xxxx", // 我总得知道怎么去找到他吧
  exports: {}, // exports 就是个空对象
};
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports;
var load = function (module) {
  // 导出的东西
  var a = 1;
  module.exports = a;
  return module.exports;
};
// 然后当我 require 的时候去找到独特的
// id，然后将要使用的东西用立即执行函数包装下，over
```

另外虽然 `exports` 和 `module.exports` 用法相似，但是不能对 `exports` 直接赋值。因为 `var exports = module.exports` 这句代码表明了 `exports` 和 `module.exports` 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 `exports` 赋值就会导致两者不再指向同一个内存地址，修改并不会对 `module.exports` 起效。

**ES Module**

ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别：

- CommonJS 支持**动态导入**，也就是 `require(\${path}/xx.js)` ，后者目前不支持，但是已有提案
- CommonJS 是**同步导入**，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是**异步导入**，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响
- CommonJS 在导出时都是**值拷贝**，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个**内存地址**，所以导入值会跟随导出值变化
- ES Module 会编译成 require/exports 来执行的

```javascript
// 引入模块 API
import XXX from "./a.js";
import { XXX } from "./a.js";
// 导出模块 API
export function a() {}
export default function () {}
```



## map, filter, reduce 各自有什么作用？

**map**

`map` 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中。

```javascript
[1, 2, 3].map((v) => v + 1); // -> [2, 3, 4]
```

另外 `map` 的回调函数接受三个参数，分别是当前索引元素，索引，原数组

```javascript
["1", "2", "3"].map(parseInt);
```

- 第一轮遍历 `parseInt('1', 0) -> 1`
- 第二轮遍历 `parseInt('2', 1) -> NaN`
- 第三轮遍历 `parseInt('3', 2) -> NaN`

**filter**

filter 的作用也是生成一个新数组，在遍历数组的时候将返回值为 true 的元素放入新数组，我们可以利用这个函数删除一些不需要的元素

```javascript
let array = [1, 2, 4, 6];
let newArray = array.filter((item) => item !== 6);
console.log(newArray); // [1, 2, 4]
```

和 `map` 一样，`filter` 的回调函数也接受三个参数，用处也相同。

**reduce**

最后我们来讲解 `reduce` 这块的内容，同时也是最难理解的一块内容。`reduce` 可以将数组中的元素通过回调函数最终转换为一个值。

```javascript
const arr = [1, 2, 3];
const sum = arr.reduce((acc, current) => acc + current, 0);
console.log(sum);
```

对于 reduce 来说，它接受两个参数，分别是回调函数和初始值，接下来我们来分解上述代码中 `reduce` 的过程

- 首先初始值为 `0`，该值会在执行第一次回调函数时作为第一个参数传入
- 回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组，后三者想必大家都可以明白作用，这里着重分析第一个参数
- 在一次执行回调函数时，当前值和初始值相加得出结果 `1`，该结果会在第二次执行回调函数时当做第一个参数传入
- 所以在第二次执行回调函数时，相加的值就分别是 `1` 和 `2`，以此类推，循环结束后得到结果 `6`



## DOM 事件级别?

- DOM0 （缺点:后定义的事件会被覆盖之前定义的事件）

```javascript
element.onclick = function () {};
```

- DOM2

```javascript
element.addEventListener("click", function () {}, false);
```

- DOM3 相较于 DOM2 增加了一些鼠标，键盘事件

```javascript
element.addEventListener("keyup", function () {}, false);
```

为什么没有 DOM1 事件呢？ 因为 DOM1 没有设计事件方面的东西。



## DOM 事件模型是什么?

捕获和冒泡

## 什么是事件流?？

一个完整的事件流分三个阶段：捕获 > 目标元素 > 冒泡

<a name="616cac2b"></a>

## 事件的触发过程是怎么样的？

事件触发过程:

从`window` 捕获 > `document` > `html`(`document.documentElement`) > `body` > ... > 目标元素 > 然后再依次冒泡到`window`

- window 往事件触发处传播，遇到注册的捕获事件会触发
- 传播到事件触发处时触发注册的事件
- 从事件触发处往 window 传播，遇到注册的冒泡事件会触发

**如果给一个 body 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。**



## Event 对象的常见应用

1.  `event.preventDefault()`：阻止默认事件；
1.  `event.stopPropagation()`：阻止冒泡事件；(其实也可以阻止捕获)
1.  `event.stoplmmediatePropagation()`：事件响应优先级 阻止相同事件类型监听函数执行。如先后定义 A,B 两个点击事件， a 使用此方法后 b 事件将不再执行。
1.  `event.currentTarget`：当前绑定事件的元素；
1.  `event.target`：当前被点击的元素；



## 怎么模拟一个事件？

```javascript
// 创建事件
let myEvent = new CustomEvent("pingan", {
  detail: { name: "wangpingan" },
});

// 添加适当的事件监听器
window.addEventListener("pingan", function (e) {
  alert(`pingan事件触发，是 ${e.detail.name} 触发。`);
});
document.getElementById("leo2").addEventListener("click", function () {
  // 派发事件
  window.dispatchEvent(myEvent);
});
```



## 怎么注册事件？

通常我们使用 `addEventListener` 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 `useCapture` 参数来说，该参数默认值为 `false` ，`useCapture` 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性

- `capture`：布尔值，和 `useCapture` 作用一样
- `once`：布尔值，值为 `true` 表示该回调只会调用一次，调用后会移除监听
- `passive`：布尔值，表示永远不会调用 `preventDefault`

一般来说，如果我们只希望事件只触发在目标上，这时候可以使用 `stopPropagation` 来阻止事件的进一步传播。通常我们认为 `stopPropagation` 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。`stopImmediatePropagation` 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。



## 知道什么是事件代理吗？

把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是 DOM 元素的事件冒泡。

如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上

```javascript
<ul id="ul">
	<li>1</li>
    <li>2</li>
	<li>3</li>
	<li>4</li>
	<li>5</li>
</ul>
<script>
	let ul = document.querySelector('#ul')
	ul.addEventListener('click', (event) => {
		console.log(event.target);
	})
</script>
```

事件代理的方式相较于直接给目标注册事件来说，有以下优点：

- 节省内存
- 不需要给子节点注销事件
- 代码简洁



## 如何理解 js 单线程?

同一时间只能干一件事



## 什么是任务队列?

有同步任务和异步任务

`seTimeout`是异步任务 , 执行到异步任务要挂起

同步任务执行完再执行异步任务



## 什么是同步(对比异步)?举个例子?

同步：浏览器向服务器请求，用户看到页面，**重新发个请求** , 请求完，页面刷新，新内容才出现。

异步：浏览器向服务器请求，用户正常操作，浏览器**后端进行请求**。请求完，页面不刷新，新内容也会出现。

同步会阻塞代码运行,异步不会

`alert`同步,`seTimeout`异步



## 什么时候需要异步?

在发生等待的情况下 , 程序仍然需要执行其他操作 , 不能阻塞程序运行



## 异步使用场景有哪些?

1.  定时任务
1.  网络请求: `ajax` , `img`加载, 脚本等文件加载和下载
1.  事件绑定



## 单线程和异步

- JS 是单线程语言， 只能同时做一件事
- JS 和 DOM 渲染共用同一个线程， 因为 JS 可修改 DOM 结构。
- 遇到等待（网络请求，定时任务）不能卡住
- 需要异步
- 回调 callback 函数形式



## 什么是执行栈？

可以把执行栈认为是一个存储函数调用的**栈结构**，遵循先进后出的原则。

当我们使用递归的时候，因为栈可存放的函数是有**限制**的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题。

## 解释一下什么是 Event Loop ？

### 事件循环执行顺序？

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/shijianxunhuan.png)

Event Loop 执行顺序如下所示：

- 首先执行同步代码，这属于宏任务
- 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行
- 执行所有微任务
- 当执行完所有微任务后，如有必要会渲染页面
- 然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数

微任务包括 process.nextTick ，promise ，MutationObserver，其中 process.nextTick 为 Node 独有。<br />宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。<br />这里很多人会有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话才会先执行微任务。



## 并发（concurrency）和并行（parallelism）区别？

这两个名词确实是很多人都常会混淆的知识点。其实混淆的原因可能只是两个名词在中文上的相似，在英文上来说完全是不同的单词。

并发是宏观概念，我分别有任务 A 和任务 B，**在一段时间内通过任务间的切换完成了这两个任务**，这种情况就可以称之为并发。

并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。**同时完成多个任务的情况就可以称之为并行**。



## 什么是回调函数？

回调函数是一段可执行的代码，它作为参数传给其他代码，方便需要的时候复用这段代码。

以下代码就是一个回调函数的例子：

```javascript
ajax(url, () => {
  // 处理逻辑
});
```

但是回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，你可能就会写出如下代码：

```javascript
ajax(url, () => {
  // 处理逻辑
  ajax(url1, () => {
    // 处理逻辑
    ajax(url2, () => {
      // 处理逻辑
    });
  });
});
```

这样写起来不利于阅读和维护。



## 回调函数有什么优缺点？

**优点:**

- 避免重复代码。

**缺点**

- 不能使用 `try catch` 捕获错误，
- 不能直接`return`。
- 容易写出回调地狱



#### 回调地狱的根本问题：

1. 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身
1. 嵌套函数一多，就很难处理错误



## 回调的特点:

- 不会立刻执行
- 是闭包
- `this` 指向是调用它的上下文，并不是回调函数的上下文
- 允许传递多个回调
- 可以嵌套



## 回调的应用场景

- 异步编程。
- 事件监听。
- `setTimeout`、`setInterval` 方法。



## 如何解决回调地狱问题？

- Promise，
- async/await



## Promise 是什么?

Promise 是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。



## Promise 的特点是什么？

`Promise` 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复。

特点: `Promise`有三种状态,一旦执行不可更改

1. 等待中（`pending`）
1. 完成了 （`resolved`）
1. 拒绝了（`rejected`）



## Promise 分别有什么优缺点？

- 优点: 解决回调地狱。
- 缺点: 无法取消 promise, 错误需要回调函数捕获



## 什么是 Promise 链？

`Promise` 每次调用 `then` 之后返回的都是一个全新的 `Promise`，如果你在 `then` 中 使用了 `return`，那么 `return` 的值会被 `Promise.resolve()` 包装。这样就实现了链式调用。



## Promise 构造函数执行和 then 函数执行有什么区别？

当我们在构造 `Promise` 的时候，构造函数内部的代码是立即执行的。

```javascript
new Promise((resolve, reject) => {
  console.log("new Promise");
  resolve("success");
});
console.log("finifsh");
// new Promise -> finifsh
Promise.resolve(1)
  .then((res) => {
    console.log(res); // => 1
    return 2; // 包装成 Promise.resolve(2)
  })
  .then((res) => {
    console.log(res); // => 2
  });
```



## async 及 await 的特点，它们的优点和缺点分别是什么？

**特点**

一个函数如果加上 `async` ，那么该函数就会返回一个 Promise

```javascript
async function test() {
  return "1";
}
console.log(test()); // -> Promise {<resolved>: "1"}
```

`async` 就是将函数返回值使用 `Promise.resolve()` 包裹了下，和 `then` 中处理返回值一样，并且 `await` 只能配套 `async` 使用

**优势：**

处理 `then` 的调用链，能够更清晰准确的写出代码，不用写一大堆 `then`。

**缺点：**

`await` 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 `await` 会导致性能上的降低。



## await 原理是什么？

`async` 函数是 Generator 函数的语法糖。使用 关键字 `async` 来表示，在函数内部使用 `await` 来表示异步。

想较于 Generator，Async 函数的改进在于下面四点：

- 内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样
- 更好的语义。`async` 和 `await` 相较于 \* 和 `yield` 更加语义化
- 更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象。而 `async` 函数的 `await` 命令后面则可以是 `Promise` 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作）
- 返回值是 Promise。`async` 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 `then()` 方法进行调用



## setTimeout、setInterval、requestAnimationFrame 各有什么特点？

异步编程当然少不了定时器了，常见的定时器函数有 `setTimeout`、`setInterval`、`requestAnimationFrame`。我们先来讲讲最常用的`setTimeout`，很多人认为 `setTimeout` 是延时多久，那就应该是多久后执行。

其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 `setTimeout` 不会按期执行。当然了，我们可以通过代码去修正 `setTimeout`，从而使定时器相对准确

```javascript
let period = 60 * 1000 * 60 * 2;
let startTime = new Date().getTime();
let count = 0;
let end = new Date().getTime() + period;
let interval = 1000;
let currentInterval = interval;

function loop() {
  count++;
  // 代码执行所消耗的时间
  let offset = new Date().getTime() - (startTime + count * interval);
  let diff = end - new Date().getTime();
  let h = Math.floor(diff / (60 * 1000 * 60));
  let hdiff = diff % (60 * 1000 * 60);
  let m = Math.floor(hdiff / (60 * 1000));
  let mdiff = hdiff % (60 * 1000);
  let s = mdiff / 1000;
  let sCeil = Math.ceil(s);
  let sFloor = Math.floor(s);
  // 得到下一次循环所消耗的时间
  currentInterval = interval - offset;
  console.log(
    "时：" + h,
    "分：" + m,
    "毫秒：" + s,
    "秒向上取整：" + sCeil,
    "代码执行时间：" + offset,
    "下次循环间隔" + currentInterval
  );

  setTimeout(loop, currentInterval);
}

setTimeout(loop, currentInterval);
```

`setInterval`，其实这个函数作用和 `setTimeout` 基本一致，只是该函数是每隔一段时间执行一次回调函数。

通常来说不建议使用 setInterval。

第一，它和 `setTimeout` 一样，不能保证在预期的时间执行任务。

第二，它存在执行累积的问题.

如果你有循环定时器的需求，其实完全可以通过 `requestAnimationFrame` 来实现

```javascript
function setInterval(callback, interval) {
  let timer;
  const now = Date.now;
  let startTime = now();
  let endTime = startTime;
  const loop = () => {
    timer = window.requestAnimationFrame(loop);
    endTime = now();
    if (endTime - startTime >= interval) {
      startTime = endTime = now();
      callback(timer);
    }
  };
  timer = window.requestAnimationFrame(loop);
  return timer;
}

let a = 0;
setInterval((timer) => {
  console.log(1);
  a++;
  if (a === 3) cancelAnimationFrame(timer);
}, 1000);
```

首先 `requestAnimationFrame` 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 setTimeout。



## 进程与线程区别？JS 单线程带来的好处？

**区别**

进程相当于一个程序，线程是更小的单位，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。

当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。

**单线程带来的好处：**

JS 运行的时候可能会阻止 UI 渲染，这说明了两个线程是互斥的。因为 JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。

得益于 JS 是单线程运行的，可以达到**节省内存，节约上下文切换时间，没有锁的问题。**

当然前面两点在服务端中更容易体现，对于锁的问题，形象的来说就是当我读取一个数字 15 的时候，同时有两个操作对数字进行了加减，这时候结果就出现了错误。解决这个问题也不难，只需要在读取的时候加锁，直到读取完毕之前都不能进行写入操作。



## 什么是提升?

js 执行时会把`var`声明，函数声明 , `argument` 提到作用域顶部。

函数声明优于`var`变量声明。

提升是为了解决函数之间相互调用的问题。

## 什么是暂时性死区?

`let`，`const`在声明前使用会报错，这个行为称之为暂时性死区。

## var,let,const 有什么区别?

1. `let`，`const`声明不会挂载在`window`上。var 声明会挂载到`window`上。
1. `let`，`const`不能重复声明, var 可以重复声明。
1. `let`，`const`不存在变量提升, var 存在变量提升。
1. `let`，`const`只在块级作用域有效。
1. `const`常量一旦声明时必须赋值 , 且不能修改 。`let` `var`是变量， 可以进行修改。



## class 本质？

- 本质是函数, js 中并不存在类，`class`只是语法糖， 使用`prototype`

## Class 与普通的构造函数有什么区别?

- 在**语法**上更贴合面向对象的写法
- 在**继承**上更容易阅读理解



## class 如何实现继承？

`class` 实现继承的核心在于使用 `extends` 表明继承自哪个父类。

子类构造函数中必须调用`super`才能传参数



## Es6 常用的方法有哪些?

- let 和 const
- 解构赋值
- 扩展运算
- promise
- 模板字符串
- 箭头函数
- class
- Reflect
- Module(模块化)
- async/await



## 箭头函数与普通函数有什么区别?

1. 语法更加简洁
1. 不会创建自己的`this`
1. call | apply | bind 无法改变箭头函数中 this 的指向
1. 不存在`arguments`对象
1. 没有原型属性
1. 不能当作构造函数，不能用作`Generator`函数 (不能使用`yield`命令)



## 为什么 0.1 + 0.2 != 0.3

先说原因，因为 JS 采用 **IEEE 754 双精度版本（64 位）**标准，并且只要采用 IEEE 754 的语言都有该问题。

JS 采用的浮点数标准却会裁剪掉我们的数字。会造成精度丢失。

解决方案：

```javascript
parseFloat((0.1 + 0.2).toFixed(10)) === 0.3; // true
```



## 请写出以下代码的打印顺序

```javascript
function Foo() {
  getName = function () {
    console.log(1);
  };
  return this;
}
Foo.getName = function () {
  console.log(2);
};
Foo.prototype.getName = function () {
  console.log(3);
};
var getName = function () {
  console.log(4);
};
function getName() {
  console.log(5);
}

Foo.getName(); //2

getName(); //4
//考察了变量提升，输出4是由于函数和var被提升到最顶部，但函数是直接把函数体全部提升，而var只是声明，未赋值。执行下来赋值时已经将函数覆盖

Foo().getName(); //1
//考察作用域：首先执行Foo()，getName由于是全局声明，重新赋值getName，Foo返回this(即window)。然后执行的就是this.getName();结果为1
getName(); //1 同上

new Foo.getName(); //2
//考察运算符优先级 .是19  new在.之后   先执行Foo.getName()在执行new
new Foo().getName(); //3
//先计算. , .把前后分割，开始执行new Foo() , 然后找getName方法
new new Foo().getName(); //3
//先计算. , .把前后分割，new.foo()带参数优先级19，new是18，执行new Foo.getName()
```



## 手写节流

考虑一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流。

```javascript
// func是用户传入需要防抖的函数
// wait是等待时间
const throttle = (func, wait = 50) => {
  // 上一次执行该函数的时间
  let lastTime = 0;
  return function (...args) {
    // 当前时间
    let now = +new Date();
    // 将当前时间和上一次执行函数时间对比
    // 如果差值大于设置的等待时间就执行函数
    if (now - lastTime > wait) {
      lastTime = now;
      func.apply(this, args);
    }
  };
};

let func = throttle(function (...args) {
  console.log("args", args);
}, 500);

setInterval(() => {
  func(1, 2, 3, 4);
}, 100);
```



## 手写防抖

有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们就可以使用防抖。

```javascript
// func是用户传入需要防抖的函数
// wait是等待时间
const debounce = (func, wait = 50) => {
  // 缓存一个定时器id
  let timer = 0;
  // 这里返回的函数是每次用户实际调用的防抖函数
  // 如果已经设定过定时器了就清空上一次的定时器
  // 开始一个新的定时器，延迟执行用户传入的方法
  return function (...args) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args);
    }, wait);
  };
};

var btn = document.getElementById("input");
btn.addEventListener(
  "click",
  debounce(function () {
    console.log("发送ajax请求");
  }),
  1000
);
```



## 创建 10 个`<a>`标签， 点击的时候弹出对应的序号

```javascript
const frag = document.createDocumentFragment();
const Max = 10;
for (let i = 0; i < Max; i++) {
  let a = document.createElement("a");
  a.innerHTML = i + "<br/>";
  a.addEventListener("click", function (e) {
    alert(e.target.innerText);
  });
  frag.appendChild(a);
}

document.body.appendChild(frag);
```



## 用 js 实现一个 99 乘法表

```javascript
for (let i = 1; i <= 9; i++) {
  document.write("<br/>");
  for (let j = 1; j <= i; j++) {
    var result = i * j;
    document.write(i + "x" + j + "=" + result + "&nbsp;&nbsp;&nbsp;");
  }
}
```



## 自己实现一个实现一个`new`操作符:

```javascript
function create() {
  let obj = {}; //创建一个空对象
  let Con = [].shift.call(arguments); //获取第一个传进来的参数，也就是构造函数
  obj.__proto__ = Con.prototype; //链接到构造函数原型
  let result = Con.apply(obj, arguments); //绑定 this 并执行构造函数
  return result instanceof Object ? result : obj; //确保返回值为对象
}
```



## 手写深拷贝

```javascript
function deepClone(obj = {}) {
    if (typeof obj !== 'object' || obj == null) {
        // obj 是 null ，或者不是对象和数组，直接返回
        return obj
    }

    // 初始化返回结果
    let result
    if (obj instanceof Array) {
        result = []
    } else {
        result = {}
    }

    for (let key in obj) {
        // 保证 key 不是原型的属性
        if (obj.hasOwnProperty(key)) {
            // 递归调用！！！
            result[key] = deepClone(obj[key])
        }
    }

    // 返回结果
    return result
}

const obj1 = {
    age: 20,
    name: 'xxx',
    address: {
        city: 'beijing'
    },
    arr: ['a', 'b', 'c']
}

const obj2 = deepClone(obj1)
obj2.address.city = 'shanghai'
obj2.arr[0] = 'a1'
console.log(obj1.address.city)
console.log(obj1.arr[0])
```



## 写一个 clone 函数,可以复制原始类型的值.

```javascript
function clone(obj) {
  var o;
  switch (typeof obj) {
    case "undefined":
      break;
    case "string":
      o = obj + "";
      break;
    case "number":
      o = obj - 0;
      break;
    case "boolean":
      o = obj;
      break;
    case "object":
      if (obj === null) {
        o = null;
      } else if (Object.prototype.toString.call(obj).slice(8, -1) === "Array") {
        o = [];
        for (var i = 0; i < obj.length; i++) {
          o.push(clone(obj[i])); //深拷贝
        }
      } else {
        o = {};
        for (var k in obj) {
          o[k] = clone(obj[k]); //深拷贝
        }
      }
      break;
    default:
      o = obj;
      break;
  }
  return o;
}

//测试
var a = [12.3];
console.log(clone(a));
```



## 以下代码如何实现点击列表显示相应的 index 值?

```javascript
<ul id="test">
    <li>1</li>
    <li>2</li>
    <li>3</li>
</ul>　　


//js
var ul = document.getElementById('test');
var lis = Array.from(ul.getElementsByTagName("li"));
ul.addEventListener("click",function(e){
console.log(lis.indexOf(e.target))
})


//使用jq:
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js"></script>
<script>
$('#test').on('click','li',function(e){
        alert($(this).index());
});
```



## 手写 call 函数

```javascript
Function.prototype.myCall = function (context) {
  if (typeof this !== "function") {
    throw new TypeError("Error"); //调用`myCall`的对象必须是函数，如果是非函数会报错
  }
  context = context || window; //如果不传参，默认为window  此时context为o
  context.fn = this; //在o对象增加fn方法，指向需要调用的函数。此时调用myCall的就是a函数，this为a，也就是说调用的方法a变成了绑定对象下的方法a
  const args = [...arguments].slice(1); //从第一个参数后面进行复制
  const result = context.fn(...args); //截取后的name，age作为参数传入了a函数，执行a函数
  delete context.fn; //删除o对象的fn属性
  return result; //返回调用函数
};

function a(name, age, sex) {
  console.log(this.name, this.age);
  console.info(name, age, sex);
}
var name = "xh",
  age = "23",
  sex = "女";
let o = {
  name: "xz",
  age: "13",
  sex: "男",
};
a(name, age); //xh 23            /xh 23 undefined  这个this是指向window
a.myCall(o, name, age); //xz 13    /xh 23 undefined   这个this执行o
```



## 手写 apply 函数

和`call`类似，区别在于处理参数，判断是否有第二个参数，如果有将作为数组传入调用函数

```javascript
Function.prototype.myApply = function (context) {
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }
  context = context || window;
  context.fn = this;
  let result;
  // 处理参数和 call 有区别
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }
  delete context.fn;
  return result;
};
```



## 手写 bind 函数

```javascript
Function.prototype.myBind = function (context) {
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }
  const _this = this;
  const args = [...arguments].slice(1);
  // 返回一个函数
  return function F() {
    // 因为返回了一个函数，可以 new F()，所以需要判断
    if (this instanceof F) {
      return new _this(...args, ...arguments);
    }
    return _this.apply(context, args.concat(...arguments));
  };
};
```



## 手写 flat()拍平数组方法

```javascript
function flat(arr) {
  const isDeep = arr.some((item) => item instanceof Array);
  if (!isDeep) {
    return arr;
  }
  const res = Array.prototype.concat.apply([], arr);
  return flat(res);
}

const res = flat([1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]]);
console.log(res);
```



## 给定一段 URL 和参数的名称，获取此参数的值

方法一：

```javascript
function getQuery(url, name) {
  let strs;
  let index = url.indexOf("?");
  if (index !== -1) {
    strs = url.slice(index + 1).split("&");
  }
  for (let k = 0; k < strs.length; k++) {
    splitItem = strs[k].split("=");
    if (splitItem[0] === name) {
      return splitItem[1];
    }
  }
}
const url = "https://www.baidu.com/s?id=123&name=why&phone=13876769797";
console.log(getQuery(url, "name")); //why
```

方法二：

```javascript
function query(name) {
  const search = location.search.substr(1);
  // search: 'a=10&b=20&c=30'
  const reg = new RegExp(`(^|&)${name}=([^&]*)(&|$)`, "i");
  const res = search.match(reg);
  if (res === null) {
    return null;
  }
  return res[2];
}
const q = query("c");
console.log(q);
```



## 写一个方法 , 去除掉重复元素...

```javascript
{
  //第一种
  let arr = [1, 3, 2, 1, 1, 2, 3, 1, 2];
  let nArr = [];
  for (let i = 0; i < arr.length; i++) {
    if (nArr.indexOf(arr[i]) === -1) {
      nArr.push(arr[i]);
    }
  }
  console.log(nArr);
}

{
  //第二种
  let arr = [1, 3, 2, 1, 1, 2, 3, 1, 2];
  let nArr = arr.filter((current, index, self) => {
    return self.indexOf(current) === index;
  });
  console.log(nArr);
}

{
  //第三种
  let arr = [1, 3, 2, 1, 1, 2, 3, 1, 2];
  let obj = {};
  let nArr = [];
  for (let i = 0; i < arr.length; i++) {
    if (!obj[arr[i]]) {
      nArr.push(arr[i]);
      obj[arr[i]] = true;
    }
  }
  console.log(nArr);
}

// 利用 集合 来简化实现 ( ES6 Set )
{
  let _set = {};
  let _newarr = [];
  arr.forEach((v) => _set[v] || ((_set[v] = true), _newarr.push(v))); // 减少赋值行为
}

{
  //第四种
  let arr = [1, 3, 2, 1, 1, 2, 3, 1, 2];
  let nArr = new Set(arr);
  console.log(Array.from(nArr));
}
```



## 如何判断一个对象是否为数组

- 使用 `Array.isArray` 判断，如果返回 true, 说明是数组
- 使用 `instanceof Array` 判断，如果返回 true, 说明是数组



### 自己实现一个 isArray

```javascript
function isArray(arg) {
  if (typeof arg === "object") {
    return Object.prototype.toString.call(arg) === "[object Array]";
  }
  return false;
}
```

理解： `Object`对象和它的原型链上各自有一个`toString()`方法，第一个返回的是一个函数，第二个返回的是值类型。

通过`call`将`Array`的`this`上下文切换到`Object`，从而调用了`Object.prototype.toString()`，因此返回`[object Array]`。



### 为什么不直接 `Array.prototype.toString.call([arg])`?

因为`Array`，`Function`,虽然是基于`Object` 进行创建的，但是他们继承的是`Object.toString()`，而不是`Object.prototype.toString()`。



## 冒泡排序

每次比较相邻的两个数，如果后一个比前一个小，换位置

```javascript
var arr = [3, 1, 4, 6, 5, 7, 2];
function bubbleSort(arr) {
  for (var i = 0; i < arr.length - 1; i++) {
    for (var j = 0; j < arr.length - 1; j++) {
      if (arr[j + 1] < arr[j]) {
        var temp;
        temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}
console.log(bubbleSort(arr));
```



## 快速排序

采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边

```javascript
var arr = [3, 1, 4, 6, 5, 7, 2];
function quickSort(arr) {
  if (arr.length == 0) {
    return []; // 返回空数组
  }
  var cIndex = Math.floor(arr.length / 2);
  var c = arr.splice(cIndex, 1);
  var l = [];
  var r = [];
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] < c) {
      l.push(arr[i]);
    } else {
      r.push(arr[i]);
    }
  }
  return quickSort(l).concat(c, quickSort(r));
}
console.log(quickSort(arr));
```



## 求一个字符出现的次数

```javascript
function queryStr(str) {
  let json = {};
  let max = 0;
  let msg = "";
  //循环字符串，获取每个字符
  for (let i = 0; i < str.length; i++) {
    if (!json[str.charAt(i)]) {
      //判断json对象内是否有当前字符串内字符，如果没有将此字符作为键,值为1
      json[str.charAt(i)] = 1;
    } else {
      //如果json已经有当前字符传内字符，将值+1
      json[str.charAt(i)]++;
    }
  }

  //循环json对象
  for (let i in json) {
    if (json[i] > max) {
      //如果json对象内有值大于max，max就设置为此对象值，msg设置为此键
      max = json[i];
      msg = i;
    }
  }
  return {
    max,
    msg,
  };
}

console.log(
  "出现次数最多的字符是：",
  queryStr("hello").msg,
  "出现次数为：",
  queryStr("hello").max
);
```



## 编写一个方法 求一个字符串的字节长度

假设：一个英文字符占用一个字节，一个中文字符占用两个字节

```javascript
function GetBytes(str) {
  var len = str.length;
  var bytes = len;
  for (var i = 0; i < len; i++) {
    if (str.charCodeAt(i) > 255) bytes++;
  }
  return bytes;
}
alert(GetBytes("你好,as"));
```



## 写一个遍历对象和数组的 forEach 函数

```javascript
function myForEach(obj, fn) {
  if (Array.isArray(obj)) {
    //准确判断是不是数组
    obj.forEach((elem, index) => {
      fn(elem, index);
    });
  } else {
    //不是数组就是对象
    for (let k in obj) {
      fn(obj[k], k);
    }
  }
}

var arr = [1, 2, 3];
myForEach(arr, function (item, index) {
  console.log(item, index);
});

var obj = { x: 100, y: 200 };
myForEach(obj, function (key, value) {
  console.log(key, value);
});
```



## 手写 promise

```javascript
function Promise(executor) {
  this.status = "pending";
  this.value = null;
  this.reason = null;
  this.onFulfilledArray = [];
  this.onRejectedArray = [];

  const resolve = (value) => {
    if (value instanceof Promise) {
      return value.then(resolve, reject);
    }
    setTimeout(() => {
      if (this.status === "pending") {
        this.value = value;
        this.status = "fulfilled";

        this.onFulfilledArray.forEach((func) => {
          func(value);
        });
      }
    });
  };

  const reject = (reason) => {
    setTimeout(() => {
      if (this.status === "pending") {
        this.reason = reason;
        this.status = "rejected";

        this.onRejectedArray.forEach((func) => {
          func(reason);
        });
      }
    });
  };

  try {
    executor(resolve, reject);
  } catch (e) {
    reject(e);
  }
}

Promise.prototype.then = function (onfulfilled, onrejected) {
  onfulfilled =
    typeof onfulfilled === "function" ? onfulfilled : (data) => data;
  onrejected =
    typeof onrejected === "function"
      ? onrejected
      : (error) => {
          throw error;
        };

  if (this.status === "fulfilled") {
    onfulfilled(this.value);
  }
  if (this.status === "rejected") {
    onrejected(this.reason);
  }
  if (this.status === "pending") {
    this.onFulfilledArray.push(onfulfilled);
    this.onRejectedArray.push(onrejected);
  }
};

let promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("data");
  }, 2000);
});

promise.then((data) => {
  console.log(`1: ${data}`);
});
promise.then((data) => {
  console.log(`2: ${data}`);
});
```



## 手写简易 jQuery 考虑插件和扩展性

```javascript
class jQuery {
  constructor(selector) {
    const result = document.querySelectorAll(selector);
    const length = result.length;
    for (let i = 0; i < length; i++) {
      this[i] = result[i];
    }
    this.length = length;
    this.selector = selector;
  }
  get(index) {
    return this[index];
  }
  each(fn) {
    for (let i = 0; i < this.length; i++) {
      const elem = this[i];
      fn(elem);
    }
  }
  //扩展更多 DOM API
}

//插件
jQuery.prototype.dialog = function (info) {
  alert(info);
};

//造轮子
class myJquery extends jQuery {
  constructor(selector) {
    super(selector);
  }
  on(type, fn) {
    return this.each((elem) => {
      elem.addEventListener(type, fn, false);
    });
  }
}

const $p = new myJquery("p");
console.log($p);
console.log($p.get(1));
$p.each((elem) => {
  console.log(elem.innerText);
});
$p.on("click", () => {
  alert(1);
});

$p.dialog("abc");
```



## 编写一个通用的事件监听函数

```javascript
function on(elem, type, selector, fn) {
  if (fn == null) {
    fn = selector;
    selector = null;
  }
  elem.addEventListener(type, function (e) {
    const target = e.target;
    if (selector) {
      //代理绑定
      if (target.matches(selector)) {
        fn.call(target, e);
      }
    } else {
      //普通绑定
      fn(e);
    }
  });
}
```



## 手写一个简易的 ajax

```javascript
function ajax(url) {
  const p = new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          resolve(JSON.parse(xhr.responseText));
        } else if (xhr.status === 404) {
          reject(new Error("404 not found"));
        }
      }
    };
    xhr.send(null);
  });
  return p;
}

const url = "/data/test.json";
ajax(url)
  .then((res) => console.log(res))
  .catch((err) => console.error(err));
```



## 用 ES5 写一个能够生成迭代器对象的迭代器生成函数

```javascript
// 定义生成器函数，入参是任意集合
function iteratorGenerator(list) {
  // idx记录当前访问的索引
  var idx = 0;
  // len记录传入集合的长度
  var len = list.length;
  return {
    // 自定义next方法
    next: function () {
      // 如果索引还没有超出集合长度，done为false
      var done = idx >= len;
      // 如果done为false，则可以继续取值
      var value = !done ? list[idx++] : undefined;

      // 将当前值与遍历是否完毕（done）返回
      return {
        done: done,
        value: value,
      };
    },
  };
}

var iterator = iteratorGenerator(["1号选手", "2号选手", "3号选手"]);
iterator.next();
iterator.next();
iterator.next();
```



## 手写深度比较 isEqual

```javascript
// 获取类型
function isEqualType(obj) {
  return Object.prototype.toString.call(obj);
}

// 全相等（深度）
function isEqual(obj1, obj2) {
  if (isEqualType(obj1) !== isEqualType(obj2)) {
    // 值类型（注意，参与equal 的一般不会是函数）
    return false;
  }

  if (obj1 === obj2) {
    return true;
  }

  const objKeys1 = Object.keys(obj1);
  const objKeys2 = Object.keys(obj2);
  if (objKeys1.length !== objKeys2.length) {
    return false;
  }
  for (const key in obj1) {
    const res = isEqual(obj1[key], obj2[key]);
    if (!res) {
      return false;
    }
  }
  return true;
}

const a = {
  b: 100,
  c: {
    d: 2,
  },
};

const b = {
  b: 100,
  c: {
    d: 2,
  },
};

const c = [1, 3, 5, a, b];
const d = [
  1,
  3,
  5,
  {
    b: 100,
    c: {
      d: 2,
    },
  },
  {
    b: 100,
    c: {
      d: 2,
    },
  },
];

let obj1 = {
  a: ["x", "y"],
};

let obj2 = {
  a: { 0: "x", 1: "y" },
};
console.log(isEqual(a, b));
console.log(isEqual(c, d));
console.log(isEqual(obj1, obj2));
```





## 多页面应用与单页应用的区别?

##### 多页应用

每次页面跳转，后端返回一个新的 HTML

优点：

- 首屏时间快（页面首个屏幕的内容展现速度）
- SEO 效果好（搜索引擎可以识别首页中的跳转其它页面的链接）

缺点：

- 页面切换慢（每次跳转页面需发送 HTTP 请求）

##### 单页应用

JS 感知路由（URL）变化，动态清除页面内容并将新页面的内容挂载到页面上（JS 渲染），此时由前端实现路由

- 优点：页面切换快
- 缺点：首屏时间慢，SEO 差

在 vue 中不使用`<a>`标签进行页面跳转，使用`<router-link>`标签进行页面跳转 `<router-link to="/list">`列表页`</router-link>` 其中`to=""` 相当于`href=""`

## 了解 MVVM 框架吗？

了解 Vue.js。

## MVVM 使用了什么设计模式?

观察者模式

## 什么是组件化？

首先很久之前就有组件化的概念， 使用 asp jsp php 就可以。node.js 中也有类似的组件化。Vue 和 React 搬过来，做了一个创新：数据驱动视图。

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/zujianhua.png)

对比 Vue， React 组件化

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/duibizujianhua.png)

但是， 传统组件它只是静态的渲染， 也就是说我们想显示谁的个人信息， 就要在后端拼接完数据去渲染。 渲染完页面就形成了， 不会再去改变了。你再需要去改需要自己去操作 DOM。所以当时 jQuery 是很流行的。因为操作 DOM 很多。

## MVC 是什么？

传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/mvc.png)

但是 MVC 有一个巨大的缺陷就是**控制器承担的责任太大**了，随着项目愈加复杂，控制器中的代码会越来越**臃肿**，导致出现不利于**维护**的情况。

## MVP 是什么？

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/mvp.png)

首先我们要了解一下 MVP 模式， 代码分为三层。 Model 层（也就是我们所说的数据层）， Presenter 呈现层(业务逻辑相关的控制层)， View 层（视图层，页面上的 DOM 展示）。

当我们视图上的按钮被点击时， 控制器里的代码会执行， 它负责了所有的业务逻辑。控制器可以去调用模型层去发`ajax`请求，或者直接处理业务逻辑， 然后通过`DOM`操作来改变视图。

使用 MVP 模式我们大部分代码都是操作 DOM。可以说是面向 DOM 开发。

## 如何理解 MVVM ？

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/mvvm.png)

- M: Model 层 （数据 vuex，data ）
- V：View 层 （视图）
- VM： ViewModel 层

在 MVVM 架构中，引入了 **ViewModel** 的概念。

对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，**而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓。**

在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。


除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。


同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。

## Vue 的响应式原理?

Vue 内部使用了 `Object.defineProperty()` 来实现数据响应式，通过这个函数可以监听到 `set` 和 `get` 的事件。

```javascript
var data = { name: "yck" };
observe(data);
let name = data.name; // -> get value
data.name = "yyy"; // -> change value

function observe(obj) {
  // 判断类型
  if (!obj || typeof obj !== "object") {
    return;
  }
  Object.keys(obj).forEach((key) => {
    defineReactive(obj, key, obj[key]);
  });
}

function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val);
  Object.defineProperty(obj, key, {
    // 可枚举
    enumerable: true,
    // 可配置
    configurable: true,
    // 自定义函数
    get: function reactiveGetter() {
      console.log("get value");
      return val;
    },
    set: function reactiveSetter(newVal) {
      console.log("change value");
      val = newVal;
    },
  });
}
```

以上代码简单的实现了如何监听数据的 `set` 和 `get` 的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，才能在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集。

```javascript
<div>{{ name }}</div>
```



在解析如上模板代码时，遇到 

``` javascript
{{name}} 
```

就会进行依赖收集。



接下来我们先来实现一个 `Dep` 类，用于解耦属性的依赖收集和派发更新操作。

```javascript
// 通过 Dep 解耦属性的依赖和更新操作
class Dep {
  constructor() {
    this.subs = [];
  }
  // 添加依赖
  addSub(sub) {
    this.subs.push(sub);
  }
  // 更新
  notify() {
    this.subs.forEach((sub) => {
      sub.update();
    });
  }
}

// 全局属性，通过该属性配置 Watcher
Dep.target = null;
```

以上的代码实现很简单，当需要依赖收集的时候调用 `addSub`，当需要派发更新的时候调用 `notify`。

接下来我们先来简单的了解下 Vue 组件挂载时添加响应式的过程。在组件挂载时，会先对所有需要的属性调用 `Object.defineProperty()`，然后实例化 `Watcher`，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。

接下来的代码会简略的表达触发依赖收集时的操作。

```javascript
class Watcher {
  constructor(obj, key, cb) {
    // 将 Dep.target 指向自己
    // 然后触发属性的 getter 添加监听
    // 最后将 Dep.target 置空
    Dep.target = this;
    this.cb = cb;
    this.obj = obj;
    this.key = key;
    this.value = obj[key];
    Dep.target = null;
  }
  update() {
    // 获得新值
    this.value = this.obj[this.key];
    // 调用 update 方法更新 Dom
    this.cb(this.value);
  }
}
```

以上就是 `Watcher` 的简单实现，在执行构造函数的时候将 `Dep.target` 指向自身，从而使得收集到了对应的 `Watcher`，在派发更新的时候取出对应的 `Watcher` 然后执行 `update` 函数。

接下来，需要对 `defineReactive` 函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码。

```javascript
function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val);
  let dp = new Dep();
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      console.log("get value");
      // 将 Watcher 添加到订阅
      if (Dep.target) {
        dp.addSub(Dep.target);
      }
      return val;
    },
    set: function reactiveSetter(newVal) {
      console.log("change value");
      val = newVal;
      // 执行 watcher 的 update 方法
      dp.notify();
    },
  });
}
```

以上所有代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 getter 来实现依赖收集。

现在我们就来测试下代码的效果，只需要把所有的代码复制到浏览器中执行，就会发现页面的内容全部被替换了。

```javascript
var data = { name: "yck" };
observe(data);
function update(value) {
  document.querySelector("div").innerText = value;
}
// 模拟解析到 `{{name}}` 触发的操作
new Watcher(data, "name", update);
// update Dom innerText
data.name = "yyy";
```

## Object.defineProperty 的缺陷?

以上已经分析完了 Vue 的响应式原理，接下来说一点 `Object.defineProperty` 中的缺陷。

如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为 `Object.defineProperty` 不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。

对于第一个问题，Vue 提供了一个 API 解决

```javascript
export function set(target: Array<any> | Object, key: any, val: any): any {
  // 判断是否为数组且下标是否有效
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    // 调用 splice 函数触发派发更新
    // 该函数已被重写
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  // 判断 key 是否已经存在
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }
  const ob = (target: any).__ob__;
  // 如果对象不是响应式对象，就赋值返回
  if (!ob) {
    target[key] = val;
    return val;
  }
  // 进行双向绑定
  defineReactive(ob.value, key, val);
  // 手动派发更新
  ob.dep.notify();
  return val;
}
```

对于数组而言，Vue 内部重写了以下函数实现派发更新

```javascript
// 获得数组原型
const arrayProto = Array.prototype;
export const arrayMethods = Object.create(arrayProto);
// 重写以下函数
const methodsToPatch = [
  "push",
  "pop",
  "shift",
  "unshift",
  "splice",
  "sort",
  "reverse",
];
methodsToPatch.forEach(function (method) {
  // 缓存原生函数
  const original = arrayProto[method];
  // 重写函数
  def(arrayMethods, method, function mutator(...args) {
    // 先调用原生函数获得结果
    const result = original.apply(this, args);
    const ob = this.__ob__;
    let inserted;
    // 调用以下几个函数时，监听新数据
    switch (method) {
      case "push":
      case "unshift":
        inserted = args;
        break;
      case "splice":
        inserted = args.slice(2);
        break;
    }
    if (inserted) ob.observeArray(inserted);
    // 手动派发更新
    ob.dep.notify();
    return result;
  });
});
```

## 为什么 vue 中通过`this.`的方式就可以获取`data`,`method`,`prop`内的数据，而不是`this.data.`的方式？

具体请看一下的代码， 在初始化数据`initState(vm);`中对`data`,`prop`做了一层代理，将三个属性下的所有`key`值都代理到了 vue 实例上。

```javascript
proxy(vm, "_props", key);
```

```javascript
var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop,
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}
```

## 如何自己实现组件 v-model？

首先我们需要在自定义组件上面写入 v-model

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/1584147196591.png)

接着在自定义组件内写入 props 和 model， 如下：

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/1584147338097.png)

## v-model 的实现原理

- input 元素的 `value = this.name`
- 绑定 input 事件 `this.name = $event.target.value`
- data 更新触发 re-render

## 双向绑定是什么原理?

Vue 采用**数据劫持**结合**发布者-订阅者模式**的方式，通过`Object.defineProperty()`来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应的监听回调。

- data 更新 view 是使用 `Object.defineProperty()`监听 data 的变化，实现了数据响应式。通过这个函数可以监听到 `set` 和 `get` 的事件。当数据发生改变时就触发这个函数， 更新的方法放在`set`内就行了。
- view 更新 data 通过事件监听即可。比如`input`标签监听 `input` 事件就可以实现了。只不过框架执行了我们看不到。

## 如何深度监听 data ，数组变化？

深度监听、监听数组

```javascript
function updateView() {
  // 触发更新视图
  console.log("视图更新");
}

const oldArrayProperty = Array.prototype; // 重新定义数组原型
// 创建新对象，原型指向 oldArrayProperty ，再扩展新的方法不会影响原型
const arrProto = Object.create(oldArrayProperty);
["push", "pop", "shift", "unshift", "splice"].forEach((methodName) => {
  arrProto[methodName] = function () {
    updateView(); // 触发视图更新
    oldArrayProperty[methodName].call(this, ...arguments);
    // Array.prototype.push.call(this, ...arguments)
  };
});

function defineReactive(target, key, value) {
  // 重新定义属性，监听起来
  observer(value); // 深度监听
  Object.defineProperty(target, key, {
    // 核心 API
    get() {
      return value;
    },
    set(newValue) {
      if (newValue !== value) {
        observer(newValue); // 深度监听
        // 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值
        value = newValue; // 设置新值
        updateView(); // 触发更新视图
      }
    },
  });
}

function observer(target) {
  // 监听对象属性
  if (typeof target !== "object" || target === null) {
    // 不是对象或数组
    return target;
  }
  // 污染全局的 Array 原型
  // Array.prototype.push = function () {
  //     updateView()
  //     ...
  // }
  if (Array.isArray(target)) {
    target.__proto__ = arrProto;
  }
  // 重新定义各个属性（for in 也可以遍历数组）
  for (let key in target) {
    defineReactive(target, key, target[key]);
  }
}

// 准备数据
const data = {
  name: "zhangsan",
  age: 20,
  info: {
    address: "北京", // 需要深度监听
  },
  nums: [10, 20, 30],
};

// 监听数据
observer(data);

// 测试
// data.name = 'lisi'
// data.age = 21
// // console.log('age', data.age)
// data.x = '100' // 新增属性，监听不到 —— 所以有 Vue.set
// delete data.name // 删除属性，监听不到 —— 所有已 Vue.delete
// data.info.address = '上海' // 深度监听
data.nums.push(4); // 监听数组
```

以上代码重新定义原型，重写 push， pop 等方法， 实现监听。

## Object.defineProperty 的缺点？

- 深度监听，需要递归到底，一次性计算量大
- 无法监听新增属性、删除属性（Vue.set Vue.delete）
- 无法原生监听数组，需要特殊处理

## Object.defineProperty 的优点？

- 兼容性好，支持 IE9

## Proxy 相比于 defineProperty 的优势？

- 深度监听不用递归到底
- 可以监听新增属性， 删除属性
- 数组变化也能监听到
- 直接监听对象而非属性
- 支持更多的拦截方法
- 性能更好 （Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；）

## Proxy 基本使用

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/proxy.png)

## Proxy 可以实现什么功能？

相当于是一个对象的代理 ，可以自定义对象中的操作。内部拥有`set`，`get`...等方法，可以实现数据响应式

Proxy 代理/拦截

- 拦截读取: `get (target, key)`
- 拦截设置：`set (target, key, value)`
- 拦截查找: `has (target, key)` // 拦截 `key in obj`操作
- 拦截删除: `deleteProperty (target, key)`
- 拦截遍历: `ownKeys(target)` // 拦截`Object.keys,Object.getOwnPropertySymbols,Object.getOwnPropertyNames`

## Proxy 如何实现响应式？

```javascript
// 创建响应式
function reactive(target = {}) {
  if (typeof target !== "object" || target == null) {
    // 不是对象或数组，则返回
    return target;
  }

  // 代理配置
  const proxyConf = {
    get(target, key, receiver) {
      // 只处理本身（非原型的）属性
      const ownKeys = Reflect.ownKeys(target);
      if (ownKeys.includes(key)) {
        console.log("get", key); // 监听
      }

      const result = Reflect.get(target, key, receiver);

      // 深度监听
      // 性能如何提升的？
      return reactive(result);
    },
    set(target, key, val, receiver) {
      // 重复的数据，不处理
      if (val === target[key]) {
        return true;
      }

      const ownKeys = Reflect.ownKeys(target);
      if (ownKeys.includes(key)) {
        console.log("已有的 key", key);
      } else {
        console.log("新增的 key", key);
      }

      const result = Reflect.set(target, key, val, receiver);
      console.log("set", key, val);
      // console.log('result', result) // true
      return result; // 是否设置成功
    },
    deleteProperty(target, key) {
      const result = Reflect.deleteProperty(target, key);
      console.log("delete property", key);
      // console.log('result', result) // true
      return result; // 是否删除成功
    },
  };

  // 生成代理对象
  const observed = new Proxy(target, proxyConf);
  return observed;
}

// 测试数据
const data = {
  name: "zhangsan",
  age: 20,
  info: {
    city: "beijing",
    a: {
      b: {
        c: {
          d: {
            e: 100,
          },
        },
      },
    },
  },
};

const proxyData = reactive(data);
```

## Reflect 作用

- 和 proxy 能力一一对应
- 规范化、标准化、函数式
- 替代掉 object 上的工具函数

## 为什么要使用虚拟 DOM？

因为 DOM 操作非常耗费性能，

所谓 v-dom 就是使用 JS 模拟 DOM 结构， 我们都知道 JS 执行速度很快， 我们可以使用 JS 计算出最小的变更来操作 DOM。

## 如何用 JS 模拟 DOM 结构？

DOM

```html
<div id="root">
  <div title="tt1" id="container">张三</div>
  <ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
  </ul>
</div>
```

JS 模拟 DOM

```javascript
var vdom = {
  tag: 'div',
  type: 1,
  value: undefined,
  data: {
    id: 'root',
  },
  children: [
    {
      tag: 'div',
      type: 1,
      value: undefined,
      data: {
        title: 'tt1',
        id: 'container'
      },
      children: [
        tag: 'undefined',
        type: 3,
        value: "张三",
        data: undefined,
        children: []
      ]
    },{
      tag: "ul"
      type: 1,
      value: undefined,
      data: {},
      children: [{
        tag: "li",
        type: 1,
        value: undefined,
        data: {},
        children: [
          {
            tag: undefined,
            type: 3,
            value: "1",
            data: undefined,
            children: []
          }
        ]

      },{
        {
          tag: "li",
          type: 1,
          value: undefined,
          data: {},
          children: [
            {
              tag: undefined,
              type: 3,
              value: "2",
              data: undefined,
              children: []
            }
          ]
        },
        {
          tag: "li",
          type: 1,
          value: undefined,
          data: {},
          children: [
            {
              tag: undefined,
              type: 3,
              value: "3",
              data: undefined,
              children: []
            }
          ]
        }
      }]
    }
  ],
};
```

## vue 编译过程?

想必大家在使用 Vue 开发的过程中，基本都是使用模板的方式。那么你有过「模板是怎么在浏览器中运行的」这种疑虑嘛？

首先直接把模板丢到浏览器中肯定是不能运行的，模板只是为了方便开发者进行开发。Vue 会通过编译器将模板通过几个阶段最终编译为 `render` 函数，然后通过执行 `render` 函数生成 Virtual DOM 最终映射为真实 DOM。

接下来我们就来学习这个编译的过程，了解这个过程中大概发生了什么事情。这个过程其中又分为三个阶段，分别为：

1. 将模板解析为 AST
1. 优化 AST
1. 将 AST 转换为 render 函数

在第一个阶段中，最主要的事情还是通过各种各样的正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 AST 对象

```javascript
{
    // 类型
    type: 1,
    // 标签
    tag,
    // 属性列表
    attrsList: attrs,
    // 属性映射
    attrsMap: makeAttrsMap(attrs),
    // 父节点
    parent,
    // 子节点
    children: []
}
```

然后会根据这个最基本的 AST 对象中的属性，进一步扩展 AST。

当然在这一阶段中，还会进行其他的一些判断逻辑。比如说对比前后开闭标签是否一致，判断根组件是否只存在一个，判断是否符合 HTML5 Content Model 规范等等问题。

接下来就是优化 AST 的阶段。在当前版本下，Vue 进行的优化内容其实还是不多的。只是对节点进行了静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 Virtual DOM，跳过对比算法的功能。在下一个大版本中，Vue 会在优化 AST 的阶段继续发力，实现更多的优化功能，尽可能的在编译阶段压榨更多的性能，比如说提取静态的属性等等优化行为。

最后一个阶段就是通过 AST 生成 `render` 函数了。其实这一阶段虽然分支有很多，但是最主要的目的就是遍历整个 AST，根据不同的条件生成不同的代码罢了。

## 为什么 Virtual DOM 比原生 DOM 快？

首先这个问题得分场景来说，如果无脑替换所有的 DOM 这种场景来说，Virtual DOM 的局部更新肯定要来的快。但是如果你可以人肉也同样去局部替换 DOM，那么 Virtual DOM 必然没有你直接操作 DOM 来的快，毕竟还有一层 diff 算法的损耗。

## Virtual DOM 的优势？

- vdom 拥有了跨平台的优势，因为不涉及 dom。这也让 vue 可是开发其它平台，比如小程序以及 app, SSR，有类似的 weex，uniapp 平台可以使用 vue 实现。
- 操作 dom 性能大部分来说会更快，因为 dom 渲染引擎和 js 引擎本就不是一个线程，如果直接用 js 去操作 dom 耗费的性能还是挺大的，直接用 js 先渲染为 vdom，然后一次性的去渲染，并在更新时与旧节点对比，只更新差异的部分，无疑会性能会更高一些（对于节点很多的情况，如果节点非常少，引入 vdom 应该会得不偿失）
- 实现组件的高度抽象化。
- 相较于 1.0，应该是粒度由 dom 元素级别改为了组件级别，这样不会因为粒度太细，反而导致性能会降低的情况。

## vue 模板到底是什么？

- 模板不是 html， 有指令、插值、JS 表达式， 能实现判断、循环
- html 只是标签语言， 只有 JS 才能实现判断、循环(图灵完备的)
- **因此， 模板一定是转换为某种 JS 代码， 即编译模板**

#### 编译模板

- 模板编译为 render 函数，执行 render 函数返回 vnode
- 基于 vnode 再执行 patch 和 diff
- 使用 webpack vue-loader, 会在开发环境编译模板（重要）

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/vuemoban.png)

## 能说一下 vue 组件渲染和更新过程吗？

**初次渲染过程：**

- 解析模板为 render 函数（或在开发环境完成，vue-loader）
- 触发响应式，监听 data 属性 `getter` `setter`
- 执行 render 函数， 生成 vnode， patch(elem,vnode)

**更新过程**

- 修改 data， 触发 setter（此前在 getter 中已被监听）
- 重新执行 render 函数， 生成 newVnode
- patch(vnode,newVnode)

流程图：

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/liuchengtu.png)

## 你能讲一下 diff 算法吗？

diff 算法是 v-dom 中最核心，最关键的部分。

diff 即对比， 是一个广泛的概念， 如 linux diff 命令， git diff 等。

首先 DOM 是一个多叉树的结构，如果需要完整的对比两颗树的差异。那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。

- 第一， 遍历 tree1；
- 第二， 遍历 tree2
- 第三， 排序
- 1000 个节点，要计算 1 亿次， 算法不可用

于是 React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。

- 只比较同一层级， 不跨级对比
- 在实际业务中很少会去跨层的移动 DOM 元素。

只比较同一层级示意图：

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/1584421293247.png)

- 第一步先比较 tag，tag 不相同， 则直接删掉重建， 不再深度比较

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/1584421354676.png)

如图，D 和 G 的 tag 不相同，直接删掉重建为 G，即便 E 和 F 相同， 也不会再向下进行比较

- tag 和 key， 两者都相同， 则认为是相同节点， 不再深度比较

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/1586181939507.png)

示例图：

#### patchVnode

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/07-010.png)

#### updateChildren

接下来就要讲一下 updateChildren 函数了。

```javascript
function updateChildren(parentElm, oldCh, newCh) {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let oldKeyToIdx, idxInOld, elmToMove, refElm;

  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (!oldStartVnode) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (!oldEndVnode) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (sameVnode(oldStartVnode, newStartVnode)) {
      patchVnode(oldStartVnode, newStartVnode);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      patchVnode(oldEndVnode, newEndVnode);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newEndVnode)) {
      patchVnode(oldStartVnode, newEndVnode);
      nodeOps.insertBefore(
        parentElm,
        oldStartVnode.elm,
        nodeOps.nextSibling(oldEndVnode.elm)
      );
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldEndVnode, newStartVnode)) {
      patchVnode(oldEndVnode, newStartVnode);
      nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      let elmToMove = oldCh[idxInOld];
      if (!oldKeyToIdx)
        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
      idxInOld = newStartVnode.key ? oldKeyToIdx[newStartVnode.key] : null;
      if (!idxInOld) {
        createElm(newStartVnode, parentElm);
        newStartVnode = newCh[++newStartIdx];
      } else {
        elmToMove = oldCh[idxInOld];
        if (sameVnode(elmToMove, newStartVnode)) {
          patchVnode(elmToMove, newStartVnode);
          oldCh[idxInOld] = undefined;
          nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          createElm(newStartVnode, parentElm);
          newStartVnode = newCh[++newStartIdx];
        }
      }
    }
  }

  if (oldStartIdx > oldEndIdx) {
    refElm = newCh[newEndIdx + 1] ? newCh[newEndIdx + 1].elm : null;
    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx);
  } else if (newStartIdx > newEndIdx) {
    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
  }
}
```

看到代码那么多先不要着急，我们还是一点一点地讲解。<br />首先我们定义 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 分别是新老两个 VNode 的两边的索引，同时 oldStartVnode、newStartVnode、oldEndVnode 以及 newEndVnode 分别指向这几个索引对应的 VNode 节点。<br />!

接下来是一个 while 循环，在这过程中，oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 会逐渐向中间靠拢。

```javascript
while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx)
```



首先当 oldStartVnode 或者 oldEndVnode 不存在的时候，oldStartIdx 与 oldEndIdx 继续向中间靠拢，并更新对应的 oldStartVnode 与 oldEndVnode 的指向（注：下面讲到的 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 移动都会伴随着 oldStartVnode、newStartVnode、oldEndVnode 以及 newEndVnode 的指向的变化，之后的部分只会讲 Idx 的移动）。

```javascript
if (!oldStartVnode) {
  oldStartVnode = oldCh[++oldStartIdx];
} else if (!oldEndVnode) {
  oldEndVnode = oldCh[--oldEndIdx];
}
```

接下来这一块，是将 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 两两比对的过程，一共会出现 2\*2=4 种情况。

```javascript
else if (sameVnode(oldStartVnode, newStartVnode)) {
    patchVnode(oldStartVnode, newStartVnode);
    oldStartVnode = oldCh[++oldStartIdx];
    newStartVnode = newCh[++newStartIdx];
} else if (sameVnode(oldEndVnode, newEndVnode)) {
    patchVnode(oldEndVnode, newEndVnode);
    oldEndVnode = oldCh[--oldEndIdx];
    newEndVnode = newCh[--newEndIdx];
} else if (sameVnode(oldStartVnode, newEndVnode)) {
    patchVnode(oldStartVnode, newEndVnode);
    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
    oldStartVnode = oldCh[++oldStartIdx];
    newEndVnode = newCh[--newEndIdx];
} else if (sameVnode(oldEndVnode, newStartVnode)) {
    patchVnode(oldEndVnode, newStartVnode);
    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
    oldEndVnode = oldCh[--oldEndIdx];
    newStartVnode = newCh[++newStartIdx];
}
```

首先是 oldStartVnode 与 newStartVnode 符合 sameVnode 时，说明老 VNode 节点的头部与新 VNode 节点的头部是相同的 VNode 节点，直接进行 patchVnode，同时 oldStartIdx 与 newStartIdx 向后移动一位。

其次是 oldEndVnode 与 newEndVnode 符合 sameVnode，也就是两个 VNode 的结尾是相同的 VNode，同样进行 patchVnode 操作并将 oldEndVnode 与 newEndVnode 向前移动一位。

接下来是两种交叉的情况。

先是 oldStartVnode 与 newEndVnode 符合 sameVnode 的时候，也就是老 VNode 节点的头部与新 VNode 节点的尾部是同一节点的时候，将 oldStartVnode.elm 这个节点直接移动到 oldEndVnode.elm 这个节点的后面即可。然后 oldStartIdx 向后移动一位，newEndIdx 向前移动一位。

同理，oldEndVnode 与 newStartVnode 符合 sameVnode 时，也就是老 VNode 节点的尾部与新 VNode 节点的头部是同一节点的时候，将 oldEndVnode.elm 插入到 oldStartVnode.elm 前面。同样的，oldEndIdx 向前移动一位，newStartIdx 向后移动一位。

最后是当以上情况都不符合的时候，这种情况怎么处理呢？

```javascript
else {
    let elmToMove = oldCh[idxInOld];
    if (!oldKeyToIdx) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
    idxInOld = newStartVnode.key ? oldKeyToIdx[newStartVnode.key] : null;
    if (!idxInOld) {
        createElm(newStartVnode, parentElm);
        newStartVnode = newCh[++newStartIdx];
    } else {
        elmToMove = oldCh[idxInOld];
        if (sameVnode(elmToMove, newStartVnode)) {
            patchVnode(elmToMove, newStartVnode);
            oldCh[idxInOld] = undefined;
            nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
        } else {
            createElm(newStartVnode, parentElm);
            newStartVnode = newCh[++newStartIdx];
        }
    }
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
    let i, key
    const map = {}
    for (i = beginIdx; i <= endIdx; ++i) {
        key = children[i].key
        if (isDef(key)) map[key] = i
    }
    return map
}
```

createKeyToOldIdx 的作用是产生 key 与 index 索引对应的一个 map 表。比如说：

```javascript
[
  { xx: xx, key: "key0" },
  { xx: xx, key: "key1" },
  { xx: xx, key: "key2" },
];
```

在经过 createKeyToOldIdx 转化以后会变成：

```javascript
{
    key0: 0,
    key1: 1,
    key2: 2
}
```

我们可以根据某一个 key 的值，快速地从 oldKeyToIdx（createKeyToOldIdx 的返回值）中获取相同 key 的节点的索引 idxInOld，然后找到相同的节点。

如果没有找到相同的节点，则通过 createElm 创建一个新节点，并将 newStartIdx 向后移动一位。

```javascript
if (!idxInOld) {
  createElm(newStartVnode, parentElm);
  newStartVnode = newCh[++newStartIdx];
}
```

否则如果找到了节点，同时它符合 sameVnode，则将这两个节点进行 patchVnode，将该位置的老节点赋值 undefined（之后如果还有新节点与该节点 key 相同可以检测出来提示已有重复的 key ），同时将 newStartVnode.elm 插入到 oldStartVnode.elm 的前面。同理，newStartIdx 往后移动一位。

```javascript
else {
    elmToMove = oldCh[idxInOld];
    if (sameVnode(elmToMove, newStartVnode)) {
        patchVnode(elmToMove, newStartVnode);
        oldCh[idxInOld] = undefined;
        nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
        newStartVnode = newCh[++newStartIdx];
    }
}
```

如果不符合 sameVnode，只能创建一个新节点插入到 parentElm 的子节点中，newStartIdx 往后移动一位。

```javascript
else {
    createElm(newStartVnode, parentElm);
    newStartVnode = newCh[++newStartIdx];
}
```

最后一步就很容易啦，当 while 循环结束以后，如果 oldStartIdx > oldEndIdx，说明老节点比对完了，但是新节点还有多的，需要将新节点插入到真实 DOM 中去，调用 addVnodes 将这些节点插入即可。

同理，如果满足 newStartIdx > newEndIdx 条件，说明新节点比对完了，老节点还有多，将这些无用的老节点通过 removeVnodes 批量删除即可。

```javascript
if (oldStartIdx > oldEndIdx) {
  refElm = newCh[newEndIdx + 1] ? newCh[newEndIdx + 1].elm : null;
  addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx);
} else if (newStartIdx > newEndIdx) {
  removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
}
```

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/07-026.png)


## 生命周期是什么?

> `Vue`实例的生命周期就是：`Vue`实例在某一个时间点会自动执行的函数。`Vue`生命周期有 11 种之多，它分为不同的组。

- `beforeCreate`:　 `Vue`实例创建前 (获取不到`props`和`data`数据,可以添加 loading 事件)
- `created`:　　 `Vue`实例创建后 (可以获取数据,但组件未被加载，异步请求可以在这里调用)
- `beforeMount`:　　 模版数据挂载前 (开始创建 VDOM)
- `mounted`: 模版数据挂载后 (将 VDOM 渲染为真实的 DOM 并且渲染数据,挂载组件,可以获取节点)
- `beforeUpdate`:　 数据更新前　　　　(对数据进行处理的函数写这里。)
- `updated`:　　 数据更新后
- `beforeDestroy`:　 `Vue`实例销毁前　　　　(适合移除事件,定时器)
- `destroyed`:　　 `Vue`实例销毁后
- `activated`:　　 `keep-alive`组件激活时
- `deactivated`:　　 `keep-alive`组件停用时
- `errorCaptured`:　　捕获子 , 孙组件发生错误时触发 (2.5+版本增加)

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/smzqi.png)

在 `beforeCreate` 钩子函数调用的时候，是获取不到 `props` 或者 `data` 中的数据的，因为这些数据的初始化都在 `initState` 中。

然后会执行 `created` 钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。

接下来会先执行 `beforeMount` 钩子函数，开始创建 `VDOM`，最后执行 `mounted`钩子，并将 VDOM 渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。

接下来是数据更新时会调用的钩子函数 `beforeUpdate` 和 `updated`，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。

另外还有 `keep-alive` 独有的生命周期，分别为 `activated` 和 `deactivated` 。用 `keep-alive` 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 `deactivated` 钩子函数，命中缓存渲染后会执行 `actived` 钩子函数。

最后就是销毁组件的钩子函数 `beforeDestroy` 和 `destroyed`。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 `destroyed` 钩子函数。



## 父子组件的生命周期顺序

- 加载渲染过程

父 beforeCreate->父 created->父 beforeMount->子 beforeCreate->子 created->子 beforeMount->子 mounted->父 mounted

- 子组件更新过程

父 beforeUpdate->子 beforeUpdate->子 updated->父 updated

- 父组件更新过程

父 beforeUpdate->父 updated

- 销毁过程

父 beforeDestroy->子 beforeDestroy->子 destroyed->父 destroyed



## ajax 请求应该放在哪个生命周期？

**答案:**

放在`mounted`生命周期内

**解析**

因为本质上 JS 是单线程的，ajax 是异步获取数据的。

放在`mounted`之前其实并没有用，因为你放在`mounted`之前你以为会在很早把 Ajax 数据拿过来，但是由于 JS 没渲染完，你这个数据拿过来也并没有效果。

而且页面初始化时，`created` 到 `mounted` 的耗时非常短。所以 `ajax` 放在 `created` 里所能带来的优化效果，并不明显。

放在 `created` 里可以更早地获取到数据触发 `setter`，视图的重新渲染也会提前，但因为 `created` 发生在真实 `dom` 挂载之前，可能导致首屏等待时长变长。



## 何时需要使用 beforeDestory

- 自定义事件（$on $emit ）
- 清除定时器
- 解绑自定义 DOM 事件， 如 window scroll 等（window.addEventListener 绑定的事件）



## keep-alive 组件有什么作用?

如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 `keep-alive` 组件包裹需要保存的组件。

对于 `keep-alive` 组件来说，它拥有两个独有的生命周期钩子函数，分别为 `activated` 和 `deactivated` 。用 `keep-alive` 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 `deactivated` 钩子函数，命中缓存渲染后会执行 `actived` 钩子函数。

提供 `include` 和 `exclude` 属性，两者都支持字符串或正则表达式， `include` 表示只有名称匹配的组件会被缓存，`exclude` 表示任何名称匹配的组件都不会被缓存 ，其中 `exclude` 的优先级比 `include` 高；



## 组件中 name 属性有什么用？

组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。

1. 做递归组件的时候会用到
1. 对某个页面取消 keep-alive 的缓存的时候会用到
1. vue-devtools 调试工具



## 怎么强制刷新组件？

- `this.$forceUpdate()`。
- 组件上加上 key，然后变化 key 的值



## 怎么访问子组件的实例或者子元素？

- 先用 ref 特性为子组件赋予一个 ID 引用 `<base-input ref="myInput"></<base-input>`
  - 比如子组件有个 `focus` 的方法，可以这样调用 `this.$refs.myInput.focus()`；
  - 比如子组件有个 `value` 的数据，可以这样使用 `this.$refs.myInput.value`。
- 先用 ref 特性为普通的 DOM 元素赋予一个 ID 引用

```vue
<ul ref="mydiv">
    <li class="item">第一个li</li>
    <li class="item">第一个li</li>
</ul>
console.log(this.$refs['mydiv'].getElementsByClassName('item')[0].innerHTML)//第一个li
```



## 组件会在什么时候下被销毁？

- 没有使用 `keep-alive` 时的路由切换；
- `v-if='false'；`
- 执行 `vm.$destroy()；`



## 为何组件 data 必须是一个函数？

组件复用时所有组件实例都会共享 `data`，如果 `data` 是对象的话，就会造成一个组件修改 `data` 以后会影响到其他所有组件，所以需要将 `data` 写成函数，每次用到就调用一次函数获得新的数据。。

当我们使用 `new Vue()` 的方式的时候，无论我们将 `data` 设置为对象还是函数都是可以的，因为 `new Vue()` 的方式是生成一个根组件，该组件不会复用，也就不存在共享 `data` 的情况了。



## 如何将组件的所有 props 传递给子组件？

- `<User v-bind="$props" />`



## props 与非 props 特性？

props 特性：

1.  在子组件中有`props`来接收父组件传来的数据
1.  可以在子组件中使用传来的数据，但是父组件设置的属性不会在最外层的元素上显示

非 props 特性：

1.  无法接收父组件传来的数据（因为子组件中没有相应的`props`来接收父组件传来的数据）；
1.  父组件设置的属性会在其最外层的元素上显示



## 父子组件如何进行通信？

- 父组件通过`props`传递数据给子组件，子组件通过`emit`发送事件传递数据给父组件。子组件不能直接修改`props`，而是必须通过发送事件的方式告知父组件修改数据。 (单向数据流)
- 当然我们也可以使用 `$parent` / `$children` 来实现父子组件通信。它们的主要目的是作为访问组件的应急方法。更推荐用 `props` 和 `events` 实现父子组件通信。



## 为什么要有单向数据流？

为了保证数据的单向流动，便于对数据进行追踪，避免数据混乱。



## 跨多层次组件通信

对于这种情况可以使用 Vue 2.2 新增的 API `provide / inject`，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。

假设有父组件 A，然后有一个跨多层级的子组件 B

```javascript
// 父组件 A
export default {
  provide: {
    data: 1
  }
}
// 子组件 B
export default {
  inject: ['data'],
  mounted() {
    // 无论跨几层都能获得父组件的 data 属性
    console.log(this.data) // => 1
  }
}
```



## 非父子组件传值/任意组件

我们需要使用发布订阅模式或者总线机制来实现非父子组件传值。

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/feifuzishengc.png)

首先我们在 Vue 的原型链上创建一个 bus 属性， 指向一个 vue 实例。然后我们在其中一个组件上触发 change 事件， 在另外一个组件上监听绑定 change 事件， 此时就可以获取到兄弟组件传来的值了。

这种方法**通过一个空的 Vue 实例作为中央事件总线（事件中心）**，用它来**触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信**，包括父子、兄弟、跨级。



## 什么是作用域插槽？

如果我们的父组件需要一个子组件内定义的标题， 我们需要使用作用域插槽。

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/zuoyongyuchazao.png)

父组件通过 `v-slot="slotProps"` 接收到数据。 通过 `slotProps.slotData` 拿到子组件的数据

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/chacao2.1.png)



## 什么是具名插槽?

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/slotchacao.png)



## extend 能做什么？

这个 API 很少用到，作用是**扩展组件生成一个构造器，通常会与 **`**$mount**`** 一起使用**。

```javascript
// 创建组件构造器
let Component = Vue.extend({
  template: "<div>test</div>",
});
// 挂载到 #app 上
new Component().$mount("#app");
// 除了上面的方式，还可以用来扩展已有的组件
let SuperComponent = Vue.extend(Component);
new SuperComponent({
  created() {
    console.log(1);
  },
});
new SuperComponent().$mount("#app");
```



## mixin 的问题

- 变量来源不明确， 不利于阅读
- 多 mixin 可能会造成命名冲突
- mixin 和组件可能会出现多对多的关系， 复杂度较高



## mixin 和 mixins 区别

`mixin` 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。

```javascript
Vue.mixin({
  beforeCreate() {
    // ...逻辑
    // 这种方式会影响到每个组件的 beforeCreate 钩子函数
  },
});
```

虽然文档不建议我们在应用中直接使用 `mixin`，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 ajax 或者一些工具函数等等。

`mixins` 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 `mixins` 混入代码，比如上拉下拉加载数据这种逻辑等等。

另外需要注意的是 `mixins` 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。



## v-show 与 v-if 区别

`v-show` 只是在 `display: none` 和 `display: block` 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说 `v-show` 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。

`v-if` 的话就得说到 Vue 底层的编译了。当属性初始为 `false` 时，组件就不会被渲染，直到条件为 `true`，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。

并且基于 `v-if` 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。



## 为何在 v-for 中用 key？

使用 `v-for`更新已渲染的元素列表时,默认用就地复用策略。

也就是说列表数据修改的时候,他会根据`key`值去判断是否修改：如果修改,则重新渲染这一项;

否则复用之前的 dom，仅修改`value`值。

而且必须要使用`key`，而不是`index`或`random`。diff 算法是通过`tag`和`key`来判断，是否更新节点。这样就**减少了渲染次数，提升渲染性能。**



## 常见事件修饰符有哪些？

- `stop`阻止冒泡
- `prevent`阻止浏览器的默认行为、
- `capture`事件捕获模式
- `self`只有触发元素是自身时才执行的事件
- `once`只执行一次的事件
- `passive`事件行为立即触发，而不会等待

## 组合键如何使用？

组合键 `click.ctrl.exact` 只有`ctrl`被按下的时候才触发



## 绑定 class 的数组用法

- 对象方法 `v-bind:class="{'orange': isRipe, 'green': isNotRipe}"`
- 数组方法 `v-bind:class="[class1, class2]"`
- 行内 `v-bind:style="{color: color, fontSize: fontSize+'px' }"`



## computed 与 watch 和 methods 有什么区别?

- `computed`是计算属性，依赖其他属性来计算值，并且 `computed` 的值有**缓存**，只有当计算值变化才会返回内容。
- `watch` 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。
- `methods` 每次都会进行计算

当有一些数据需要随着另外一些数据变化时，建议使用 computed。 当有一个通用的响应数据变化的时候，要执行一些业务逻辑或异步操作的时候建议使用 watcher

computed 和 watch 还都支持对象的写法

```javascript
vm.$watch("obj", {
  // 深度遍历
  deep: true,
  // 立即触发
  immediate: true,
  // 执行的函数
  handler: function (val, oldVal) {},
});
var vm = new Vue({
  data: { a: 1 },
  computed: {
    aPlus: {
      // this.aPlus 时触发
      get: function () {
        return this.a + 1;
      },
      // this.aPlus = 1 时触发
      set: function (v) {
        this.a = v - 1;
      },
    },
  },
});
```



## watch 的深度监听？

首先对于引用类型是没有深度监听的， 也就是说它下面的属性值改变并不会被监听到。 我们如果想做深度监听可以按照以下方式进行：

```vue
<template>
  <div>
    <input v-model="name" />
    <input v-model="info.city" />
  </div>
</template>

<script>
export default {
  data() {
    return {
      name: "双越",
      info: {
        city: "北京",
      },
    };
  },
  watch: {
    name(oldVal, val) {
      // eslint-disable-next-line
      console.log("watch name", oldVal, val); // 值类型，可正常拿到 oldVal 和 val
    },
    info: {
      handler(oldVal, val) {
        // eslint-disable-next-line
        console.log("watch info", oldVal, val); // 引用类型，拿不到 oldVal 。因为指针相同，此时已经指向了新的 val
      },
      deep: true, // 深度监听
      immediate: true, //该回调将会在侦听开始之后被立即调用
    },
  },
};
</script>
```

在 watch 监听的引用类型下增加 handler 函数和 deep:true， 以实现深度监听。

对于引用类型来说也拿不到原先的属性值。

## $nextTick 有什么用？

- 首先 Vue 是异步渲染
- data 改变之后， DOM 不会立刻渲染
- 异步渲染时会将 data 的修改做整合， 多次 data 修改只会渲染一次。也就是说 `$nextTick` 只会触发一次
- `$nextTick` 会在 DOM 渲染之后被触发， 以获取最新 DOM 节点

## nextTick 应用场景

```javascript
// DOM 还没有更新
this.$nextTick(function () {
  // DOM 现在更新了
  // `this` 绑定到当前实例
  this.doSomethingElse();
});
```

`nextTick` 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，可以获得更新后的 DOM。

应用场景：

- 需要在视图更新之后，基于新的视图进行操作。
- created()钩子函数进行的 DOM 操作。因为此时 DOM 并未渲染。

## NextTick 原理分析

`nextTick` 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。

在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。

对于实现 macrotasks ，会先判断是否能使用 `setImmediate`，不能的话降级为 `MessageChannel` ，以上都不行的话就使用 `setTimeout`

```javascript
if (typeof setImmediate !== "undefined" && isNative(setImmediate)) {
  macroTimerFunc = () => {
    setImmediate(flushCallbacks);
  };
} else if (
  typeof MessageChannel !== "undefined" &&
  (isNative(MessageChannel) ||
    // PhantomJS
    MessageChannel.toString() === "[object MessageChannelConstructor]")
) {
  const channel = new MessageChannel();
  const port = channel.port2;
  channel.port1.onmessage = flushCallbacks;
  macroTimerFunc = () => {
    port.postMessage(1);
  };
} else {
  macroTimerFunc = () => {
    setTimeout(flushCallbacks, 0);
  };
}
```

以上代码很简单，就是判断能不能使用相应的 API。



## Vue 和 React 之间的区别

Vue 的表单可以使用 `v-model` 支持双向绑定，相比于 React 来说开发上更加方便，当然了 `v-model` 其实就是个语法糖，本质上和 React 写表单的方式没什么区别。

改变数据方式不同，Vue 修改状态相比来说要简单许多，React 需要使用 `setState` 来改变状态，并且使用这个 API 也有一些坑点。并且 Vue 的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是 React 还是需要用户手动去优化这方面的问题。

React 16 以后，有些钩子函数会执行多次，这是因为引入 Fiber 的原因。

React 需要使用 JSX，有一定的上手成本，并且需要一整套的工具链支持，但是完全可以通过 JS 来控制页面，更加的灵活。Vue 使用了模板语法，相比于 JSX 来说没有那么灵活，但是完全可以脱离工具链，通过直接编写 `render` 函数就能在浏览器中运行。

在生态上来说，两者其实没多大的差距，当然 React 的用户是远远高于 Vue 的。

在上手成本上来说，Vue 一开始的定位就是尽可能的降低前端开发的门槛，然而 React 更多的是去改变用户去接受它的概念和思想，相较于 Vue 来说上手成本略高。



## SSR 了解吗？

SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 HTML 直接返回给客户端。

SSR 有着更好的 SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持 `beforeCreate` 和 `created` 两个钩子，当我们需要一些外部扩展库时需要特殊处理。服务端渲染应用程序也需要处于 Node.js 的运行环境。还有就是服务器会有更大的负载需求。



## vue 常见性能优化方式？

1. 合理使用`v-show`、`v-if`、`computed`、`keep-alive`
1. `v-for`时加`key`，以及避免和`v-if`同时使用
1. 自定义事件、DOM 事件及时销毁
1. 使用路由懒加载、异步组件
1. `data` 层级不要太深，尽量扁平化



#### 懒加载

- 路由懒加载

当路由被访问的时候才加载对应组件

结合了 Vue 的**异步组件**和 **Webpack 的代码分割**功能，先将**异步组件**定义为返回一个 **Promise 的工厂函数**，使用**动态 import 语法**来定义**代码分块点**

```javascript
const Foo = () => import("./Foo.vue");
```

- 图片懒加载

当网络请求比较慢的时候,提前给这张图片添加一个像素比较低的占位图片，不至于堆叠在一块，或显示大片空白，让用户体验更好。

使用 vue 的 vue-lazyload 插件

在入口文件引入后把 `img` 标签里面的 `:src` 属性 改成 `v-lazy


## 实现一个观察者模式

```javascript
// 定义发布者类
class Publisher {
  constructor() {
    this.observers = [];
    console.log("Publisher created");
  }
  // 增加订阅者
  add(observer) {
    console.log("Publisher.add invoked");
    this.observers.push(observer);
  }
  // 移除订阅者
  remove(observer) {
    console.log("Publisher.remove invoked");
    this.observers.forEach((item, i) => {
      if (item === observer) {
        this.observers.splice(i, 1);
      }
    });
  }
  // 通知所有订阅者
  notify() {
    console.log("Publisher.notify invoked");
    this.observers.forEach((observer) => {
      observer.update(this);
    });
  }
}

// 定义一个具体的需求文档（prd）发布类
class PrdPublisher extends Publisher {
  constructor() {
    super();
    // 初始化需求文档
    this.prdState = null;
    // 韩梅梅还没有拉群，开发群目前为空
    this.observers = [];
    console.log("PrdPublisher created");
  }

  // 该方法用于获取当前的prdState
  getState() {
    console.log("PrdPublisher.getState invoked");
    return this.prdState;
  }

  // 该方法用于改变prdState的值
  setState(state) {
    console.log("PrdPublisher.setState invoked");
    // prd的值发生改变
    this.prdState = state;
    // 需求文档变更，立刻通知所有开发者
    this.notify();
  }
}

// 定义订阅者类
class Observer {
  constructor() {
    console.log("Observer created");
  }

  update() {
    console.log("Observer.update invoked");
  }
}

class DeveloperObserver extends Observer {
  constructor() {
    super();
    // 需求文档一开始还不存在，prd初始为空对象
    this.prdState = {};
    console.log("DeveloperObserver created");
  }

  // 重写一个具体的update方法
  update(publisher) {
    console.log("DeveloperObserver.update invoked");
    // 更新需求文档
    this.prdState = publisher.getState();
    // 调用工作函数
    this.work();
  }

  // work方法，一个专门搬砖的方法
  work() {
    // 获取需求文档
    const prd = this.prdState;
    // 开始基于需求文档提供的信息搬砖。。。
    console.log("996 begins...");
  }
}

// 创建订阅者：前端开发李雷
const liLei = new DeveloperObserver();
// 创建订阅者：服务端开发小A（sorry。。。起名字真的太难了）
const A = new DeveloperObserver();
// 创建订阅者：测试同学小B
const B = new DeveloperObserver();
// 韩梅梅出现了
const hanMeiMei = new PrdPublisher();
// 需求文档出现了
const prd = {
  // 具体的需求内容
};
// 韩梅梅开始拉群
hanMeiMei.add(liLei);
hanMeiMei.add(A);
hanMeiMei.add(B);
// 韩梅梅发送了需求文档，并@了所有人
hanMeiMei.setState(prd);
```



## 实现一个 Event Bus/ Event Emitter

Event Bus，即全局事件总线，严格来说不能说是观察者模式，而是发布-订阅模式。

Event Bus/Event Emitter 作为全局事件总线，它起到的是一个沟通桥梁的作用。我们可以把它理解为一个事件中心，我们所有事件的订阅/发布都不能由订阅方和发布方“私下沟通”，必须要委托这个事件中心帮我们实现。

在 Vue 中，有时候 A 组件和 B 组件中间隔了很远，看似没什么关系，但我们希望它们之间能够通信。这种情况下除了求助于 Vuex 之外，我们还可以通过 Event Bus 来实现我们的需求。

创建一个 Event Bus（本质上也是 Vue 实例）并导出：

```javascript
const EventBus = new Vue();
export default EventBus;
```

在主文件里引入 EventBus ，并挂载到全局：

```javascript
import bus from "EventBus的文件路径";
Vue.prototype.bus = bus;
```

订阅事件：

```javascript
// 这里func指someEvent这个事件的监听函数
this.bus.$on("someEvent", func);
```

发布（触发）事件：

```javascript
// 这里params指someEvent这个事件被触发时回调函数接收的入参
this.bus.$emit("someEvent", params);
```

大家会发现，整个调用过程中，没有出现具体的发布者和订阅者（比如上节的 PrdPublisher 和 DeveloperObserver），全程只有 bus 这个东西一个人在疯狂刷存在感。这就是全局事件总线的特点——所有事件的发布/订阅操作，必须经由事件中心，禁止一切“私下交易”！

下面，我们就一起来实现一个 Event Bus（注意看注释里的解析）：

```javascript
class EventEmitter {
  constructor() {
    // handlers是一个map，用于存储事件与回调之间的对应关系
    this.handlers = {};
  }

  // on方法用于安装事件监听器，它接受目标事件名和回调函数作为参数
  on(eventName, cb) {
    // 先检查一下目标事件名有没有对应的监听函数队列
    if (!this.handlers[eventName]) {
      // 如果没有，那么首先初始化一个监听函数队列
      this.handlers[eventName] = [];
    }

    // 把回调函数推入目标事件的监听函数队列里去
    this.handlers[eventName].push(cb);
  }

  // emit方法用于触发目标事件，它接受事件名和监听函数入参作为参数
  emit(eventName, ...args) {
    // 检查目标事件是否有监听函数队列
    if (this.handlers[eventName]) {
      // 如果有，则逐个调用队列里的回调函数
      this.handlers[eventName].forEach((callback) => {
        callback(...args);
      });
    }
  }

  // 移除某个事件回调队列里的指定回调函数
  off(eventName, cb) {
    const callbacks = this.handlers[eventName];
    const index = callbacks.indexOf(cb);
    if (index !== -1) {
      callbacks.splice(index, 1);
    }
  }

  // 为事件注册单次监听器
  once(eventName, cb) {
    // 对回调函数进行包装，使其执行完毕自动被移除
    const wrapper = (...args) => {
      cb.apply(...args);
      this.off(eventName, wrapper);
    };
    this.on(eventName, wrapper);
  }
}
```



## 请实现一个简单的购物车实例

```vue
<template>
  <div>
    <header class="header">购物车</header>
    <section class="cart-goods">
      <div class="good-item" v-for="item of goods" :key="item.id">
        <div class="goods-item-info">{{ item.title }} - {{ item.price }}元</div>
        <div class="btn" @click.stop="add(item.id)">加入购物车</div>
      </div>
    </section>
    <hr />
    <section class="cart">
      <div class="good-item" v-for="item of list" :key="item.id">
        <div class="goods-item-info">{{ item.title }} - {{ item.price }}元</div>
        <div class="goods-item-right">
          <span class="btn" @click="add(item.id)">增加</span>
          <span class="num">{{ item.quantity }}</span>
          <span class="btn" @click="sub(item.id)">减少</span>
        </div>
      </div>
    </section>
    <section class="footer">合计：{{ totalPrice }}元</section>
  </div>
</template>
<script>
export default {
  data() {
    return {
      goods: [
        {
          id: 1,
          title: "商品1",
          price: 10,
        },
        {
          id: 2,
          title: "商品2",
          price: 15,
        },
      ],
      cart: [],
    };
  },
  computed: {
    list: function () {
      return this.cart.map((cartitem) => {
        // 根据ID找到对应的商品
        const prduction = this.goods.find((item) => {
          return item.id === cartitem.id;
        });
        // 返回商品信息，外加购物数量
        return {
          ...prduction,
          quantity: cartitem.quantity,
        };
      });
    },
    totalPrice: function () {
      return this.list.reduce(
        (total, curItem) => total + curItem.price * curItem.quantity,
        0
      );
    },
  },
  methods: {
    add: function (id) {
      // 先看购物车中是否有该商品
      const prd = this.cart.find((item) => item.id === id);
      if (prd) {
        prd.quantity++;
        return;
      }
      //购物车没有该商品
      this.cart.push({
        id,
        quantity: 1, // 默认购物数量 1
      });
    },
    sub: function (id) {
      // 从购物车中找出该商品
      const prd = this.cart.find((item) => item.id === id);
      if (prd == null) {
        return;
      }
      prd.quantity--;
      // 如果数量减少到了 0
      if (prd.quantity <= 0) {
        this.cart = this.cart.filter((item) => item.id !== id);
      }
    },
  },
};
</script>
<style lang="stylus" scoped>
.btn
  display inline-flex
  align-items center
  height 30px
  padding 4px
  background #dcdcdc
  border-radius 4px
.good-item
  display flex
  justify-content space-between
  line-height 60px
.goods-item-right .num
  margin 0 15px
</style>
```



## 请实现一个简单的 TodoList？

```vue
<template>
  <div>
    <div class="todo-input-box">
      <input
        class="todo-input"
        type="text"
        placeholder="请添加待办的事项"
        v-model="todo"
        @keyup.enter="addtodo"
      />
      <span class="add" @click="addtodo">添加</span>
    </div>
    <list :list="list" @delete="del" @delline="through"> </list>
  </div>
</template>

<script>
import List from "../components/list";

export default {
  name: "todolist",
  components: {
    List,
  },
  data() {
    return {
      todo: "",
      list: [],
    };
  },
  methods: {
    addtodo: function () {
      let itemId = 1;
      if (this.list.length !== 0) {
        const lastIndex = this.list.length - 1;
        itemId = this.list[lastIndex].id + 1;
      }
      const todoitem = {
        id: itemId,
        title: this.todo,
        completed: false,
      };
      this.list.push(todoitem);
      this.todo = "";
    },
    del: function (index) {
      this.list.splice(index, 1);
    },
    through: function (id, state) {
      this.list.map((item) => {
        if (item.id === id) {
          item.completed = state;
        }
      });
    },
  },
};
</script>
<style scoped>
.todo-input-box {
  display: flex;
  justify-content: center;
}
.todo-input {
  width: 70vw;
  border: 1px solid #666;
  border-radius: 4px;
  text-indent: 10px;
  margin-right: 10px;
}
.add {
  background: #dcdcdc;
  padding: 10px;
  border-radius: 4px;
}
</style>
```

list 组件

```vue
<template>
  <ul class="list">
    <template v-for="(item, index) of list">
      <li class="item" :key="item.id">
        <input
          class="check"
          type="checkbox"
          name="item"
          :id="ids(item.id)"
          @click="check($event)"
        />
        <label :for="ids(item.id)" :class="isDelLine(item.completed)">{{
          item.title
        }}</label>
        <span class="delete" @click="del(index)">删除</span>
      </li>
    </template>
  </ul>
</template>

<script>
export default {
  name: "List",
  props: {
    list: Array,
  },
  computed: {},
  methods: {
    ids: function (id) {
      return "vid" + id;
    },
    isDelLine: function (completed) {
      return completed ? "through" : "";
    },
    check: function (event) {
      const checked = event.target.checked;
      const id = event.target.id;
      this.$emit("delline", id, checked);
    },
    del: function (index) {
      const isDel = window.confirm("您确定要删除吗？");
      if (isDel === true) {
        this.$emit("delete", index);
      }
    },
  },
};
</script>

<!-- Add "scoped" attribute to limit CSS to this component only -->
<style scoped>
.li {
  list-style: none;
}
.list {
  padding: 0 10px;
}
.list .item {
  display: flex;
  line-height: 40px;
  margin: 10px 0;
}
.item .check {
  margin-top: 12px;
}
.item .through {
  text-decoration: line-through;
}
.item label {
  flex: 1;
  background: #f0f0f0;
  padding: 0px 4px;
}
.item .delete {
  width: 50px;
}
</style>
```




## 聊一下 Vuex？

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/vuex.png)

是一个公共存储的数据库，能够方便的在 vue 实例及其组件间传递数据。



## 聊聊 Vuex 的设计思想？

Vuex 全局维护着一个对象，使用到了**单例设计模式**。`state` 里面存放的数据是**响应式**的，Vue 组件从 `store` 读取数据，若是 `store` 中的数据发生改变，依赖项数据的组件也会发生更新。并且只能通过 `commit` 的方式改变状态，实现了**单向数据流模式**。

- `state`: 状态中心、存放数据
- `mutations`: 更改状态，同步的
- `actions`: 异步更改状态
- `getters`: 获取状态,计算属性
- `modules`: 将`state`分成多个`modules`，便于管理



#### 应用场景：

1. 多个组件间的状态和数据共享
1. 路由间的复杂数据传递。

非常要注意的地方：只要刷新或者退出浏览器，仓库清空。

**除非已经确定是特别简单的项目，其它都建议使用 vuex 的方式来进行数据通信，好处是数据易于管理，可维护性高，不易造成数据传递混乱**



## Vuex 中 action 和 mutation 有何区别？

- `action` 中处理异步， `mutation` 不可以
- `mutation` 做原子操作，每次只操作一个
- `action` 可以整合多个 `mutation`



## 为什么 Vuex 的 mutation 不能做异步操作？

```javascript
mutations: {
  someMutation (state) {
    api.callAsyncMethod(() => {
      state.count++
    })
  }
}
```

现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。



## 双向绑定和 Vuex 是否冲突？

严格模式中，会冲突，抛出一个错误。

可以使用以下方式进行解决：

用 “Vuex 的思维” 去解决这个问题的方法是：给 `<input>` 中绑定 value，然后侦听 `input` 或者 `change` 事件，在事件回调中调用一个方法:

```html
<input :value="message" @input="updateMessage" />
```

```javascript
// ...
computed: {
  ...mapState({
    message: state => state.obj.message
  })
},
methods: {
  updateMessage (e) {
    this.$store.commit('updateMessage', e.target.value)
  }
}
```




## vue 怎么做路由拦截？

利用`vue-router`提供的钩子函数`beforeEach()`对路由进行判断



## 动态路由定义和获取？

在 router 目录下的 index.js 文件中，对 path 属性加上 /:id。 `path: '/bookdetail/:id',`

使用 router 对象的 params.id 获取。 `id: this.$route.params.id`



## vue-router 有哪几种导航钩子?

三种

1. 全局导航钩子

- `router.beforeEach`   全局前置守卫
- `router.beforeResolve` 全局解析守卫
- `router.afterEach` 全局后置钩子(不会接受 next 函数也不会改变导航本身)

3. 路由独享的守卫

- `beforeEnter`

2. 组件内钩子

- `beforeRouteEnter`(在渲染该组件的对应路由被 confirm 前调用)
- `beforeRouteUpdate`(在当前路由改变，但是该组件被复用时调用)
- `beforeRouteLeave`(导航离开该组件的对应路由时调用)



## 请描述一下前端路由原理

前端路由实现起来其实很简单，本质就是**监听 URL 的变化**，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式

- Hash 模式
- History 模式



## 路由两种模式有什么区别？

**Hash 模式**

**hash 的特点**

- hash 变化会触发网页跳转，即浏览器的前进、后退。
- hash 变化不会刷新页面，
- hash 永远不会提交到 server 端（前端自生自灭）

`www.test.com/#/` 就是 Hash URL。

当 `#` 后面的哈希值发生变化时，可以通过 `hashchange` 事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是 `www.test.com`。

```javascript
window.addEventListener("hashchange", () => {
  // ... 具体逻辑
});
```

Hash 模式相对来说更简单，并且兼容性也更好。

#### History 模式

History 模式是 HTML5 新推出的功能，主要使用 `history.pushState` 和 `history.replaceState` 改变 URL。

通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。

```javascript
// 新增历史记录
history.pushState(stateObject, title, URL);
// 替换当前历史记录
history.replaceState(stateObject, title, URL);
```

当用户做出浏览器动作时，比如点击后退按钮时会触发 popState 事件

```javascript
window.addEventListener("popstate", (e) => {
  // e.state 就是 pushState(stateObject) 中的 stateObject
  console.log(e.state);
});
```

两种模式对比

- Hash 模式只可以更改 `#` 后面的内容，History 模式可以通过 API 设置任意的同源 URL
- History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串
- Hash 模式无需后端配置，并且兼容性好。History 模式后端需要配置。
- Hash 丑，url 带有#号,无法使用锚点定位。history 无#， 好看。
