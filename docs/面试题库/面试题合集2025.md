# 面试题合集2025

## 做一下自我介绍
您好，我叫***，前端开发，有6年的工作经验。之前做的是一个偏向金融的CRM管理系统，主要用的技术栈是Vue。

平时的话也会学习新技术，写写自己的博客之类的。目标是想成为一名全栈工程师。


## 你的职业规划是什么？
近3年的话想深入学习一下python后端方面的知识，包括接触一些AI相关的东西。

长期来说的话也会打算了解一下UI设计，运维相关知识。总之尽量往技术的广度方面去发展。

我是打算在5年之内成为一名成熟的全栈工程师。

## 项目中遇到的困难？
之前我们做过一个pc端打电话的功能。

手机端采用uniApp，pc是网页。两者使用socket进行通信，pc端点击拨打电话后手机进行拨打，然后将通话状态传递给PC端展示。


**第一个难的点就是权限**

为了保证通话录音正常，我们需要获取通话状态、通话记录、通讯录、存储、电池保活等这些权限。

然后就是对不同品牌的手机还要检测自动录音是不是开启了，没开启的话打开对应设置界面。

还有一个是录音文件，它必须拷贝到公共目录进行读取上传。（这里也是折腾了比较久的。）

**还有就是保活，这个是最难的**

（由于安卓新版本对保活控制越来越严格，保活越来越困难。大厂可以通过合作，让手机厂商将其加入到手机系统保活白名单）

一方面我们通过原生安卓的intent来检测是否忽略电池优化，没有忽略的话打开相应设置界面。

还有就是引入一个保活插件提高保活率。（这是一个作者开发的，它里边用了双守护，1像素锁屏显示等来提高保活。）

（未使用：背景音乐保活，常驻通知栏等。）

socket使用心跳检测保证活跃。

**还有一个是系统兼容,这个比较麻烦**

比如华为录音文件lastModified（最后修改时间）为创建时间，其它系统为结束时间。（通过录音时长计算得到录音结束时间，以便匹配录音文件。）

鸿蒙系统录音文件无法读取，需要把targetSdkVersion 降到 28，安卓9。

OPPO只要手机号已经存在联系人里边，录音文件就只有姓名，没有手机号。通过手机号在联系人里边找，找到后在录音文件名称里加上电话号码以便录音文件匹配。）

小米系统默认开启空白通行证后没办法读取通话状态，而且无法检测该权限给用户提示。为了兼容换成读取通话记录，当它多出后认为通话结束。查找录音文件。

**服务器性能：**

三端频繁通信带来的服务器压力，特别是多标签页导致的socket重复连接问题，我们在前端采用了shareWorker技术统一管理socket操作，从而减轻了服务器压力。



## 讲讲diff算法？

  首先我们要对比前后两个节点是不是一样的，不一样的话就替换。

  一样的话，我们就对比他们的子节点，子节点对比总共分为九种情况。文本，数组，空两两交叉组合。

  我们主要对比数组与数组的情况，其它八种基本都是删除，更新这种。

  对于数组与数组的情况，diff算法首先从头部逐个匹配节点，然后尾部，一样的话就patch更新。

  结束后老节点如果有多的就移除，如果缺少就挂载。

  在这个过程中，可能会遇到节点顺序变化的情况。为了尽量减少DOM性能消耗，diff算法采用了最长递增子序列（LIS）的方法来识别那些不需要移动的节点。通过这种方式，我们可以确定哪些节点可以直接复用，哪些节点需要移动到正确的位置。

## 递增子序列实现

```
// 2 5 8 9 7 4 6 11
// 最长的子序列是多少个 长度

// 贪心算法

// 我们找序列中最有潜力的那一个，比最后一个大的，直接放到队列中，如果比最后一个小
// 则将它替换到队伍中比他第一个大的那一项（二分查找）

// 2 3  （更有潜力）
// 2 5


// 贪心算法+二分查找+追溯


// 2 （2的前一个是null）
// 2 5 （5的前一个是2）
// 2 5 8 （8的前一个是5）
// 2 5 8 9 （9的前一个是8）
// 2 5 8 9 7  （❌7无法放到9后边）
// 2 5 7 9 （7去找比自己大的那一项替换，虽然错误，但我们找的是后面更有潜力的。序列长度是不会错的，7的前一个是5）
// 2 5 7 9 11 （11的前一个是9）

// 追溯
// 2 5 8 9 11  = 5
function getSeq(arr) {
    let result = [0]
    const len = arr.length // 总长度
    let resultLastIndex
    let start
    let end
    let middle = 0
    let p = arr.slice(0).fill(0)
    for (let i = 0; i < len; i++) {
        const arrI = arr[i]
        if (arrI != 0) {
            // 获取队列中的最后一项
            resultLastIndex = result[result.length - 1]
            if (arr[resultLastIndex] < arrI) {
                result.push(i)
                p[i] = resultLastIndex
                continue
            }
            // ..替换
            start = 0
            end = result.length - 1
            while (start < end) { // 折半 查找
                middle = Math.floor((start + end) / 2)
                // 中间那一项的值
                // 1,2,3,4,6    5
                if (arr[result[middle]] < arrI) {
                    start = middle + 1
                } else {
                    end = middle
                }
            }
            if (arrI < arr[result[end]]) {
                p[i] = result[end - 1]
                result[end] = i // 发现最后找到的索引比这一项大，那就用这个索引换掉，因为更有潜力
            }
        }
    }
    let i = result.length
    let last = result[i - 1]
    while (i-- > 0) {
        result[i] = last
        last = p[last]
    }
    return result
}


// console.log(getSeq([1, 2, 3, 4, 5, 0]))
console.log(getSeq([2, 3, 1, 5, 9, 4]))
```

## 你的优点和缺点？

- 优点
    - 有毅力：深入研究Vue.js源码，解决了PC端打电话并上传录音文件的复杂功能。

    - 追求完美：接手混乱项目后，优化代码结构，提升可读性和维护性，如将冗长文件拆分、重命名变量以增加意义。

- 缺点

    - 社交能力偏弱: 我不擅长闲聊，但在必要时能够进行有效的沟通以确保工作的顺利进行。

## 你对AI怎么看？

我对AI感受很深，从22年开始用ChatGPT和Copilot，这些工具真的改变了我的工作方式。它们不仅能大幅减少编写简单代码的时间，还能帮我们找到解决复杂问题的新思路。我觉得我们应该尽量多接触AI，无论是直接使用还是结合开发新功能，这里面都是大有可为的。



## 简述三次握手是什么？

HTTP 协议是使用 TCP 协议作为其传输层协议的，在拿到服务器的 IP 地址后，浏览器客户端会与服务器建立 TCP 连接。该过程包括三次握手：

1. 建立连接时，客户端向服务器**发送请求报文**
2. 服务器收到请求报文后，**如同意连接**，则向客户端**发送确认报文**
3. 客户端收到服务器的确认后，**再次向服务器发出确认报文**，完成连接。

三次握手主要是为了防止已经失效的请求报文字段发送给服务器，浪费资源。



#### 为什么浪费资源？

假设没有第三次握手，仅通过两次握手来建立连接的话，可能会发生这种情况：客户端发送了一个连接请求报文，但由于网络问题这个请求被延迟了，所以没有及时得到服务器的响应。于是客户端重新发送请求，并成功建立了连接。当使用完连接并断开后，之前被延迟的那个连接请求报文突然到达了服务器。在这种情况下，如果没有进一步确认（即第三次握手），服务器会认为这是一个新的连接请求并作出响应，尝试建立连接。但实际上，这个请求是过时的，客户端并不期望建立这样一个连接。这将导致服务器为一个无效的、不被需要的连接请求分配资源，等待最终超时，从而造成了资源的浪费。

因此，第三次握手保证了只有在客户端确实希望与服务器建立连接的情况下才会建立连接，避免了由于过期的请求报文导致的不必要的资源预留和浪费。这就是为什么三次握手对于保证TCP连接的可靠性和效率是非常重要的。



## 简述四次挥手是什么？

1. 客户端**想断开连接**，发送消息给服务器
2. 服务器通知客户端已经接收到断开连接请求，但**还没做好断开连接准备（服务器可能还在向客户端发送数据）**
3. 服务器已经**做好断开连接准备**，通知客户端
4. 客户端**发送消息**给服务器，**确定断开连接**，服务器关闭连接



## 输入 URL 到页面渲染的整个流程

#### 一. 首先浏览器根据请求的 URL 交给 DNS 域名解析

DNS 的作用就是通过域名查询到具体的 IP。

在 TCP 握手之前就已经进行了 DNS 查询，这个查询是操作系统自己做的。当你在浏览器中想访问 `www.google.com` 时，会进行一下操作：

- DNS 查询解析的详细过程

过程：`. -> .com -> google.com. -> www.google.com`

1. 首先在**本地域名服务器**中查询 IP 地址
2. 如果没有找到的情况下，本地域名会向**根域名服务器**发送请求
3. 如果根域名服务器也不存在该域名时，本地域名会向**com 顶级域名服务器**发送请求
4. 依次类推下去。直到最后本地域名服务器得到`google`的 IP 地址并把它缓存到本地，供下次查询使用。

#### 二. 接下来是 TCP 三次握手：

1. 得到 ip 地址后向服务器**发送请求报文**
2. 服务器收到请求报文后，**如同意连接**，则向客户端**发送确认报文**
3. 客户端收到服务器的确认后，**再次向服务器发出确认报文**，完成连接。

#### 三. 浏览器接收相应的数据后开始解析文件

- 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件。

- 首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。

- 浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。

- 文件解码成功后会正式开始渲染流程：

  - 先会根据 HTML 构建 DOM 树，

  - 有 CSS 的话会去构建 CSSOM 树。

  - 如果遇到 script 标签的话，会判断是否存在 `async` 或者 `defer` ，`async`  会并行进行下载并执行 JS，`defer` 会先下载文件，然后等待 HTML 解析完成后顺序执行。（如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP/2 协议的话会极大的提高多图的下载效率。）

  - CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西。在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。





## 浏览器渲染过程？

> 我们知道执行 JS 有一个 JS 引擎，那么执行渲染也有一个渲染引擎。同样，渲染引擎在不同的浏览器中也不是都相同的。比如在 Firefox 中叫做 **Gecko**，在 Chrome 和 Safari 中都是基于 **WebKit** 开发的。在这一章节中，我们也会主要学习关于 **WebKit** 的这部分渲染引擎内容。



#### 浏览器接收到 HTML 文件并转换为 DOM 树

`字节数据 => 字符串 => Token => Node => DOM`

- 当我们打开网页时，浏览器先去请求对应的 HTML 文件。HTML 只是字符串，计算机不识别，网络传输内容都是`0`和`1`这样的**字节数据**。浏览器会先把**字节数据转换为字符串**，也就是我们写的代码。
- 然后将字符串**语法分析**转换为**标记**（token）。这一过程在词法分析中叫做标记化（tokenization）。
- 标记化后紧接着转换为**Node**
- 然后根据 Node 之间的联系构建成**DOM 树**。
- 在解析 HTML 文件的时候，浏览器还会遇到 CSS 和 JS 文件，这时候浏览器也会去下载并解析这些文件。

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/htmltoken.png)

什么是标记呢？这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，是构成代码的**最小单位**。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。<br />![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/imageabaioqian.png)



#### 将 CSS 文件转换为 CSSOM 树

- 和转化 DOM 树基本相似，浏览器会**先确定每个节点的样式**，样式可以自行设置，也是可以继承的。（**很消耗资源**）
- 浏览器需要**递归 CSSOM** 树，确定元素的具体样式。
- 由于递归过程是很复杂的，我们应该避免写**过于具体**的 CSS 选择器，HTML 也不要添加无意义标签，保证**层级扁平**。

#### 生成渲染树

- 当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。
- 渲染树只会渲染**需要显示的节点**，如果`display: none`就不会显示。
- 然后开始进行布局，（也可以叫做回流），调用 GPU 绘制，合成图层，显示在页面。



## 如何进行性能优化？

1. 如何进行性能优化?

   1.  多使用内存 , 缓存 , 减少 cpu 计算

   - 强缓存表示在缓存期间，不需要请求，`State Code`为 200，`Cache-Control`可以组合使用多个
   - 强缓存可以通过设置`Expires` `Cache-Control`来实现。如果两个都有以后者为准。
   - 协商缓存： 协商缓存表示如果缓存过期了，那么就需要重新发起请求验证资源是否有更新，
   - 可通过设置`HTTP Header`的`Last-Modified`和`ETag`来实现，如果资源没有改变，`State Code`为`304`

   2.  资源压缩 ,合并, 减少 http 请求
   3.  非核心代码异步加载  

   #### 异步加载的方式

   1.  动态脚本加载：动态创建 script 标签添加到页面
   1.  `defer`: 在 html 解析完成执行 , 如果是多个 , 则按照加载顺序执行
   1.  `async`: 加载完成后立即执行 , 如果是多个 , 执行顺序与加载顺序无关

   1.  使用 CDN：

   CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。

   因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。

   5. DNS 预解析

   DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。

   ```html
   <meta http-equiv="x-dns-prefetch-control" content="on" />
   //在https中强制打开a标签预解析
   
   <link rel="dns-prefetch" href="//baidu.com" /> //dns预解析
   ```

   

   ### 图片类:

   1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。
   1. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
   1. 小图使用 base64 格式
   1. 将多个图标文件整合到一张图片中（雪碧图）
   1. 选择正确的图片格式：
      - 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
      - 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
      - 照片使用 JPEG

   

   ### CSS 类:

   1.  css 放在 head 里 (先加载 css 然后渲染 否则渲染两次)
   1.  不使用 css 表达式
   1.  正确使用选择器 (应从右向左匹配 , 避免层级过多 , 扁平化)

   

   ### JS 类:

   1.  JS 放在 body 最下面 (不会阻塞渲染过程 性能优化问题； 再执行 JS script 能拿到所有标签)
   1.  减少 DOM 操作 , 对 DOM 查询进行缓存
   1.  频繁 DOM 操作， 合并到一起插入 DOM 结构
   1.  尽早在 dom 渲染完就执行，用 DOMContentLoaded 触发
   1.  删除不需要的脚本
   1.  节流
   1.  防抖
   1.  预加载:

   - 优点:降低首屏加载时间
   - 缺点:兼容性不好

   如果有些资源需要马上使用，可以使用如下代码实现，预加载不会阻塞`onload`事件

   ```html
   <link rel="preload" href="http://example.com" />
   ```

   9. 预渲染:
      - 要确保用户大概率会打开的资源进行预渲染，可以提升网页的加载速度

   可以通过预渲染将下载的文件预先在后台渲染，

   ```html
   <link rel="prerender" href="http://example.com" />
   ```

   10. 懒加载:

   懒加载就是将不关键的资源延后加载。

   对于图片来说，先设置图片标签的 `src` 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 `src` 属性，这样图片就会去下载资源，实现了图片懒加载。

   懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。

   ```javascript
   var myImage = (function () {
     var imgNode = document.createElement("img");
     document.body.appendChild(imgNode);
     var img = new Image();
     img.onload = function () {
       imgNode.src = img.src;
     };
     return {
       setSrc: function (src) {
         imgNode.src = "loading.gif";
         img.src = src;
       },
     };
   })();
   myImage.setSrc("https://img1.sycdn.imooc.com/5c09123400014ba418720632.jpg");
   ```




## 手写 promise

```js
function Promise(executor) {
  this.status = "pending";
  this.value = null;
  this.reason = null;
  this.onFulfilledArray = [];
  this.onRejectedArray = [];

  const resolve = (value) => {
    if (value instanceof Promise) {
      return value.then(resolve, reject);
    }
    setTimeout(() => {
      if (this.status === "pending") {
        this.value = value;
        this.status = "fulfilled";

        this.onFulfilledArray.forEach((func) => {
          func(value);
        });
      }
    });
  };

  const reject = (reason) => {
    setTimeout(() => {
      if (this.status === "pending") {
        this.reason = reason;
        this.status = "rejected";

        this.onRejectedArray.forEach((func) => {
          func(reason);
        });
      }
    });
  };

  try {
    executor(resolve, reject);
  } catch (e) {
    reject(e);
  }
}

Promise.prototype.then = function (onfulfilled, onrejected) {
  onfulfilled =
    typeof onfulfilled === "function" ? onfulfilled : (data) => data;
  onrejected =
    typeof onrejected === "function"
      ? onrejected
      : (error) => {
          throw error;
        };

  if (this.status === "fulfilled") {
    onfulfilled(this.value);
  }
  if (this.status === "rejected") {
    onrejected(this.reason);
  }
  if (this.status === "pending") {
    this.onFulfilledArray.push(onfulfilled);
    this.onRejectedArray.push(onrejected);
  }
};

let promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("data");
  }, 2000);
});

promise.then((data) => {
  console.log(`1: ${data}`);
});
promise.then((data) => {
  console.log(`2: ${data}`);
});
```





## MVVM模式

在前端开发领域，MVC（Model-View-Controller）、MVP（Model-View-Presenter）和MVVM（Model-View-ViewModel）是三种常见的架构模式，它们旨在帮助开发者构建结构清晰、易于维护的应用程序。下面我将分别介绍这三种模式，并讨论它们在前端中的应用。

### MVC（Model-View-Controller）

- **Model**：负责数据处理和业务逻辑。
- **View**：展示数据给用户，处理用户的交互。
- **Controller**：接收用户输入并决定如何响应这些输入，通常会更新Model或View。

在前端中，MVC模式可以用来组织代码，比如使用JavaScript框架如Backbone.js来实现。但是，传统的MVC模式有时会在前端显得不够灵活，特别是在处理复杂的用户界面时。

### MVP（Model-View-Presenter）

- **Model**：与MVC中的Model相同，负责数据处理和业务逻辑。
- **View**：纯粹的展示层，不包含任何业务逻辑。它只负责显示由Presenter提供的数据，并将用户交互反馈给Presenter。
- **Presenter**：作为中间层，它从Model获取数据，然后格式化这些数据以便View使用，并且响应来自View的用户交互事件。

MVP模式在前端中的实现相对较少，但在某些场景下非常有用，尤其是在需要严格分离UI逻辑和业务逻辑的时候。

### MVVM（Model-View-ViewModel）

- **Model**：代表数据源，独立于UI组件。
- **View**：展示数据的UI组件，绑定到ViewModel。
- **ViewModel**：作为一个连接层，它提供View所需的数据，并处理View触发的命令。ViewModel通过双向数据绑定机制与View进行通信。

MVVM模式非常适合现代前端开发，特别是当使用像Vue.js或Angular这样的框架时。这种模式极大地简化了视图和逻辑之间的同步问题，使得开发者能够更专注于业务逻辑而不是DOM操作。

### 总结

- **MVC**适用于较为简单的应用场景，但随着应用复杂度的增加，它可能会变得难以管理。
- **MVP**提供了更加清晰的职责划分，但由于其强制的分离导致代码量有所增加。
- **MVVM**由于其引入的双向数据绑定概念，大大简化了视图和模型之间的同步工作，非常适合用于动态网页的开发，特别是在使用Vue.js或Angular等现代前端框架时。

每种模式都有其适用场景和优缺点，选择哪种模式取决于项目的具体需求、团队的经验以及个人偏好。理解这些模式的核心思想有助于做出更适合项目的技术决策。



## Vue 的响应式原理?

Vue 的响应式系统是其核心特性之一，它允许数据与视图之间的自动同步更新。Vue 3 响应式系统的实现相较于 Vue 2 有了显著的变化，主要得益于 Proxy 对象的引入。

### Vue 2 中的响应式原理

在 Vue 2 中，响应式主要是通过 `Object.defineProperty` 方法来实现的。这个方法可以用来定义或修改对象属性。Vue 使用它来拦截对对象属性的访问和修改，从而能够追踪依赖并在数据变化时通知视图更新。

- **getter/setter**：对于每一个需要被监控的对象属性，Vue 都会使用 `Object.defineProperty` 来定义 getter 和 setter。当读取属性值时触发 getter，这会收集依赖；当设置属性值时触发 setter，这会导致视图更新。
- **缺点**：由于 `Object.defineProperty` 只能监听已经存在的属性，因此无法检测到新添加或删除的属性。此外，对于数组类型的数据，Vue 通过重写某些数组方法（如 push、pop）来支持响应式更新。

### Vue 3 中的响应式原理

Vue 3 利用了 ES6 引入的 Proxy 对象来构建其响应式系统，提供了一个更加高效且灵活的解决方案。

- **Proxy**：Proxy 对象用于创建一个对象的代理，从而拦截并重新定义基本操作（如属性查找、赋值等）。Vue 3 使用 Proxy 来包裹原始数据对象，这样就可以监听到任何属性的增删以及嵌套对象的变更，而无需预先定义。
- **优点**：
  - 更好的性能表现，尤其是在处理大量数据时。
  - 能够监听到对象结构的变化，包括新增或删除属性。
  - 不需要像 Vue 2 那样为每个属性都定义 getter 和 setter，简化了代码逻辑。

### 总结

Vue 的响应式机制旨在确保数据模型和视图之间保持一致，使得开发人员可以更专注于业务逻辑而非状态管理。Vue 3 中引入的 Proxy 技术极大地改进了这一过程，提供了更强的功能和更好的性能。然而，无论是 Vue 2 还是 Vue 3，理解响应式的基本原理都是掌握 Vue 开发的关键步骤之一。了解这些概念可以帮助开发者更好地优化应用性能，并解决可能出现的问题。





## v-model实现原理

`v-model` 是 Vue.js 中用于实现双向数据绑定的语法糖。它简化了表单元素与数据之间的同步过程，使得开发者可以更方便地处理用户输入。实际上，`v-model` 是通过结合 `v-bind`（绑定属性）和 `v-on`（监听事件）来实现的。

### 实现原理

在 Vue 2 和 Vue 3 中，`v-model` 的基本实现原理是相似的，都是基于属性绑定和事件监听。但是，在不同版本中，`v-model` 对不同表单元素的支持和默认行为可能会有所不同。

#### 基本用法

对于一个文本输入框来说，使用 `v-model` 可以像下面这样：

```html
<input v-model="message" />
```

这相当于以下代码的简写形式：

```html
<input :value="message" @input="message = $event.target.value" />
```

这里，`:value="message"` 使用 `v-bind` 将 `message` 的值绑定到输入框的 `value` 属性上，而 `@input="message = $event.target.value"` 则使用 `v-on` 监听 `input` 事件，并在每次触发时更新 `message` 的值。

#### 自定义组件中的 `v-model`

从 Vue 2.2.0 开始，可以在自定义组件上使用 `v-model`。在这种情况下，`v-model` 默认会利用名为 `value` 的 prop 和名为 `input` 的事件。例如：

```vue
<custom-input v-model="searchText"></custom-input>
```

等同于：

```vue
<custom-input :value="searchText" @input="searchText = arguments[0]"></custom-input>
```

在自定义组件内部，你可能需要这样做来支持 `v-model`：

```vue
Vue.component('customInput', {
  props: ['value'],
  template: `
    <input
      :value="value"
      @input="$emit('input', $event.target.value)"
    >
  `
})
```

#### Vue 3 中的变化

在 Vue 3 中，`v-model` 更加灵活，允许为每个组件实例指定不同的 prop 和 event 名称。比如：

```vue
<custom-input v-model:foo="bar"></custom-input>
```

这意味着你可以为不同的用途定制 `v-model` 的行为，而不仅仅局限于默认的 `value` 和 `input`。

### 总结

`v-model` 提供了一种简洁的方式来实现表单元素与数据之间的双向绑定。其实现依赖于 Vue 的数据绑定系统，通过组合 `v-bind` 和 `v-on` 来达到目的。理解其背后的原理有助于更好地掌握 Vue.js 的工作方式，并能更加灵活地应用这一特性。无论是直接应用于原生表单元素还是自定义组件，`v-model` 都极大地简化了开发流程。



## 为什么要使用虚拟 DOM？

虚拟 DOM（Virtual DOM）是现代前端框架（如 React、Vue 等）中使用的一种技术，旨在优化用户界面的更新效率。它的主要目的是提升应用性能，并简化开发者的操作复杂度。以下是为什么要使用虚拟 DOM 的几个关键原因：

### 1. 提升性能

在传统的网页应用中，每当模型数据发生变化时，开发者需要手动更新DOM来反映这些变化。这不仅繁琐，而且直接操作DOM的成本非常高，尤其是在处理大量元素或频繁更新的情况下。

虚拟DOM通过在内存中维护一个轻量级的DOM副本，使得我们可以在这个副本上进行任何必要的更改，然后仅将实际变更的部分同步回真实DOM。这种方式显著减少了直接操作DOM的次数和复杂性，从而提升了应用的性能。

### 2. 跨平台兼容性和可移植性

虚拟DOM不依赖于特定浏览器的实现细节，这意味着它可以更轻松地跨不同环境运行（例如服务器端渲染）。此外，它也使得构建桌面或移动应用程序变得更加容易，因为虚拟DOM可以被编译成针对这些平台的本地代码。

### 3. 简化编程模型

虚拟DOM抽象了底层DOM操作的复杂性，允许开发者以声明式的方式描述UI应该如何根据状态的变化而改变。这种编程模型更加直观，降低了学习曲线，并且减少了出错的机会。

### 4. 差异检测算法（Diffing Algorithm）

当状态更新时，虚拟DOM会重新生成一棵新的树形结构，并与旧的树进行比较，找出两者之间的差异。这个过程被称为“差异检测”或简称为“diff”。只有那些真正改变了的部分才会被更新到真实的DOM中，这样就避免了不必要的重绘和回流，进一步提高了性能。

### 结论

虚拟DOM提供了一种高效、灵活的方法来管理用户界面的更新。它通过减少直接操作DOM的频率和优化重绘流程，极大地改善了应用的响应速度和整体性能。同时，它也为开发者提供了一个更加简单、直观的编程模型，促进了快速迭代和开发效率。因此，在构建复杂的单页应用或其他需要频繁交互的Web应用时，采用虚拟DOM技术是一个明智的选择。



## 如何用 JS 模拟 DOM 结构？

DOM

```html
<div id="root">
  <div title="tt1" id="container">张三</div>
  <ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
  </ul>
</div>
```

JS 模拟 DOM

```vue
var vdom = {
  tag: 'div',
  type: 1,
  value: undefined,
  data: {
    id: 'root',
  },
  children: [
    {
      tag: 'div',
      type: 1,
      value: undefined,
      data: {
        title: 'tt1',
        id: 'container'
      },
      children: [
        tag: 'undefined',
        type: 3,
        value: "张三",
        data: undefined,
        children: []
      ]
    },{
      tag: "ul"
      type: 1,
      value: undefined,
      data: {},
      children: [{
        tag: "li",
        type: 1,
        value: undefined,
        data: {},
        children: [
          {
            tag: undefined,
            type: 3,
            value: "1",
            data: undefined,
            children: []
          }
        ]

      },{
        {
          tag: "li",
          type: 1,
          value: undefined,
          data: {},
          children: [
            {
              tag: undefined,
              type: 3,
              value: "2",
              data: undefined,
              children: []
            }
          ]
        },
        {
          tag: "li",
          type: 1,
          value: undefined,
          data: {},
          children: [
            {
              tag: undefined,
              type: 3,
              value: "3",
              data: undefined,
              children: []
            }
          ]
        }
      }]
    }
  ],
};
```



## vue 编译过程?

**Vue编译过程其实就三步**，像这样：

1. **把模板（HTML）转成内部数据（AST树）**  
   比如你写的 `<div>{{name}}</div>`，Vue会先解析成一个数据结构，标记出动态部分（比如`{{name}}`）。

2. **把数据结构转成渲染函数**  
   这个数据结构再被编译成一个函数，这个函数能根据数据生成虚拟DOM（比如`return h('div', this.name)`）。

3. **用虚拟DOM生成真实DOM**  
   最后，这个虚拟DOM会被渲染成真实的HTML，挂载到页面上。如果数据变化了，就对比新旧虚拟DOM的差异，只更新变化的部分，这样效率更高。

**举个例子**：  
你写 `{{name}}`，Vue会：  
- 解析出这是一个文本插值 → 放到数据结构里  
- 生成一个函数，里面会根据`name`的值生成虚拟节点  
- 当`name`变的时候，只更新这个文本节点，而不是整个页面  

**面试重点**：  
编译过程的核心是 **模板→AST→渲染函数→虚拟DOM→真实DOM**，关键是为了高效更新，不用每次都重绘整个页面。



## 为什么 Virtual DOM 比原生 DOM 快？

首先这个问题得分场景来说，如果无脑替换所有的 DOM 这种场景来说，Virtual DOM 的局部更新肯定要来的快。但是如果你可以人肉也同样去局部替换 DOM，那么 Virtual DOM 必然没有你直接操作 DOM 来的快，毕竟还有一层 diff 算法的损耗。



## vue生命周期

好的，我来简单说说Vue的生命周期，我按阶段分一下，这样更清晰：

**1. 创建阶段**  
- **beforeCreate**：组件实例刚创建，数据还没初始化，这时候访问数据可能还没值。  
- **created**：数据（data、computed等）初始化完成，但还没渲染DOM。适合做数据初始化，比如调接口获取数据，但这时候不能操作DOM。

**2. 挂载阶段**  
- **beforeMount**：虚拟DOM生成，但还没挂载到真实页面。  
- **mounted**：组件已经渲染到页面，可以操作DOM了。比如初始化第三方插件（如地图、图表），或者获取DOM元素。

**3. 更新阶段**（数据变化或props变化时触发）  
- **beforeUpdate**：数据变化了，但DOM还没更新。比如想在数据更新前做点什么。  
- **updated**：DOM已经更新完毕。但注意⚠️：这里频繁操作DOM可能影响性能，尽量用响应式数据驱动。

**4. 销毁阶段**  
- **beforeUnmount**（Vue3叫这个名字，Vue2是beforeDestroy）：组件即将被销毁，可以在这一步做清理工作，比如清除定时器、事件监听器。  
- **unmounted**（Vue3） / destroyed（Vue2）：组件彻底销毁，和页面没关系了。

---

**关键点总结**：  
- 挂载前（created前）不能操作DOM，mounted后才能操作。  
- 更新阶段的钩子（beforeUpdate/updated）会在数据变化时触发，但要注意避免在这里做复杂计算。  
- 销毁阶段一定要清理资源，比如定时器、事件，否则可能内存泄漏。

举个🌰：  
如果我要在页面加载时获取用户信息，我会在`created`里调接口；如果需要初始化一个ECharts图表，必须在`mounted`之后操作DOM。



## Vue 和 React 之间的区别



### **1. 核心设计理念**
| **Vue**                                                      | **React**                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **渐进式框架**：从简单到复杂逐步扩展，适合从小项目到大型应用。 | **声明式框架**：强调“一切由数据驱动”，用函数式编程思想设计。 |
| **双向数据绑定**：通过 `v-model` 实现视图和数据自动同步（如表单输入）。 | **单向数据流**：数据只能从父组件流向子组件，子组件通过事件或状态管理传递数据。 |
| **模板语法**：用 HTML 模板 + 指令（如 `v-if`、`v-for`）编写界面。 | **JSX/JS**：用 JavaScript 语法嵌入 HTML（如 `<div>{name}</div>`）。 |

---

### **2. 开发体验**
| **Vue**                                                      | **React**                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **学习曲线低**：文档友好，语法直观（如 `v-model`、`v-bind`）。 | **学习曲线高**：需学习 JSX 语法，且需理解组件化、状态管理等概念。 |
| **单文件组件**：`.vue` 文件整合 HTML/CSS/JS，适合传统 Web 开发习惯。 | **组件拆分灵活**：通常用多个 JS 文件组织组件逻辑，需依赖工具链（如 Webpack）。 |
| **自动优化**：依赖追踪系统自动优化渲染，开发者无需手动优化 90% 场景。 | **手动优化多**：需用 `React.memo`、`useMemo` 或 `PureComponent` 避免重复渲染。 |

---

### **3. 性能与虚拟 DOM**
| **Vue**                                                      | **React**                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **轻量级虚拟 DOM**：Vue 3 的虚拟 DOM 更小（约 20KB），依赖追踪更精准，更新效率高。 | **复杂虚拟 DOM**：React 的 Diff 算法优化成熟，但需依赖不可变数据（Immutable）提升性能。 |
| **响应式系统**：通过 `Proxy`（Vue 3）或 `Object.defineProperty`（Vue 2）自动追踪数据变化。 | **函数式更新**：通过 `useState`、`useEffect` 等 Hook 管理状态，需手动控制依赖。 |

---

### **4. 生态系统**
| **Vue**                                                      | **React**                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **全家桶支持**：Vue Router（路由）、Vuex（状态管理）、Vue CLI（脚手架）等开箱即用。 | **高度解耦**：核心库轻量，需搭配第三方库（如 React Router、Redux）构建复杂应用。 |
| **社区规模**：社区活跃，中文资源丰富，适合国内开发者。       | **社区更大**：Facebook 支持，全球开发者多，第三方库（如 Ant Design）更丰富。 |

---

### **5. 状态管理**
| **Vue**                                                      | **React**                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Vuex**：集中式状态管理，适合大型应用，但学习成本较低。     | **Redux**：经典的 Flux 架构，需配合中间件（如 Saga、Thunk），代码量较大。 |
| **组合式 API**（Vue 3）：用 `setup()` 和 `ref`/`reactive` 管理状态，更灵活。 | **Context API + Hooks**：通过 `useContext` 和自定义 Hook 实现状态管理，代码更简洁。 |

---

### **6. 跨平台能力**
| **Vue**                                             | **React**                                                    |
| --------------------------------------------------- | ------------------------------------------------------------ |
| **Vue Native**：跨平台移动端开发，但生态较弱。      | **React Native**：Facebook 官方支持，可开发高性能原生 App，生态成熟。 |
| **小程序支持**：通过框架（如 Wepy）适配微信小程序。 | **Taro**：支持多端（小程序、H5、React Native）开发，技术栈与 React 一致。 |

---

### **7. 适合场景**
| **Vue**                                                  | **React**                                                    |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| **适合**：中小型项目、快速开发、团队对框架易用性要求高。 | **适合**：大型复杂应用、需要高度定制化、团队熟悉 JavaScript 生态。 |
| **优势**：开箱即用，开发效率高，适合新手。               | **优势**：灵活性强，社区资源丰富，适合长期维护的大项目。     |

---

### **总结：如何选择？**
- **选 Vue**：如果你需要快速上手，追求开发效率，或团队对框架易用性要求高。
- **选 React**：如果你的项目规模大、需要极致性能，或团队熟悉 JavaScript 生态（如 TypeScript、函数式编程）。



## vue 常见性能优化方式？

以下是 Vue 中常见的性能优化方式，结合知识库内容整理，分点说明，适合面试或项目优化参考：

---

### **一、减少不必要的渲染**
1. **合理使用 `v-if` 和 `v-show`**  
   - **`v-if`**：条件不满足时直接移除 DOM，适合不频繁切换的场景。  
   - **`v-show`**：通过 CSS `display` 控制显示，切换更快但始终渲染 DOM，适合频繁切换。  
   **示例**：  
   ```vue
   <!-- v-if -->
   <div v-if="isShow">显示内容</div>
   <!-- v-show -->
   <div v-show="isShow">显示内容</div>
   ```

2. **使用 `key` 属性优化列表渲染**  
   - 在 `v-for` 中为每个元素提供唯一 `key`，帮助 Vue 区分元素，减少 DOM 操作。  
   **示例**：  
   ```vue
   <div v-for="item in list" :key="item.id">{{ item.name }}</div>
   ```

3. **避免频繁更新组件**  
   - **Vue 2**：通过 `shouldComponentUpdate` 钩子或 `extends: Vue.extend()` 创建纯组件（Pure Component）。  
   - **Vue 3**：使用 `memo` 或 ` shallowRef` 避免子组件频繁重新渲染。  
   **示例**：  
   ```vue
   // Vue 3 中使用 memo
   const MyComponent = memo(() => {
     return <div>只在 props 变化时重新渲染</div>;
   });
   ```

---

### **二、懒加载与代码分割**
1. **路由懒加载**  
   通过动态 `import()` 按需加载路由组件，减少初始加载时间。  
   **示例**：  
   ```javascript
   // 路由配置
   const Foo = () => import('@/views/Foo.vue');
   const routes = [
     { path: '/foo', component: Foo }
   ];
   ```

2. **异步组件**  
   使用 `defineAsyncComponent` 延迟加载非关键组件。  
   **示例**：  
   ```javascript
   import { defineAsyncComponent } from 'vue';
   const AsyncComponent = defineAsyncComponent(() => import('@/components/AsyncComponent.vue'));
   ```

---

### **三、状态管理优化**
1. **合理使用 Vuex/Pinia**  
   - **集中管理状态**：避免组件间直接传递数据，减少冗余。  
   - **模块化拆分**：按功能拆分模块，按需加载，减少监听范围。  
   **示例**：  
   ```javascript
   // Pinia 模块化
   const store = defineStore('user', {
     state: () => ({ name: '', age: 0 }),
     actions: { /* ... */ }
   });
   ```

2. **避免过度使用计算属性和 Watcher**  
   - 计算属性依赖的数据越少，性能越高。  
   - 对于简单逻辑，直接使用方法替代计算属性。  
   **示例**：  
   ```vue
   computed: {
     fullName() {
       return this.firstName + ' ' + this.lastName;
     }
   }
   ```

---

### **四、虚拟滚动与大数据优化**
1. **虚拟滚动**  
   使用库（如 `vue-virtual-scroller`）仅渲染可见区域的 DOM，适合处理长列表。  
   **示例**：  
   ```vue
   <template>
     <RecycleScroller
       :items="largeList"
       :item-size="50"
       key-field="id"
       v-slot="{ item }"
     >
       <div>{{ item.name }}</div>
     </RecycleScroller>
   </template>
   ```

---

### **五、生产环境优化**
1. **使用生产版本**  
   构建时设置 `NODE_ENV=production`，移除开发环境的警告和调试代码。  
   **命令示例**：  
   ```bash
   vue-cli-service build --mode production
   ```

2. **Tree Shaking**  
   通过 ES Module 的静态导入导出，移除未使用的代码。  
   **package.json 配置**：  
   ```json
   {
     "sideEffects": false
   }
   ```

---

### **六、事件与 DOM 优化**
1. **防抖与节流**  
   对频繁触发的事件（如 `scroll`、`resize`）使用防抖（debounce）或节流（throttle）。  
   **示例**：  
   ```javascript
   import { debounce } from 'lodash';
   methods: {
     handleScroll: debounce(function() {
       // 处理滚动逻辑
     }, 200)
   }
   ```

2. **事件委托**  
   将事件监听器绑定到父元素，减少事件数量。  
   **示例**：  
   ```javascript
   // 监听父元素的点击事件
   document.querySelector('.parent').addEventListener('click', (e) => {
     if (e.target.classList.contains('child')) {
       // 处理子元素点击
     }
   });
   ```

---

### **七、其他优化技巧**
1. **使用 `keep-alive` 缓存组件**  
   缓存不常用但需要保留状态的组件，避免重复渲染。  
   **示例**：  
   ```vue
   <keep-alive>
     <component :is="currentView"></component>
   </keep-alive>
   ```

2. **避免直接操作 DOM**  
   通过 Vue 的响应式系统驱动视图更新，减少手动操作 DOM 的需求。

3. **函数式组件（Vue 2）**  
   无状态、无生命周期的组件开销更小。  
   **示例**：  
   ```vue
   Vue.component('my-component', {
     functional: true,
     render(h, context) {
       return h('div', context.props.text);
     }
   });
   ```

---

### **总结：关键优化点**
1. **懒加载**：路由/组件按需加载。  
2. **虚拟滚动**：处理大数据列表。  
3. **状态管理**：合理使用 Vuex/Pinia。  
4. **减少渲染**：`key`、`v-if`、`memo`。  
5. **生产环境配置**：Tree Shaking、生产版本。  

根据项目需求选择优化方案，优先解决性能瓶颈（如通过 Chrome DevTools 分析）。



## vue-router 有哪几种导航钩子?

三种

1. 全局导航钩子

- `router.beforeEach`  全局前置守卫
- `router.beforeResolve` 全局解析守卫
- `router.afterEach` 全局后置钩子(不会接受 next 函数也不会改变导航本身)

1. 路由独享的守卫

- `beforeEnter`

1. 组件内钩子

- `beforeRouteEnter`(在渲染该组件的对应路由被 confirm 前调用)
- `beforeRouteUpdate`(在当前路由改变，但是该组件被复用时调用)
- `beforeRouteLeave`(导航离开该组件的对应路由时调用)



## Vue3 生命周期和 Vue2 生命周期有什么区别？



以下是 **Vue 3** 和 **Vue 2** 生命周期钩子的核心区别，结合知识库内容整理，适合面试或项目迁移参考：

---

### **1. 生命周期钩子名称变化**
| **Vue 2**                | **Vue 3**                   | **说明**                                                     |
| ------------------------ | --------------------------- | ------------------------------------------------------------ |
| `beforeCreate`           | **无**（由 `setup()` 替代） | Vue 3 中 `setup()` 在 `beforeCreate` 和 `created` 之前执行，无需显式定义。 |
| `created`                | **无**（由 `setup()` 替代） | `setup()` 已包含 `created` 的功能，且优先级更高。            |
| `beforeDestroy`          | `onBeforeUnmount`           | 组件卸载前触发，用于清理资源（如定时器、监听器）。           |
| `destroyed`              | `onUnmounted`               | 组件完全卸载后触发。                                         |
| 其他钩子（如 `mounted`） | `onMounted`                 | 命名前缀统一为 `on`，如 `onBeforeMount`、`onUpdated` 等。    |

---

### **2. 新增的生命周期钩子**
Vue 3 新增了以下钩子，主要用于 **`<keep-alive>`** 缓存组件的激活/停用状态：
- **`onActivated`**：组件被激活时触发（如从缓存中恢复）。
- **`onDeactivated`**：组件被停用时触发（如被缓存时）。

---

### **3. 组合式 API 的使用方式**
- **Vue 2**：生命周期钩子直接写在选项中（如 `created()`、`mounted()`）。
- **Vue 3**：需从 `vue` 中导入钩子函数（如 `onMounted`、`onBeforeUpdate`），并在 `setup()` 中调用：
  ```vue
  import { onMounted, onUnmounted } from 'vue';
  
  setup() {
    onMounted(() => {
      // 组件挂载后逻辑
    });
    
    onUnmounted(() => {
      // 组件卸载前逻辑
    });
    
    return {};
  }
  ```

---

### **4. `setup()` 的影响**
- **Vue 3** 的 `setup()` 函数在组件初始化时最先执行，替代了 `beforeCreate` 和 `created` 钩子。
- **特点**：
  - `setup()` 是**响应式上下文**，可以直接访问 `props` 和 ` reactive`/`ref` 数据。
  - `this` 在 `setup()` 中**无效**，需通过 `context` 或 `getCurrentInstance()` 获取组件实例。
  - `setup()` 的返回值会暴露给模板，因此无需显式定义 `data` 或 `methods`。

---

### **5. 销毁阶段的钩子名称变化**
| **Vue 2**       | **Vue 3**         |
| --------------- | ----------------- |
| `beforeDestroy` | `onBeforeUnmount` |
| `destroyed`     | `onUnmounted`     |

---

### **6. 执行顺序的变化**
Vue 3 的生命周期执行顺序与 Vue 2 基本一致，但 `setup()` 的引入调整了部分阶段：
1. **`setup()`** → 执行组合式 API 的逻辑。
2. **`beforeCreate`** 和 **`created`** 钩子被 `setup()` 替代。
3. 其他钩子（如 `onMounted`、`onUpdated`）的触发时机与 Vue 2 对应钩子一致。

---

### **7. 关键区别总结**
| **对比项**                   | **Vue 2**                   | **Vue 3**                         |
| ---------------------------- | --------------------------- | --------------------------------- |
| **钩子命名**                 | 原始名称（如 `created`）    | 命名前缀为 `on`（如 `onCreated`） |
| **`beforeCreate`/`created`** | 存在                        | 由 `setup()` 替代，无需显式定义   |
| **销毁钩子**                 | `beforeDestroy`/`destroyed` | `onBeforeUnmount`/`onUnmounted`   |
| **钩子引入方式**             | 直接写在选项中              | 需从 `vue` 导入（如 `onMounted`） |
| **组合式 API 支持**          | 不支持                      | 原生支持，需通过 `setup()` 使用   |

---

### **8. 迁移示例**
将 Vue 2 的生命周期迁移到 Vue 3：
```javascript
// Vue 2（选项式 API）
export default {
  mounted() {
    console.log('组件已挂载');
  },
  beforeDestroy() {
    console.log('组件即将销毁');
  }
};

// Vue 3（组合式 API）
import { onMounted, onUnmounted } from 'vue';

export default {
  setup() {
    onMounted(() => {
      console.log('组件已挂载');
    });
    
    onUnmounted(() => {
      console.log('组件即将销毁');
    });
    
    return {};
  }
};
```

---

### **9. 注意事项**
- **`setup()` 的优先级**：`setup()` 在 `beforeCreate` 和 `created` 之前执行，且只执行一次（单文件组件中）。
- **避免混合使用 API**：Vue 3 允许同时使用选项式 API 和组合式 API，但建议统一风格以避免混乱。
- **销毁阶段清理**：务必在 `onBeforeUnmount` 中清理资源（如定时器、事件监听），防止内存泄漏。

---

### **总结**
Vue 3 的生命周期钩子名称更规范（统一 `on` 前缀），且通过组合式 API 的 `setup()` 函数重构了初始化阶段。迁移时需注意钩子名称的修改、导入方式的变化，以及 `setup()` 的使用场景。



## 如何理解 `ref`、`toRef` 和 `toRefs`？

#### **核心概念**
Vue 3 中的 `ref`、`toRef` 和 `toRefs` 都是用于处理响应式数据的工具函数，但它们的用途和行为有明显区别。以下是它们的核心区别和应用场景：

---

### **1. `ref`**
#### **作用**
- **创建基本类型的响应式数据**：将任意值（包括基本类型和引用类型）包装成一个响应式对象，并通过 `.value` 访问/修改其值。
- **适用于简单数据**：如数字、布尔值、对象等。

#### **示例**
```javascript
import { ref } from 'vue';

const count = ref(0); // 响应式基本类型
const user = ref({ name: 'Alice' }); // 响应式对象

console.log(count.value); // 0
count.value = 1; // 更新值，视图自动更新
```

#### **特点**
- **包装任何类型**：无论是基本类型（如 `number`、`string`）还是对象，`ref` 都会将其包装成一个响应式对象。
- **直接响应式**：修改 `.value` 会触发视图更新。
- **模板中自动解包**：在模板中使用时，Vue 会自动解包 `.value`，无需显式写 `.value`。

---

### **2. `toRef`**
#### **作用**
- **将响应式对象的单个属性转为 `ref`**：将 `reactive` 对象中的某个属性转换为独立的 `ref`，保持与原对象的绑定。
- **解耦属性**：允许单独操作某个属性，同时保持与原对象的响应式关联。

#### **示例**
```javascript
import { reactive, toRef } from 'vue';

const user = reactive({
  name: 'Alice',
  age: 25
});

const nameRef = toRef(user, 'name'); // 将 user.name 转为 ref

// 修改 nameRef 会影响原对象
nameRef.value = 'Bob';
console.log(user.name); // 'Bob'

// 修改原对象也会影响 ref
user.age = 30;
console.log(toRef(user, 'age').value); // 30
```

#### **特点**
- **依赖原对象**：`toRef` 返回的 `ref` 与原 `reactive` 对象的属性**双向绑定**。
- **适合单个属性**：当需要单独传递或操作某个属性时使用。
- **避免解构丢失响应性**：例如，从 `reactive` 对象中提取单个属性传递给子组件。

---

### **3. `toRefs`**
#### **作用**
- **批量将 `reactive` 对象的所有属性转为 `ref`**：将整个 `reactive` 对象的每个属性转换为独立的 `ref`，形成一个普通对象。
- **保留解构后的响应性**：解决直接解构 `reactive` 对象导致的响应性丢失问题。

#### **示例**
```javascript
import { reactive, toRefs } from 'vue';

const user = reactive({
  name: 'Alice',
  age: 25
});

const refs = toRefs(user); // { name: ref('Alice'), age: ref(25) }

// 解构后仍保持响应式
const { name, age } = refs;
name.value = 'Bob'; // user.name 同步更新
```

#### **特点**
- **批量转换**：将 `reactive` 对象的所有属性转为 `ref`，形成一个普通对象。
- **解决解构问题**：直接解构 `reactive` 对象会丢失响应性，而 `toRefs` 可以保留响应性。
- **适合返回多个响应式属性**：例如在 `setup()` 中解构 `reactive` 对象后返回给模板。

---

### **关键区别总结**
| **函数** | **作用**                               | **参数**                 | **返回值**                | **与原数据的关系**           |
| -------- | -------------------------------------- | ------------------------ | ------------------------- | ---------------------------- |
| `ref`    | 包装任意值为响应式对象                 | 初始值（任意类型）       | `ref` 对象（含 `.value`） | 独立存在，修改不影响其他数据 |
| `toRef`  | 将 `reactive` 对象的单个属性转为 `ref` | `reactive` 对象 + 属性名 | `ref` 对象（绑定原属性）  | 与原属性双向绑定             |
| `toRefs` | 将 `reactive` 对象的所有属性转为 `ref` | `reactive` 对象          | 普通对象，属性为 `ref`    | 所有属性与原对象双向绑定     |

---

### **常见场景**
#### **场景 1：解构 `reactive` 对象**
```javascript
const user = reactive({ name: 'Alice', age: 25 });

// 直接解构会丢失响应性！
const { name } = user; // name 是普通变量，不再响应式

// 使用 toRefs 保留响应性
const { name, age } = toRefs(user); // name 和 age 是 ref
```

#### **场景 2：跨组件传递数据**
```javascript
// 父组件
const user = reactive({ name: 'Alice' });
return { userRef: toRef(user, 'name') };

// 子组件接收 userRef（ref 类型），修改时会同步父组件
```

#### **场景 3：在 `setup()` 中返回多个属性**
```vue
setup() {
  const state = reactive({ count: 0, text: '' });
  // 返回解构后的 ref，确保响应式
  return { ...toRefs(state) };
}
```

---

### **注意事项**
1. **`.value` 的使用**：
   - `ref(10).value`：直接访问值。
   - `toRef(user, 'age').value`：访问 `user.age`。
   - `toRefs(user).age.value`：访问 `user.age`。

2. **避免重复包装**：
   - 不要对 `ref` 再次使用 `toRef`，会导致嵌套 `.value`（如 `toRef(ref(10), 'value')`）。

3. **与 `reactive` 的配合**：
   - `reactive` 用于创建复杂对象的响应式，而 `toRef`/`toRefs` 用于解构或传递属性。

---

### **总结**
- **`ref`**：基础响应式包装器，适合基本类型或需要独立响应式值的场景。
- **`toRef`**：提取 `reactive` 对象的单个属性为 `ref`，保持双向绑定。
- **`toRefs`**：批量转换 `reactive` 对象的所有属性为 `ref`，解决解构后的响应性问题。

通过合理使用这些工具，可以更灵活地管理 Vue 3 中的响应式数据，避免常见的响应性丢失问题。



## Vue3 为何比 Vue2 快

- Proxy 响应式
- PatchFlag
- hoistStatic
- cacheHandler
- SSR 优化
- tree-shaking



### PatchFlag

- 编译模板时,动态节点做标记
- 标记,分为不同的类型,如 TEXT PROPS
- diff 算法时，可以区分静态节点,以及不同类型的动态节点

![image-20220808174120035](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20220808174120035.png)



### HoistStatic

- 将静态节点的定义,提升到父作用域,缓存起来
- 多个相邻的静态节点,会被合并起来
- 典型的拿空间换时间的优化策略

将静态节点的定义,提升到父作用域,缓存起来

![image-20220808174151576](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20220808174151576.png)

多个相邻的静态节点,会被合并起来![image-20220808174233992](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20220808174233992.png)



### CacheHandler

- 缓存事件

![image-20220808174304798](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20220808174304798.png)



### SSR 优化

- 静态节点直接输出, 绕过了 vdom
- 动态节点, 还是需要动态渲染

类似 HoistStatic

- ![image-20220808174327021](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20220808174327021.png)

### Tree-shaking 的优化

- 编译时, 根据不同的情况,引入不同的 API

  

![image-20220808174356872](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20220808174356872.png)





## Vue3 和 JSX-基本使用

```vue
<template>
    <p @click="changeFlag">Demo {{flagRef}}</p>
    <child a="abc" v-if="flagRef"></child>
    <ul>
        <li v-for="item in state.list" :key="item">{{item}}</li>
    </ul>
</template>

<script>
import { ref, reactive } from 'vue'
import Child from './Child'

export default {
    name: 'Demo',
    components: { Child },
    setup() {
        const flagRef = ref(true)

        function changeFlag() {
            flagRef.value = !flagRef.value
        }

        const state = reactive({
            list: ['a', 'b', 'c']
        })

        return {
            flagRef,
            changeFlag,
            state
        }
    }
}
</script>
```

```vue
<script>
import {ref} from 'vue';
export default {
    setup(){
        const countRef = ref(200)
        // return ()=>{
        //     return <p>demo12 {countRef.value}</p>
        // }
        const render = ()=>{
            return <p>demo1.vue {countRef.value}</p>//jsx
        }
        return render
    }
}
</script>
```

```javascript
import { defineComponent, ref, reactive } from "vue";
import Child from "./Child";

export default defineComponent(() => {
  const flagRef = ref(true);

  function changeFlag() {
    flagRef.value = !flagRef.value;
  }

  const state = reactive({
    list: ["a1", "b1", "c1"],
  });

  const render = () => {
    return (
      <>
        <p onClick={changeFlag}>demo1 {flagRef.value.toString()}</p>
        {flagRef.value && <Child a={flagRef.value}></Child>}

        <ul>
          {state.list.map((item) => (
            <li>{item}</li>
          ))}
        </ul>
      </>
    );
  };
  return render;
});

// 1. setup 函数
// 2. 组件的配置
```

```javascript
import { defineComponent } from "vue";

export default defineComponent({
  props: ["a"],
  setup(props) {
    const render = () => {
      return <p>Child {props.a}</p>;
    };
    return render;
  },
});
```



### module chunk bundle 分别什么意思，有何区别?

- module： 各个源码文件， webpack 中一切皆模块
- chunk： 多模块合并成的， 如 entry import() splitChunk
- bundle： 最终输出的文件
- ![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/bundle.png)



## 前端代码为何要进行构建和打包?

- 体积更小（Tree-Shaking、压缩、合并），加载更快
- 能够编译高级语言或语法（TS、ES6+、模块化、SCSS）
- 兼容性和错误检查（Polyfill、postcss、eslint）

#### 研发流程方面：

- 统一，高效的开发环境
- 统一的构建流程和产出标准
- 集成公司构建规范（提测、上线等）



## Plugin 与 loader 的区别？

#### loader

- loader 模块转换器， 如 less > css

  loader 是一个打包方案，它是针对于某一个特定类型的文件，webpack 该如何进行打包。本身 webpack 是不知道对于一些文件（jpg，txt，excel）该如何处理的，但是 loader 知道。 所以 webpack 去求助 loader 就可以啦。

- Plugin

  plugin 扩展插件，如 HtmlWebpackPlugin

  在我们做打包的时候， 在某一个具体时刻上。 比如说， 当我打包结束后，我要自动生成一个 html 文件， 这时候我们就可以使用一个 html-webpack-plugin 的插件。它会在打包结束后生成 html 文件。

  Plugin 可以在我们打包过程的某个时刻想做一些事情。

## 常见 loader 有哪些？

1. file-loader

   打包图片文件，先将文件转移到打包目录下，再将 dist 中的文件路径返回给 index.js。

1. url-loader

   可以通过图片大小来判断是使用 base64 格式图片还是直接打包成一个图片资源文件。

1. css-loader

   帮我们分析出几个 css 文件的引入关系， 最终将这些 css 文件合并成一段 css。

1. style-loader

   再得到 css-loader 生成的内容后， 会把这段代码挂载到 html 的 head 部分。

1. sass-loader

   sass 文件打包

1. postcss-loader

   自动加厂商前缀

1. babel-loader

   babel 与 webpack 沟通的桥梁

1. ts-loader

   TypeScript 的打包配置

1. eslint-loader

   可以使团队统一使用一套 eslint





### 常见 plugin 有哪些？

1.  html-webpack-plugin 会在打包结束的时刻， 自动生成一个 html 文件， 并把打包生成的 js 自动注入到这个 html 文件中。
1.  clean-webpack-plugin 打包流程执行前清空 dist 目录
1.  webpack.HotModuleReplacementPlugin 模块热更新
1.  webpack.IgnorePlugin 忽略无用文件
1.  webpack-bundle-analyzer 打包分析
1.  happypack 多进程打包
1.  webpack-parallel-uglify-plugin 多进程压缩 JS
1.  mini-css-extract-plugin 将 CSS 提取为独立的文件
1.  optimize-css-assets-webpack-plugin 压缩 css 代码
1.  workbox-webpack-plugin 实现 PWA，是一种强缓存技术
1.  add-asset-html-webpack-plugin 将 JavaScript 或 CSS 资源添加到 html-webpack-plugin 生成的 HTML 中
1.  webpack.DllPlugin 我们引入了一个 lodash 库， 我们知道这个库的文件它是不会变的， 但是每次打包都会打包它， 我们可以让它只在第一次打包， 下次就不打包了。



## babel 和 webpack 的区别

- babel JS 新语法编译工具， 不关心模块化
- webpack 打包构建工具， 是多个 loader plugin 的集合
