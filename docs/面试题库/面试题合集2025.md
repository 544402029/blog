# 面试题合集2025

## 谈谈你对 vue 的理解 ？



### 1.1 声明式框架

- Vue 的核心特点，用起来简单。那我们就有必要知道**命令式和声明式的区别**！

  - 早在 JQ 的时代编写的代码都是命令式的，命令式框架重要特点就是关注过程
  - 声明式框架更加关注结果。命令式的代码封装到了 Vuejs 中，过程靠 vuejs 来实现

  > 声明式代码更加简单，不需要关注实现，按照要求填代码就可以 （给上原材料就出结果）





### 1.2 MVVM 模式

在前端开发领域，MVC（Model-View-Controller）、和MVVM（Model-View-ViewModel）是两种常见的架构模式。

#### MVC（Model-View-Controller）

- **Model**：负责数据处理和业务逻辑。
- **View**：展示数据给用户，处理用户的交互。
- **Controller**：接收用户输入并决定如何响应这些输入，通常会更新Model或View。

在前端中，MVC模式可以用来组织代码，比如使用JavaScript框架如Backbone.js来实现。但是，传统的MVC模式有时会在前端显得不够灵活，特别是在处理复杂的用户界面时。



#### MVVM（Model-View-ViewModel）

- **Model**：代表数据源，独立于UI组件。
- **View**：展示数据的UI组件，绑定到ViewModel。
- **ViewModel**：作为一个连接层，它提供View所需的数据，并处理View触发的命令。ViewModel通过双向数据绑定机制与View进行通信。

MVVM模式非常适合现代前端开发，特别是当使用像Vue.js或Angular这样的框架时。这种模式极大地简化了视图和逻辑之间的同步问题，使得开发者能够更专注于业务逻辑而不是DOM操作。



### 1.3 采用虚拟 DOM

传统更新页面，拼接一个完整的字符串 innerHTML 全部重新渲染，添加虚拟 DOM 后，可以比较新旧虚拟节点，找到变化在进行更新。虚拟 DOM 就是一个对象，用来描述真实 DOM 的



### 1.4 区分编译时(打包)和运行(浏览器)时

- Vue 的渲染核心就是调用渲染（render）方法将虚拟 DOM 渲染成真实 DOM （缺点就是虚拟 DOM 编写麻烦）

- 专门写个编译时可以将模板编译成虚拟 DOM （在构建的时候进行编译性能更高，不需要再运行的时候进行编译）

  

### 1.5 组件化

实现高内聚、低耦合、单向数据流

- 组件化开发能大幅提高应用开发效率、测试性、复用性等;
- 降低更新范围，只重新渲染变化的组件



## 谈谈你对 SPA 的理解？

### 1.1 理解基本概念

- SPA（single-page application）单页应用，默认情况下我们编写 Vue、React 都只有一个`html` 页面，并且提供一个挂载点，最终打包后会再此页面中引入对应的资源。（页面的渲染全部是由 JS 动态进行渲染的）。切换页面时通过监听路由变化，渲染对应的页面 **Client Side Rendering，客户端渲染 CSR**
- MPA（Multi-page application）多页应用，多个`html`页面。每个页面必须重复加载，js，css 等相关资源。（服务端返回完整的 html，同时数据也可以再后端进行获取一并返回“模板引擎”）。多页应用跳转需要整页资源刷新。**Server Side Rendering，服务器端渲染 SSR**

> 如何分清在哪渲染：HTML 是在前端动态生成的“客户端渲染”，在服务端处理好并返回的是“服务端渲染”。

### 1.2 优缺点

|            | 单页面应用（SPA） | 多页面应用（MPA）       |
|:-----------|:-----------|:-----------------|
| 组成         | 一个主页面和页面组件 | 多个完整的页面          |
| 刷新方式       | 局部刷新       | 整页刷新             |
| SEO 搜索引擎优化 | 无法实现       | 容易实现             |
| 页面切换       | 速度快，用户体验良好 | 切换加载资源，速度慢，用户体验差 |
| 维护成本       | 相对容易       | 相对复杂             |

- 用户体验好、快，内容的改变不需要重新加载整个页面，服务端压力小。
- SPA 应用不利于搜索引擎的抓取。
- 首次渲染速度相对较慢 （第一次返回空的 html，需要再次请求首屏数据）白屏时间长。

### 1.3 解决方案

- 静态页面预渲染(Static Site Generation) SSG，在构建时生成完整的 html 页面。（就是在打包的时候，先将页面放到浏览器中运行一下，将`HTML`保存起来），仅适合静态页面网站。变化率不高的网站
- `SSR` + `CSR` 的方式， 首屏采用服务端渲染的方式，后续交互采用客户端渲染方式。`NuxtJS`



## 为什么要使用虚拟 DOM？

### 1.1 基本概念

> 基本上所有框架都引入了虚拟 DOM 来对真实 DOM 进行抽象，也就是现在大家所熟知的 VNode 和 VDOM

- Virtual DOM 就是用 js 对象来描述真实 DOM，是对真实 DOM 的抽象，由于直接操作 DOM 性能低但是 js 层的操作效率高，可以将 DOM 操作转化成对象操作，最终通过 diff 算法比对差异进行更新 DOM（减少了对真实 DOM 的操作）。
- 虚拟 DOM 不依赖真实平台环境从而也可以实现跨平台。

### 1.2 VDOM 是如何生成的 ？

- 在 vue 中我们常常会为组件编写模板 - template
- 这个模板会被编译器编译为渲染函数 - render
- 在接下来的挂载过程中会调用 render 函数，返回的对象就是虚拟 dom
- 会在后续的 patch 过程中进一步转化为 真实 dom。

### 1.3 VDOM 如何做 diff 的？

- 挂载过程结束后，会记录第一次生成的 VDOM - oldVnode
- 当响应式数据发生变化时，将会引起组件重新 render，此时就会生成新的 VDOM - newVnode
- 使用 oldVnode 与 newVnode 做 diff 操作，将更改的部分应到真实 DOM 上，从而转换为最小量的 dom 操作，高效更新视图。



## 谈一谈对 Vue 组件化的理解

> `WebComponent` 组件化的核心组成：模板、属性、事件、插槽、生命周期。

组件化好处: 高内聚、可重用、可组合

- 组件化开发能大幅提高应用开发效率、测试性、复用性等;
- 降低更新范围，只重新渲染变化的组件；

补充：

- `Vue`中的每个组件都有一个渲染函数 watcher、effect。
- 数据是响应式的，数据变化后会执行 watcher 或者 effect。
- 组件要合理的划分，如果不拆分组件，那更新的时候整个页面都要重新更新。
- 如果过分的拆分组件会导致 watcher、effect 产生过多也会造成性能浪费。



## 既然 Vue 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 DOM 进行 diff 检测差异？

- Vue 的数据劫持是通过 Object.defineProperty 或 Proxy 来实现的。
- 虚拟 DOM 是用于比较两次渲染之间的虚拟树，找出差异并仅更新必要的部分。从而提高性能，减少直接操作实际 DOM 的次数。（直接操作真实 DOM 是代价是非常昂贵的）

> Vue 内部设计原因导致，vue 设计的是每个组件一个 watcher（渲染 watcher），没有采用一个属性对应一个 watcher。这样会导致大量 watcher 的产生而且浪费内存，如果粒度过低也无法精准检测变化。所以采用 diff 算法 + 组件级 watcher。



#### **为什么 Vue 不采用更细粒度的 Watcher？**

如果 Vue 采用 **每个属性对应一个 Watcher** 的设计，虽然可以更精确地知道哪些数据发生了变化，但会带来以下问题：

- **内存占用过高**：每个 Watcher 都需要占用内存，大量 Watcher 会导致内存消耗过大。
- **更新效率降低**：频繁触发 Watcher 更新可能会导致性能问题，尤其是在复杂组件中。
- **代码复杂性增加**：需要更复杂的逻辑来管理大量的 Watcher，增加代码的维护成本。

因此，Vue 选择了 **组件级 Watcher + 虚拟 DOM** 的设计，在 **性能** 和 **开发体验** 之间找到了一个平衡点。



## 请说一下你对响应式数据的理解？

### 1.1 如何实现响应式数据

数组和对象类型当值变化时如何劫持到。对象内部通过`defineReactive`方法，使用`Object.defineProperty`将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。 多层对象是通过**递归**来实现劫持。`Vue3`则采用 proxy

### 1.2 `vue2` 处理缺陷

- 在 `Vue2` 的时候使用 `defineProperty` 来进行数据的劫持, 需要对属性进行重写添加`getter`及`setter` **性能差**。
- 当新增属性和删除属性时无法监控变化。需要通过`$set`、`$delete`实现
- 数组不采用 `defineProperty` 来进行劫持 （浪费性能，对所有索引进行劫持会造成性能浪费）需要对数组单独进行处理。
- 对于 `ES6` 中新产生的 Map、Set 这些数据结构不支持。

### 1.3 `Vue2` 与 `Vue3` 实现对比

javascript

```
function defineReactive(target,key,value){
    observer(value);
    Object.defineProperty(target,key,{
        get(){
            return value;
        },
        set(newValue){
            if (value !== newValue) {
                value = newValue;
                observer(newValue)
            }
        }
    })
}
function observer(data) {
    if(typeof data !== 'object'){
        return data
    }
    for(let key in data){
        defineReactive(data,key,data[key]);
    }
}
```



```js
let handler = {
  get(target, key) {
    if (typeof target[key] === "object") {
      return new Proxy(target[key], handler);
    }
    return Reflect.get(target, key);
  },
  set(target, key, value) {
    let oldValue = target[key];
    if (oldValue !== value) {
      return Reflect.set(target, key, value);
    }
    return true;
  },
};
let proxy = new Proxy(obj, handler);
```



## Vue 中如何检测数组变化?

### 1.1 Vue2 中采用重写数组方法的方式

- 数组考虑性能原因没有用`defineProperty`对数组的每一项进行拦截，而是选择重写数组（`push,shift,pop,splice,unshift,sort,reverse`）方法。**数组中如果是对象数据类型也会进行递归劫持**。

#### **性能优化对比示例**

|        **场景**        |       **逐项劫持**       |  **重写方法**   |
|:--------------------:|:--------------------:|:-----------:|
|    初始化 10,000 项数组    |    高内存占用 + 长初始化时间    | 低内存 + 快速初始化 |
| 执行 `arr.push(1,2,3)` | 触发 3 次索引更新 + 3 次视图渲染 | 触发 1 次视图渲染  |
|        嵌套对象处理        |     全量递归劫持所有子对象      | 按需劫持访问到的子对象 |

### 1.2 Vue3 直接采用的是 Proxy

- 在 Vue 3.x 中，直接使用 Proxy 实现了更*高效*和*精确*的数组变化检测，通过 Proxy，Vue 可以捕获到数组索引和长度的变化，不再需要重写数组的方法。这是 Vue 3.x 在性能方面的一个重要改进（但是由于代理问题，还需要对部分检测方法进行重写）。

1. *修改length或者设置一个比当前length大的索引，会对其特殊处理。添加/修改。*

2. *如果原始对象放入一个响应式数组，用includes查询原始对象，会出现查询不到的情况，代理对象和原始对象本身就不一样。解决方案就是拦截includes，先在代理数组上找，找不到再往原始数组里边找。 `indexOf` 和 `lastIndexOf`同理*。

3. *`push/pop/shift/unshift/splice `会隐式修改数组长度, 触发无限更新，拦截这些方法禁止追踪。后续**手动触发 `length` 的更新通知***。



## 如何将 template 转换成 render 函数 ?

Vue 中含有模版编译的功能，它的主要作用是将用户编写的 template 编译为 js 中可执行的 render 函数。

```javascript
/**
 * 将 Vue 模板编译为可执行代码的核心函数
 * @param {string} template - 原始模板字符串
 * @returns {object} 编译后的抽象语法树（AST）及相关产物
 */
export function compile(template) {
    // ====================== 阶段1：解析模板为AST ======================
    /**
     * 解析器将模板字符串转换为抽象语法树（AST）
     * 实现细节：
     * 1. 使用正则表达式匹配标签、属性、文本等元素
     * 2. 构建树形结构，记录节点类型（元素/文本）、属性列表、子节点等
     * 3. 处理特殊语法如插值表达式{{}}、指令(v-if/v-for)等
     * 
     * 示例输入：`<div class="box">{{msg}}</div>`
     * 输出AST节点：
     * {
     *   type: 1,
     *   tag: 'div',
     *   attrsList: [{ name: 'class', value: 'box' }],
     *   children: [{
     *     type: 2,
     *     expression: '_s(msg)',
     *     text: '{{msg}}'
     *   }]
     * }
     */
    const ast = parser(template);

    // ====================== 阶段2：转换优化AST ======================
    /**
     * 对AST进行静态分析和优化处理
     * 主要功能：
     * 1. 标记静态子树（static: true），避免重复渲染
     * 2. 处理指令转换（如v-if转为条件表达式）
     * 3. 静态节点提升（hoistStatic），减少运行时开销
     * 
     * 示例优化后AST节点：
     * {
     *   static: false, // 动态节点
     *   children: [{
     *     static: true, // 静态文本节点
     *     isStatic: true
     *   }]
     * }
     */
    transform(ast);

    // ====================== 阶段3：生成可执行代码 ======================
    /**
     * 将优化后的AST转换为可执行的JavaScript代码字符串
     * 实现细节：
     * 1. 拼接_c、_v、_s等虚拟DOM构建函数调用
     * 2. 处理动态属性绑定（如:class、@click）
     * 3. 生成带有with语句的render函数体
     * 
     * 示例输出代码：
     * `with(this){return _c('div',{class:"box"},[_v(_s(msg))])}`
     */
    const code = generate(ast);

    // 实际Vue编译流程应返回生成的代码字符串
    // 此处保持原代码结构返回AST用于演示
    return { 
        ast,      // 抽象语法树
        code,     // 可执行代码字符串
        render: new Function(code) // 最终生成的渲染函数
    };
}
```

##### **关键步骤说明：**
1. **解析阶段**（`parser`）  
   通过正则表达式（如`/<([a-z][^\/>\0]*)/i`匹配标签）和状态机解析模板，构建包含标签、属性、子节点的树形结构。例如解析到`v-for`指令时会生成带`for`属性的AST节点。

2. **转换阶段**（`transform`）  
   遍历AST进行两轮优化：
   • **静态标记**：识别纯静态节点（如无绑定的`<div>static</div>`）并添加`static: true`标记
   • **指令转换**：将`v-if`转换为三元表达式，`v-for`转换为`_l`渲染列表函数

3. **代码生成**（`generate`）  
   递归拼接代码字符串，使用Vue内部工具方法：
   ```javascript
   // 生成示例
   _c('div', { class: _normalizeClass({ active: isActive }) }, [
     _v("静态文本"),
     _s(dynamicText)
   ])
   ```



> Vue3 中的模版转化，做了更多的优化操作。Vue2 仅仅是标记了静态节点而已~



## Vue 中如何进行依赖收集？

`Vue3`**依赖收集**

- `Vue3`中会通过`Map`结构将属性和`effect`映射起来。
- 默认在初始化时会调用 render 函数，此时会触发属性依赖收集`track`，
- 当属性发生修改时会找到对应的`effect`列表依次执行`trigger`



## Vue 中 diff 算法原理？

  首先我们要对比前后两个节点是不是一样的，不一样的话就替换。

  一样的话，我们就对比他们的子节点，子节点对比总共分为九种情况。文本，数组，空两两交叉组合。

  我们主要对比数组与数组的情况，其它八种基本都是删除，更新这种。

  对于数组与数组的情况，diff算法首先从头部逐个匹配节点，然后尾部，一样的话就patch更新。

  结束后老节点如果有多的就移除，如果缺少就挂载。

  在这个过程中，可能会遇到节点顺序变化的情况。为了尽量减少DOM性能消耗，diff算法采用了最长递增子序列（LIS）的方法来识别那些不需要移动的节点。通过这种方式，我们可以确定哪些节点可以直接复用，哪些节点需要移动到正确的位置。





### 1.1 Diff 概念

vue 基于虚拟 DOM 做更新 。diff 的核心就是比较两个虚拟节点的差异 。Vue 的 diff 算法是平级比较，不考虑跨级比较的情况。内部采用深度递归的方式 + 双指针的方式进行比较。

#### 1.2 Vue2 Diff 比较流程

- 1.先比较是否是相同节点 key tag
- 2.相同节点比较属性,并复用老节点（将老的虚拟 dom 复用给新的虚拟节点 DOM）
- 3.比较儿子节点，考虑老节点和新节点儿子的情况
  - 老的没儿子，现在有儿子。 直接插入新的儿子
  - 老的有儿子，新的没儿子。直接删除页面节点
  - 老的儿子是文本，新的儿子是文本，直接更新文本节点即可
  - 老的儿子是一个列表，新的儿子也是一个列表 updateChildren
- 4.优化比较：头头、尾尾、头尾、尾头
- 5.比对查找进行复用

> Vue3 中采用最长递增子序列来实现 diff 优化。

![diff](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/vue-diff.4c21677d.jpg)

### 1.3 Vue3 Diff 算法比较流程

全量 Diff：

- 刚开始默认从头比对，相同节点则复用节点。
- 如果头部节点不一致，我们就从后向前对比，相同节点则复用。
- 默认优化了子节点追加和子节点删除的情况。
- 乱序比对，通过最长递增子序列实现在复用过程中减少节点的移动操作。

#### 1.`sync from start`

![img](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/diff-1.png)

#### 2.`sync from end`

![img](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/diff-2.png)

#### 3.`common sequence + mount`

![img](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/diff-3.png)

![img](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/diff-4.png)

#### 4.`common sequence + unmount`（通用序列+卸载）

![img](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/diff-5.png)![img](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/diff-6-1613403863544.png)

#### 5.`unknown sequence`

##### 1).`build key:index map for newChildren`

![img](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/diff-7.png)

#### 2).绕过那些需要修补的老节点，试着修补

#### 3).移动或挂载

![img](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/diff-8.png)

> Vue3 采用最长递增子序列，求解不需要移动的元素有哪些



## 递增子序列实现

```js
// 2 5 8 9 7 4 6 11
// 最长的子序列是多少个 长度

// 贪心算法

// 我们找序列中最有潜力的那一个，比最后一个大的，直接放到队列中，如果比最后一个小
// 则将它替换到队伍中比他第一个大的那一项（二分查找）

// 2 3  （更有潜力）
// 2 5


// 贪心算法+二分查找+追溯


// 2 （2的前一个是null）
// 2 5 （5的前一个是2）
// 2 5 8 （8的前一个是5）
// 2 5 8 9 （9的前一个是8）
// 2 5 8 9 7  （❌7无法放到9后边）
// 2 5 7 9 （7去找比自己大的那一项替换，虽然错误，但我们找的是后面更有潜力的。序列长度是不会错的，7的前一个是5）
// 2 5 7 9 11 （11的前一个是9）

// 追溯
// 2 5 8 9 11  = 5
function getSeq(arr) {
    let result = [0]
    const len = arr.length // 总长度
    let resultLastIndex
    let start
    let end
    let middle = 0
    let p = arr.slice(0).fill(0)
    for (let i = 0; i < len; i++) {
        const arrI = arr[i]
        if (arrI != 0) {
            // 获取队列中的最后一项
            resultLastIndex = result[result.length - 1]
            if (arr[resultLastIndex] < arrI) {
                result.push(i)
                p[i] = resultLastIndex
                continue
            }
            // ..替换
            start = 0
            end = result.length - 1
            while (start < end) { // 折半 查找
                middle = Math.floor((start + end) / 2)
                // 中间那一项的值
                // 1,2,3,4,6    5
                if (arr[result[middle]] < arrI) {
                    start = middle + 1
                } else {
                    end = middle
                }
            }
            if (arrI < arr[result[end]]) {
                p[i] = result[end - 1]
                result[end] = i // 发现最后找到的索引比这一项大，那就用这个索引换掉，因为更有潜力
            }
        }
    }
    let i = result.length
    let last = result[i - 1]
    while (i-- > 0) {
        result[i] = last
        last = p[last]
    }
    return result
}


// console.log(getSeq([1, 2, 3, 4, 5, 0]))
console.log(getSeq([2, 3, 1, 5, 9, 4]))
```



## 请说明 Vue 中 key 的作用和原理，谈谈你对它的理解

### 1.1 key 的概念

- `key` 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。
- 当 Vue 正在更新使用 `v-for` 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染

### 1.2 key 的作用

- Vue 在 patch 过程中通过 key 可以判断两个虚拟节点是否是相同节点。 （可以复用老节点）
- 无 key 会导致更新的时候出问题
- 尽量不要采用索引作为 key

![key](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/key.ca1b7f53.png)







## Vue3 为何比 Vue2 快？

- Proxy 响应式
- PatchFlag
- hoistStatic
- cacheHandler
- SSR 优化
- tree-shaking



## 谈谈 Vue3 中模板编译做了哪些优化？

### 1.1 PatchFlags 优化

Diff 算法无法避免新旧虚拟 DOM 中无用的比较操作，通过 patchFlags 来标记动态内容，可以实现快速 diff 算法

html

```html
<div>
  <h1>Hello Jiang</h1>
  <span>{{name}}</span>
</div>
```

> 此 template 经过模板编译会变成以下代码：

javascript

```js
const {
  createElementVNode: _createElementVNode,
  toDisplayString: _toDisplayString,
  createTextVNode: _createTextVNode,
  openBlock: _openBlock,
  createElementBlock: _createElementBlock,
} = Vue;

return function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (
    _openBlock(),
    _createElementBlock("div", null, [
      _createElementVNode("h1", null, "Hello Jiang"),
      _createTextVNode(),
      _createElementVNode(
        "span",
        null,
        _toDisplayString(_ctx.name),
        1 /* TEXT */
      ),
    ])
  );
};
```

#### 创建虚拟节点

> 生成的虚拟 DOM 是：

javascript

```
{
	type: "div",
    __v_isVNode: true,
    children:[
       {type: 'h1', props: null, key: null, …}
       {type: Symbol(), props: null, key: null, …}
	   {type: 'span', props: null, key: null, …}
    ],
    dynamicChildren:[{type: 'span', children: _ctx.name, patchFlag: 1}]
}
```

> 此时生成的虚拟节点多出一个 dynamicChildren 属性。这个就是 block 的作用，block 可以收集所有后代动态节点。这样后续更新时可以直接跳过静态节点，实现靶向更新

#### 动态标识

javascript

```ts
export const enum PatchFlags {
  TEXT = 1, // 动态文本节点
  CLASS = 1 << 1, // 动态class
  STYLE = 1 << 2, // 动态style
  PROPS = 1 << 3, // 除了class\style动态属性
  FULL_PROPS = 1 << 4, // 有key，需要完整diff
  HYDRATE_EVENTS = 1 << 5, // 挂载过事件的
  STABLE_FRAGMENT = 1 << 6, // 稳定序列，子节点顺序不会发生变化
  KEYED_FRAGMENT = 1 << 7, // 子节点有key的fragment
  UNKEYED_FRAGMENT = 1 << 8, // 子节点没有key的fragment
  NEED_PATCH = 1 << 9, // 进行非props比较, ref比较
  DYNAMIC_SLOTS = 1 << 10, // 动态插槽
  DEV_ROOT_FRAGMENT = 1 << 11,
  HOISTED = -1, // 表示静态节点，内容变化，不比较儿子
  BAIL = -2 // 表示diff算法应该结束
}
```

### 1.2 BlockTree

为什么我们还要提出 blockTree 的概念？ 只有 block 不就挺好的么？ 问题出在 block 在收集动态节点时是忽略虚拟 DOM 树层级的。

html

```js
<div>
  <p v-if="flag">
    <span>{{a}}</span>
  </p>
  <div v-else>
    <span>{{a}}</span>
  </div>
</div>
```

> 这里我们知道默认根节点是一个 block 节点，如果要是按照之前的套路来搞，这时候切换 flag 的状态将无法从 p 标签切换到 div 标签。 **解决方案：就是将不稳定的结构也作为 block 来进行处理**

#### 不稳定结构

所谓的不稳结构就是 DOM 树的结构可能会发生变化。不稳定结构有哪些呢？ （v-if/v-for/Fragment）

#### **v-if**

html

```html
<div>
  <div v-if="flag">
    <span>{{a}}</span>
  </div>
  <div v-else>
    <p><span>{{a}}</span></p>
  </div>
</div>
```

编译后的结果:

javascript

```js
return function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (
    _openBlock(),
    _createElementBlock("div", null, [
      _ctx.flag
        ? (_openBlock(),
          _createElementBlock("div", { key: 0 }, [
            _createElementVNode(
              "span",
              null,
              _toDisplayString(_ctx.a),
              1 /* TEXT */
            ),
          ]))
        : (_openBlock(),
          _createElementBlock("div", { key: 1 }, [
            _createElementVNode("p", null, [
              _createElementVNode(
                "span",
                null,
                _toDisplayString(_ctx.a),
                1 /* TEXT */
              ),
            ]),
          ])),
    ])
  );
};
```



```
Block(div)
	Blcok(div,{key:0})
	Block(div,{key:1})
```

父节点除了会收集动态节点之外，也会收集子 block。 更新时因 key 值不同会进行删除重新创建

#### v-for

随着`v-for`变量的变化也会导致虚拟 DOM 树变得不稳定

html

```html
<div>
  <div v-for="item in fruits">{{item}}</div>
</div>
```

javascript

```js
export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (
    _openBlock(true),
    _createElementBlock(
      _Fragment,
      null,
      _renderList(_ctx.fruits, (item) => {
        return (
          _openBlock(),
          _createElementBlock("div", null, _toDisplayString(item), 1 /* TEXT */)
        );
      }),
      256 /* UNKEYED_FRAGMENT */
    )
  );
}
```

> 可以试想一下，如果不增加这个 block，前后元素不一致是无法做到靶向更新的。因为 dynamicChildren 中还有可能有其他层级的元素。同时这里还生成了一个 Fragment，因为前后元素个数不一致，所以称之为**不稳定序列**。

#### 稳定 Fragment

这里是可以靶向更新的, 因为稳定则有参照物

html

```html
<div>
  <div v-for="item in 3">{{item}}</div>
</div>
```

javascript

```js
export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (
    _openBlock(),
    _createElementBlock("div", null, [
      (_openBlock(),
      _createElementBlock(
        _Fragment,
        null,
        _renderList(3, (item) => {
          return _createElementVNode(
            "div",
            null,
            _toDisplayString(item),
            1 /* TEXT */
          );
        }),
        64 /* STABLE_FRAGMENT */
      )),
    ])
  );
}
```

### 1.3 静态提升

html

```
<div>
  <span>hello</span>
  <span a="1" b="2">{{name}}</span>
  <a><span>{{age}}</span></a>
</div>
```

我们把模板直接转化成 render 函数是这个酱紫的，那么问题就是每次调用`render`函数都要重新创建虚拟节点。

javascript

```
export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (
    _openBlock(),
    _createElementBlock("div", null, [
      _createElementVNode("span", null, "hello"),
      _createElementVNode(
        "span",
        {
          a: "1",
          b: "2",
        },
        _toDisplayString(_ctx.name),
        1 /* TEXT */
      ),
      _createElementVNode("a", null, [
        _createElementVNode(
          "span",
          null,
          _toDisplayString(_ctx.age),
          1 /* TEXT */
        ),
      ]),
    ])
  );
}
```


```
const _hoisted_1 = /*#__PURE__*/ _createElementVNode(
  "span",
  null,
  "hello",
  -1 /* HOISTED */
);
const _hoisted_2 = {
  a: "1",
  b: "2",
};

export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (
    _openBlock(),
    _createElementBlock("div", null, [
      _hoisted_1,
      _createElementVNode(
        "span",
        _hoisted_2,
        _toDisplayString(_ctx.name),
        1 /* TEXT */
      ),
      _createElementVNode("a", null, [
        _createElementVNode(
          "span",
          null,
          _toDisplayString(_ctx.age),
          1 /* TEXT */
        ),
      ]),
    ])
  );
}
```

> 静态提升则是将静态的节点或者属性提升出去。**静态提升是以树为单位**。也就是说树中节点有动态的不会进行提升。

### 1.4 预字符串化

静态提升的节点都是静态的，我们可以将提升出来的节点字符串化。 当连续静态节点超过 20 个时，会将静态节点序列化为字符串。

html

```
<div>
  <span></span>
  ... ...
  <span></span>
</div>
```

javascript

```
const _hoisted_1 = /*#__PURE__*/ _createStaticVNode("<span>....</span>", 20);
```

- 大块的静态内容可以通过 `innerHTML` 进行设置，在性能上具有一定优势。
- 减少创建虚拟节点产生的性能开销。
- 减少内存占用。



### 1.5 缓存内联事件函数

html

```
<div @click="e=>v=e.target.value"></div>
```

> 每次调用 render 的时都要创建新函数

javascript

```
export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (
    _openBlock(),
    _createElementBlock(
      "div",
      {
        onClick: (e) => (_ctx.v = e.target.value),
      },
      null,
      8 /* PROPS */,
      ["onClick"]
    )
  );
}
```

> 开启函数缓存后,函数会被缓存起来，后续可以直接使用

javascript

```
export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (
    _openBlock(),
    _createElementBlock("div", {
      onClick: _cache[0] || (_cache[0] = (e) => (_ctx.v = e.target.value)),
    })
  );
}
```



## 你知道哪些 Vue3 新特性?

- Composition API
  - 使用函数的方式编写 vue 组件。
  - 组合式 API (响应式 API `ref()、reactive()`，生命周期钩子`onMounted()、onUnmounted()`，依赖注入`inject()、provide()`)
  - 组合式 API 并不是函数式编程。
- SFC Composition API Syntax Sugar (`<script setup>`)
  - 单文件组合式 API 语法糖(setup 语法糖)
  - 让代码更简洁，性能更好（不需要借助代理对象）。
- Teleport
  - 类似于 React 中的 Portal 传送门组件，指定将组件渲染到某个容器中。
  - 经常用于处理弹窗组件和模态框组件。
  vue

  ```
  <button @click="open = true">打开模态框</button>
  <Teleport to="body">
    <div v-if="open" class="modal">
      <button @click="open = false">关闭</button>
    </div>
  </Teleport>
  ```

- Fragments

  - Fragment（片段）Vue3 中允许组件中包含多个节点。无需引入额外的 DOM 元素。

- Emits Component Option

  - Vue3 中默认绑定的事件会被绑定到根元素上。通过 Emits 属性可将事件从`attrs` 中移除。

- createRenderer API from @vue/runtime-core to create custom renderers

  - 提供自定义渲染器，可以在非 DOM 环境中使用 Vue 的运行时。

- SFC State-driven CSS Variables (`v-bind in <style>`)

  - 在 css 中使用 v-bind 绑定样式

  scss

  ```
  background:v-bind(color);
  ```

- `SFC <style scoped> can now include global rules or rules that target only slotted content`

  - 在作用域样式中可以包含全局规则或只针对插槽内容的规则

  scss

  ```scss
  /* 跨组件修改组件内样式 */
  .parent :deep(h1) {
    color: red;
  }
  /* 控制全局样式 */
  :global(.root) {
    width: 100px;
    height: 100px;
    background: yellow;
  }
  /* 控制插槽内容的样式 */
  :slotted(.child) {
    color: red;
  }
  ```

- `Suspense experimental`

  - 主要的作用优雅地处理异步组件的加载状态

  vue

  ```vue
  <Suspense>
      <template #default>
          <!-- 可以配合async setup使用 -->
          <AsyncComponent></AsyncComponent>
      </template>
      <template #fallback>
          正在加载异步组件...
      </template>
  </Suspense>
  ```



## Vue3 对⽐ Vue2 的变化？

- 性能优化（更快）：
  - 使用了**Proxy**替代 Object.defineProperty 实现响应式。（为什么？defineProperty 需要对属性进行递归重写添加`getter`及`setter` **性能差**，同时新增属性和删除属性时无法监控变化，需要$set、$delete 方法。此方法对数组劫持性能差，同时不支持 map 和 set 的数据结构。）
  - 模板编译优化。给动态节点增添 PatchFlag 标记；对静态节点进行静态提升；对内联事件进行缓存处理等。
  - Diff 算法优化，全量 diff 算法中采用最长递增子序列减少节点的移动。在非全量 diff 算法中只比较动态节点，通过 PatchFlag 标记更新动态的部分。
- 体积优化（更小）:
  - Vue3 移除了不常用的 API
    - 移除 inline-template (Vue2 中就不推荐使用)
    - $on、$off、$once （如果有需要可以采用 mitt 库来实现）全局事件总线机制
    - 删除过滤器 （可以通过计算属性或者方法来实现）
    - $children移除 （可以通过provide，inject方法构建$children）
    - 移除`.sync` `.native`)修饰符 (`.sync`通过 `v-model:xxx`实现，`.native`为 Vue3 中的默认行为) 以及不在支持 keycode 作为`v-on`修饰符（@keyup.13 不在支持）
    - 移除全局 API。Vue.component、Vue.use、Vue.directive (将这些 api 挂载到实例上)
  - 通过构建工具 Tree-shaking 机制实现按需引入，减少用户打包后体积。
- 支持自定义渲染器：
  - 用户可以自定义渲染 API 达到跨平台的目的。扩展能力更强，无需改造 Vue 源码。
- TypeScript 支持：
  - Vue3 源码采用 Typescript 来进行重写 , 对 Ts 的支持更加友好。
- 源码结构变化：
  - Vue3 源码采用 monorepo 方式进行管理，将模块拆分到 package 目录中，解耦后可单独使用。



## 如何看待 Composition API 和 Options API?

- 在 Vue2 中采用的是 OptionsAPI, 用户提供的 data,props,methods,computed,watch 等属性 (用户编写复杂业务逻辑会出现反复横跳问题)
- Vue2 中所有的属性都是通过`this`访问，`this`存在指向明确问题
- Vue2 中很多未使用方法或属性依旧会被打包，并且所有全局 API 都在 Vue 对象上公开。Composition API 对 tree-shaking 更加友好，代码也更容易压缩。
- 组件逻辑共享问题， Vue2 采用 mixins 实现组件之间的逻辑共享； 但是会有数据来源不明确，命名冲突等问题。 Vue3 采用 CompositionAPI 提取公共逻辑非常方便

![image-20230616151243860](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20230616151243860.png)

> 将同一个逻辑的相关代码收集在一起，并且可复用。



## Vue 中的 v-show 和 v-if 怎么理解？

### 1.1 基本概念

- v-if 如果条件不成立不会渲染当前指令所在节点的 dom 元素

- v-show 只是切换当前 dom 的显示或者隐藏 display、opacity、visiviblity

  

*在切换时会记录原始的diplay属性。*

*opacity:0 占位 可以进行DOM事件监听*

*visibility:hidden 占据页面空间*  *鼠标事件不监听，其它监听*

*display:none; 不占位, 无法进行DOM事件监听。*

### 1.2 效果展示

[Vue2 模板编译](https://v2.template-explorer.vuejs.org/) 、[Vue3 模板编译](https://template-explorer.vuejs.org/)

### 1.3 如何选择

- `v-if` 可以阻断内部代码是否执行，如果条件不成立不会执行内部逻辑
- 如果页面逻辑在第一次加载的时候已经被确认后续不会频繁更改则采用 `v-if`



## v-if 和 v-for 哪个优先级更高？

v-for 和 v-if 避免在同一个标签中使用。如果遇到需要同时使用时可以考虑写成计算属性的方式。

html

```html
<!--应当避免这种写法-->
<li v-for="l in arr" v-if="exists"></li>
```

- 在 Vue2 中解析时，先解析 v-for 在解析 v-if。会导致先循环后在对每一项进行判断，浪费性能。
- 在 Vue3 中 v-if 的优先级高于 v-for。

[Vue2 解析结果分析](https://v2.template-explorer.vuejs.org/#<%2Fli><%2Fdiv>) 、[Vue3 解析结果分析](https://vue-next-template-explorer.netlify.app/#eyJzcmMiOiI8bGkgdi1mb3I9XCJsIGluIGFyclwiIHYtaWY9XCJleGlzdHNcIj48L2xpPiIsIm9wdGlvbnMiOnt9fQ==)



## v-once 的使用场景有哪些

#### 1.1 v-once 概念

`v-once`是 Vue 中内置指令，只渲染元素和组件**一次**。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。

#### 1.2 v-once 使用场景

html

```html
<!-- 单个元素 -->
<span v-once>This will never change: {{msg}}</span>
<!-- 有子元素 -->
<div v-once>
  <h1>comment</h1>
  <p>{{msg}}</p>
</div>
<!-- 组件 -->
<my-component v-once :comment="msg"></my-component>
<!-- `v-for` 指令-->
<ul>
  <li v-for="i in list" v-once>{{i}}</li>
</ul>
```

> vue3.2 之后，增加了`v-memo`指令，通过依赖列表的方式控制页面渲染。

html

```html
<div>
  <div v-memo="[valueA,valueB]">
    <div class="box" v-for="item in arr" :key="item">{{ item }}</div>
  </div>
</div>
```



## Vue 的生命周期方法有哪些？一般在哪一步发送请求及原因



### Vue2 中的生命周期

主要的生命周期有：创建前后, 挂载前后, 更新前后, 销毁前后

- beforeCreate 初始化父子关系及事件，数据观测(data observer) 之前被调用。用此方法一般编写插件的时候会用到。
- created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法等， 但是这里没有$el，一般也不咋用。
- beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。
- mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。可以用于获取 DOM 元素
- beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。此时修改数据不会再次出发更新方法
- updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。
- beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。
- destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。
- keep-alive (activated 和 deactivated)



### V2 和 V3 中的生命周期对比

| 生命周期 v2   | 生命周期 v3             | 描述                                     |
| :------------ | :---------------------- | :--------------------------------------- |
| beforeCreate  | beforeCreate            | 组件实例被创建之初                       |
| created       | created                 | 组件实例已经完全创建                     |
| beforeMount   | beforeMount             | 组件挂载之前                             |
| mounted       | mounted                 | 组件挂载到实例上去之后                   |
| beforeUpdate  | beforeUpdate            | 组件数据发生变化，更新之前               |
| updated       | updated                 | 数据数据更新之后                         |
| beforeDestroy | **beforeUnmount**       | 组件实例销毁之前                         |
| destroyed     | **unmounted**           | 组件实例销毁之后                         |
| activated     | activated               | keep-alive 缓存的组件激活时              |
| deactivated   | deactivated             | keep-alive 缓存的组件停用时调用          |
| errorCaptured | errorCaptured           | 捕获一个来自子孙组件的错误时被调用       |
| -             | **renderTracked Dev**   | 调试钩子，响应式依赖被收集时调用         |
| -             | **renderTriggered Dev** | 调试钩子，响应式依赖被触发时调用         |
| -             | **serverPrefetch**      | ssr only，组件实例在服务器上被渲染前调用 |

> Vue3 中新增了，组合式 API：生命周期钩子，但是不存在 onBeforeCreate 和 onCreated 钩子

- **`created` 或 `setup` 是发送请求的最佳时机**，因为此时组件已经初始化完成，且无需等待 DOM 渲染。
- **`mounted` 适用于需要依赖 DOM 的场景**。
- 避免在 `beforeDestroy` 或 `destroyed` 中发送请求，因为此时组件即将被销毁，可能无法正确处理响应数据。



## Vue.mixin 的使用场景和原理

### 1.1 Vue.mixin 概念

mixin 可以用来扩展组件，将公共逻辑进行抽离。在需要该逻辑时进行“混入”，采用策略模式针对不同的属性进行合并。如果混入的数据和本身组件中的数据冲突，会采用“就近原则”以组件的数据为准。

> mixin 中有很多缺陷 "命名冲突问题"、"数据来源问题"，Vue3 采用 CompositionAPI 提取公共逻辑非常方便。

**mixins 在 Vue 3 支持主要是为了向后兼容，因为生态中有许多库使用到。在新的应用中应尽量避免使用 mixin，特别是全局 mixin。**

### 1.2 混入方式

在`Vue`中我们可以**局部混入**跟**全局混入**。一般情况下全局混入用于编写插件。局部混入用于复用逻辑。

[vue-router](https://github.com/vuejs/vue-router/blob/dev/src/install.js#L21)[vuex](https://github.com/vuejs/vuex/blob/3.x/src/store.js#L549)

### 1.3 mixin 合并策略

核心就是：对象的合并处理。

- props、methods、inject、computed 同名时会被替换
- data 会被合并
- 生命周期和 watch 方法 会被合并成队列
- components、directives、filters 会在原型链上叠加

> 组件的扩展除了 mixin 之外还有一个属性叫 extends，但是不怎么常用~~~。

## Vue.use 是干什么的？

### 1.1 use 概念

安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入,这样插件中就不在需要依赖 Vue 了。(扩展应用的功能)

### 1.2 插件的功能

- 添加全局指令、全局过滤器(Vue3 不再支持过滤器)、全局组件。
- 通过全局混入来添加一些组件选项。
- 添加实例方法，通过把它们添加到 `Vue.prototype` / `app.config.globalProperties`上实现。

### 1.3 实现原理

js

```js
Vue.use = function (plugin: Function | Object) {
  // 插件缓存
  const installedPlugins =
    this._installedPlugins || (this._installedPlugins = []);
  if (installedPlugins.indexOf(plugin) > -1) {
    // 如果已经有插件 直接返回
    return this;
  }
  // additional parameters
  const args = toArray(arguments, 1); // 除了第一项其他的参数整合成数组
  args.unshift(this); // 将Vue 放入到数组中
  if (typeof plugin.install === "function") {
    // 调用install方法
    plugin.install.apply(plugin, args);
  } else if (typeof plugin === "function") {
    // 直接调用方法
    plugin.apply(null, args);
  }
  installedPlugins.push(plugin); // 缓存插件
  return this;
};
```

> Vue3 中使用[app.use](https://github1s.com/vuejs/core/blob/main/packages/runtime-core/src/apiCreateApp.ts#L256-L257)进行插件的注册，原理同 Vue2~



## 说说你对双向绑定的理解，以及它的实现原理吗？

### 1.1 双向绑定的概念

vue 中双向绑定靠的是指令 v-model，可以绑定一个动态值到视图上，同时修改视图能改变数据对应的值（能修改的视图就是表单组件） 经常会听到一句话：v-model 是 value + input 的语法糖。

### 1.2 表单元素中的 v-model

内部会根据标签的不同解析出不同的语法。并且这里有“额外”的处理逻辑

- 例如 文本框会被解析成 value + input 事件 (同时处理中文输入问题)
- 例如 复选框会被解析成 checked + change 事件
- ...

[v-model](https://github1s.com/vuejs/core/blob/HEAD/packages/runtime-dom/src/directives/vModel.ts#L45-L46)

### 1.3 组件中的 v-model

组件上的 `v-model` 默认会利用名为 `value` 的 prop 和名为 `input` 的事件。对于组件而言 v-model 就是 value + input 的语法糖。可用于组件中数据的双向绑定。

Vue2 中 `v-model` 名字可以修改：

js

```
Vue.component("base-checkbox", {
  model: {
    prop: "checked",
    event: "change",
  },
  props: {
    checked: Boolean,
  },
  template: `
    <input
      type="checkbox"
      v-bind:checked="checked"
      v-on:change="$emit('change', $event.target.checked)"
    >
  `,
});
```

> 那组件中如果有多个数据想做双向数据绑定怎么办？ 很遗憾在 vue2 中不支持使用多个 v-model 的 （使用过时的`.sync`语法）。vue3 中可以通过以下方法进行绑定。

vue

```
<my v-model:a="a" v-model:b="b" v-model:c="c"></my>
```



## Vue.extend 方法的作用？

### 1.1 Vue.extend 概念

使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。

`data` 选项是特例，需要注意 - 在 `Vue.extend()` 中它必须是函数

js

```
var Profile = Vue.extend({
  template: "<p>{{firstName}} {{lastName}} aka {{alias}}</p>",
  data: function () {
    return {
      firstName: "Walter",
      lastName: "White",
      alias: "Heisenberg",
    };
  },
});
// 创建 Profile 实例，并挂载到一个元素上。
new Profile().$mount("#mount-point");

new Vue().$mount();
```

### 1.2 分析

- 所有的组件创建时都会调用`Vue.extend`方法进行创建
- 有了此方法我们可以用于手动挂载组件。
- 后端存储的字符串模板我们可以通过 Vue.extend 方法将其进行渲染，但是需要引入编译时。

### 1.3 Vue3 中手动挂载

> Vue3 中不在使用 `Vue.extend` 方法，而是采用`render`方法进行手动渲染。

html

```
<div id="app"></div>
<script type="module">
  import { render, h, ref } from "./vue.esm-browser.js";
  const App = {
    template: `<div id="counter">{{ count }}</div>`,
    setup() {
      const count = ref(0);
      return { count };
    },
  };
  const app = render(h(App), document.getElementById("app"));
</script>
```



## Vue 组件 data 为什么必须是个函数？

- 根实例对象`data`可以是对象也可以是函数“单例”，不会产生数据污染情况
- 组件实例对象`data`必须为函数，目的是为了防止多个组件实例对象之间共用一个`data`，产生数据污染。所以需要通过工厂函数返回全新的 data 作为组件的数据源

js

```js
function Vue() {}

Vue.extend = function (options) {
  function Sub() {
    // 会将data存起来
    this.data = this.constructor.options.data;
  }
  Sub.options = options;
  return Sub;
};
let Child = Vue.extend({
  data: { name: "xxx" },
});
// 两个组件就是两个实例, 希望数据互不干扰
let child1 = new Child();
let child2 = new Child();

console.log(child1.data.name);
child1.data.name = "jw";
console.log(child2.data.name);
```

> Vue3 一切从组件开始，所以 data 都为函数形式。



## Vue.set 方法是如何实现的？

`Vue2` 不允许在已经创建的实例上动态添加新的响应式属性。所以采用 set API 来进行实现。

typescript

```ts
export function set(targetx, key, val) {
  // 1.是开发环境 target 没定义或者是基础类型则报错
  if (
    process.env.NODE_ENV !== "production" &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(
      `Cannot set reactive property on undefined, null, or primitive value: ${target}`
    );
  }
  // 2.如果是数组 Vue.set(array,1,100); 调用我们重写的splice方法 (这样可以更新视图)
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  // 3.如果是对象本身的属性，则直接添加即可
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }
  // 4.如果是Vue实例 或 根数据data时 报错,（更新_data 无意义）
  const ob = target.__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== "production" &&
      warn(
        "Avoid adding reactive properties to a Vue instance or its root $data " +
          "at runtime - declare it upfront in the data option."
      );
    return val;
  }
  // 5.如果不是响应式的也不需要将其定义成响应式属性
  if (!ob) {
    target[key] = val;
    return val;
  }
  // 6.将属性定义成响应式的
  defineReactive(ob.value, key, val);
  // 通知视图更新
  ob.dep.notify();
  return val;
}
```

> 当我们选择新增属性时，可以考虑使用对象合并的方式实现

javascript

```
this.info = {...this.info,...{newProperty1:1,newProperty2:2...}}
```

> `Vue3` 则采用 proxy 来进行数据劫持，可以直接劫持到属性新增的逻辑，无需采用补丁的方式来进行实现。



## Vue 项目中的错误如何处理的？

### 1.1 errorCaptured 钩子

可以捕获一个来自后代组件的错误时被调用，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。

> 父组件（errorCaptured）-》 子组件（errorCaptured）-》 孙子组件出错时，错误会一直向上抛。如果 errorCaptured 中返回 false 则会阻断传播。

> [错误捕获实现](https://github1s.com/vuejs/vue/blob/main/src/core/util/error.ts#L7-L8)

### 1.2 全局设置错误处理

如果在组件渲染时出现运行错误，错误将会被传递至全局 `config.errorHandler` 配置函数。

js

```js
Vue.config.errorHandler = (err, vm, info) => {
  console.log(err, vm, info);
};
```

### 1.3 接口异常处理

js

```js
instance.interceptors.response.use(
  (res) => {
    return res.data;
  },
  (err) => {
    let res = err.response;
    if (res.status >= 400) {
      handleError(response); // 统一处理接口异常
    }
    return Promise.reject(error);
  }
);
```

> 收集到错误后，提交到前端监控系统中，这样我们可以分析前端代码的异常信息啦。



## Vue 中.sync 修饰符的作用？

在有些情况下，我们可能需要对一个 prop 进行“双向绑定”，这时可以使用`.sync`来实现。`v-model`默认只能双向绑定一个属性，这里就可以通过`.sync`修饰符绑定多个属性。

vue

```
<my :value.sync="xxxx"></my>
<!--编译的结果是 
with(this){
    return _c('my',{
        attrs:{"value":xxxx},
        on:{"update:value":function($event){xxxx=$event}}
    })
}-->
```

> vue3 中`.sync` 语法被移除。



## 如何理解 reactive、ref 、toRef 和 toRefs？

- **reactive:**：将一个普通对象转换为响应式对象。(采用 new Proxy 进行实现) 通过代理对象访问属性时会进行依赖收集，属性更新时会触发依赖更新。
- **ref:** 创建一个包装对象（Wrapper Object）将一个简单的值包装成一个响应式对象，当访问`value`属性时会进行依赖收集，更新`value`属性时会触发依赖更新。(采用类访问器实现) *内部是对象的情况会采用 reactive 来进行处理*
- **toRef:**：创建`ref`对象，引用`reactive`中的属性。
- **toRefs:**：批量创建`ref`对象，引用`reactive`中的属性。



## watch 和 watchEffect 的区别？

- watchEffect 立即运行一个函数，然后被动地追踪它的依赖，当这些依赖改变时重新执行该函数。
- watch 侦测一个或多个响应式数据源并在数据源变化时调用一个回调函数。

**effect 原理**

html

```
<script type="module">
  import {
    ReactiveEffect,
    reactive,
  } from "./node_modules/vue/dist/vue.esm-browser.js";
  const state = reactive({ name: "jw" });
  const effect = new ReactiveEffect(
    // getter
    () => {
      return state.name;
    },
    // scheduler
    () => {
      console.log("数据变化");
    }
  );
  effect.run();
  state.name = "shui";
</script>
```

**基于 effect 进行包装**

js

```js
// getter函数
watchEffect(() => {
  app.innerHTML = state.name; // 数据变化后，会调用scheduler内部会再次触发effect.run()重新运行getter
});

// 1.getter 函数   2.cb函数
watch(
  () => state.name, // 数据变化后，会调用scheduler，内部会调用cb
  (newVal, oldVal) => {}
);
```

> [watch 实现原理](https://github1s.com/vuejs/core/blob/main/packages/runtime-core/src/apiWatch.ts#L83-L84)



## computed 和 watch 区别

Vue2 中有三种 watcher (渲染 watcher 、计算属性 watcher、 用户 watcher)
Vue3 中有三种 effect (渲染 effect 、计算属性 effect、 用户 effect)

### 1.1 computed

- 计算属性仅当用户取值时才会执行对应的方法。
- computed 属性是具备缓存的，依赖的值不发生变化，对其取值时计算属性方法不会重新执行。
- 计算属性可以简化模板中复杂表达式。
- 计算属性中不支持异步逻辑。
- computed 属性是可以再模板中使用的。

### 1.2 watch

watch 则是监控值的变化，当值发生变化时调用对应的回调函数。经常用于监控某个值的变化，进行一些操作。（异步要注意竞态问题。）

vue

```
<template>
  <div>
    <input v-model="value" />
    {{ result }}
  </div>
</template>
<script>
export default {
  name: "App",
  components: {},
  data() {
    return {
      result: "",
      timer: 3000,
    };
  },
  methods: {
    async getData(newVal) {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve(newVal);
        }, (this.timer -= 1000));
      });
    },
  },
  mounted() {
    let arr = [];
    this.$watch("value", async (newVal, oldValue) => {
      let clear = false;
      while (arr.length > 0) {
        arr.shift()();
      }
      arr.push(() => {
        clear = true; // 利用闭包实现清理操作
      });
      let result = await this.getData(newVal);
      if (!clear) this.result = result;
    });
  },
};
</script>
```

> vue3 提供了 onCleanup 函数，让用户更加方便使用也解决了清理问题。

js

```ts
watch(
    () => this.value,
    async (newVal, oldValue, onCleanup) => {
    let clear = false;
    onCleanup(() => {
        clear = true;
    });
    let result = await this.getData(newVal);
    if (!clear) this.result = result as string;
    }
);
```



## 说说你对 nextTick 的理解？

> 当你在 Vue 中更改响应式状态时，最终的 DOM 更新并不是同步生效的，而是由 Vue 将它们缓存在一个队列中，直到下一个“tick”才一起执行。这样是为了确保每个组件无论发生多少状态改变，都仅执行一次更新。

### 1.Vue2 中的 nextTick

html

```
<div id="app">{{count}}</div>
<script src="./node_modules/vue/dist/vue.js"></script>
<script>
  const vm = new Vue({
    el: "#app",
    data() {
      return { count: 0 };
    },
    mounted() {
      // [渲染watcher，nextTick逻辑，数据更新]
      // 按照执行顺序存放到队列中，最后异步执行。
      this.$nextTick(() => {
        console.log(document.getElementById("app").innerHTML);
      });
      this.count = 100;
    },
  });
</script>
```

> [Vue2 nextTick 实现原理](https://github.com/vuejs/vue/blob/main/src/core/util/next-tick.ts) 优雅降级（Promise、MutationObserver、setImmediate、setTimeout） 这里一般会配合浏览器事件环作为面试题。

### 2.Vue3 中的 nextTick

html

```
<div id="app">{{count}}</div>
<script src="./node_modules/vue/dist/vue.global.js"></script>
<script>
  const App = {
    el: "#app",
    data() {
      return { count: 0 };
    },
    mounted() {
      // 当执行mounted之前会创建一个promise,nextTick会被延迟到这个promise之后执行 (值被改为100后再进行渲染)
      Vue.nextTick(() => {
        console.log(document.getElementById("app").innerHTML);
      });
      this.count = 100;
    },
  };
  const app = Vue.createApp(App);
  app.mount("#app");
</script>
```

> Vue3 中不在考虑 promise 的兼容性，所以 nextTick 的实现原理就是 promise.then 方法。



## Vue 中的过滤器了解吗？过滤器的应用场景有哪些？

过滤器实质不改变原始数据，只是对数据进行加工处理后返回过滤后的数据再进行调用处理，我们也可以理解成纯函数。

html

```
{{ message | filterA("arg1", "arg2") | filterB("arg1", "arg2") }}
```

ts

```ts
Vue.filter("filterA", function (value) {
  // 返回处理后的值
});
Vue.filter("filterB", function (value) {
  // 返回处理后的值
});
```

> 常见场景：单位转换、千分符、文本格式化、时间格式化等操作。 这个写个方法、写个方法不香么？Vue3 果断废弃了过滤器......

html

```html
<p>{{format(number)}}</p>
```

js

```js
const format = (n) => {
  return parseFloat(n).toFixed(2);
};
```



## Vue 中 slot 是如何实现的？什么时候使用它？

### 1.1 什么是插槽？

插槽设计来源于 [Web Components 规范草案](https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md)，利用`slot`进行占位，在使用组件时，组件标签内部内容会分发到对应的 slot 中。

### 1.2 什么时候使用它

通过插槽可以让用户更好的对组件进行扩展和定制化。可以通过具名插槽指定渲染的位置。常用的组件例如：弹框组件、布局组件、表格组件、树组件......

### 1.3 插槽的分类和原理

> 具名插槽，作用域插槽

#### 1）Vue2 插槽实现

- 普通插槽的实现

  vue

  ```vue
  <template>
    <my>
      <h1 slot="title">标题</h1>
      <div slot="content">内容</div>
    </my>
  </template>
  <!-- 
      编译后的结果 
      with(this){ 
        return _c('my',[
          _c('h1',{attrs:{"slot":"title"},slot:"title"},[_v("标题")])
          _c('div',{attrs:{"slot":"content"},slot:"content"},[_v("内容")]) 
        ]) 
      } 
  -->
  ```

  **my.vue**

  vue

  ```
  <template>
    <div>
      <slot name="title"></slot>
      <slot name="content"></slot>
    </div>
  </template>
  <!--
    编译后的结果
    with(this){
      return _c('div',[
        _t("title"),_t("content")
      ])
    }
  -->
  ```

- 作用域插槽

  vue

  ```vue
  <template>
    <my>
      <template v-slot="{ article }">
        <h1>{{ article.title }}</h1>
        <div>{{ article.content }}</div>
      </template>
    </my>
  </template>
  <!--
    with(this) { 
      return _c('my', { 
        scopedSlots: _u([
          { 
            key: "default", 
            fn: function ({ article }) { 
              return [_c('h1', [_v(_s(article.title))]), _c('div',[ _v(_s(article.content)) ])] 
            } 
          }
        ]) 
      }) 
    }
  -->
  ```

  vue

  ```vue
  <template>
    <div>
      <slot :article="{ title: '标题', content: '内容' }"></slot>
    </div>
  </template>
  <!--
    编译后的结果
    with(this){
      return _c('div',[_t("default",null,{"article":{title:'标题',content:'内容'}})])
    }
  -->
  ```

> 普通插槽，渲染在父级， 作用域插槽在组件内部渲染！

#### 2）Vue3 插槽实现

vue

```vue
<template>
  <my>
    <template #default="{ article }">
      <h1>{{ article.title }}</h1>
      <div>{{ article.content }}</div>
    </template>
  </my>
</template>
<!--
export function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_my = _resolveComponent("my")
  return (_openBlock(), _createBlock(_component_my, null, {
    default: _withCtx(({ article }) => [
      _createElementVNode("h1", null, _toDisplayString(article.title), 1 /* TEXT */),
      _createElementVNode("div", null, _toDisplayString(article.content), 1 /* TEXT */)
    ]),
  }))
}
-->
```

vue

```vue
<template>
  <div>
    <slot :article="{ title: '标题', content: '内容' }"></slot>
  </div>
</template>
<!--
  export function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (_openBlock(), _createElementBlock("div", null, [
      _renderSlot(_ctx.$slots, "default", { article: { title: '标题', content: '内容' } })
    ]))
  }
-->
```



## Vue 中如何进行组件通信？

Vue3 通信方式：

- props 父子间通信
- $attrs 父子间通信
- $emit 子父通信
- expose / ref / $parent 实例通信
- v-model 数据同步
- provide / inject 跨级通信
- slot ui 通信
- Vuex/pinia 状态管理
- mitt 发布订阅通信（事件总线）



## Vue 中异步组件的作用及原理

> 在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。主要采用`ES 模块动态导入`配合 Vite 和 Webpack 这样的构建工具实现打包时的代码分割。

### Vue2 异步组件的写法

- 回调写法

  js

  ```
  {
    components: {
      "my-component": (resolve, reject) =>  {
        setTimeout(function () {
            resolve({
                render(h){
                    return h('div','hello')
                },
            });
        }, 1000);
      },
    },
  }
  ```

- Promise 写法

  js

  ```
  {
    components: {
      "my-component": () => import(/* webpackChunkName:"B4" */ "./components/B4.vue"),
    },
  }
  ```

- 对象写法

  js

  ```js
  const AsyncComponent = () => ({
    // 需要加载的组件 (应该是一个 `Promise` 对象)
    component: import("./MyComponent.vue"),
    // 异步组件加载时使用的组件
    loading: LoadingComponent,
    // 加载失败时使用的组件
    error: ErrorComponent,
    // 展示加载时组件的延时时间。默认值是 200 (毫秒)
    delay: 200,
    // 如果提供了超时时间且组件加载也超时了，则使用加载失败时使用的组件。默认值是：`Infinity`
    timeout: 3000,
  });
  ```

**异步组件原理**

- 默认渲染异步占位符节点
- 组件加载完毕后调用 $forceUpdate 强制更新，渲染加载完毕后的组件。

[Vue2 异步组件实现原理](https://github1s.com/vuejs/vue/blob/main/src/core/vdom/create-component.ts#L133-L134)



## Vue 组件中写 name 选项有哪些好处及作用？

- 标识组件： 通过设置组件的 name 选项，可以为每个组件指定一个独特的名称，这有助于在开发和调试过程中准确标识和定位组件。
- Vue 开发者工具中的组件树显示时：Vue 开发者工具将以树形结构显示组件层次结构，每个组件都以其 name 显示在树中。
- 递归组件： 当你在 Vue.js 中创建递归组件，通常需要使用 name 选项来标识组件。这样 Vue.js 能够正确地识别和渲染递归组件。
- 组件抛出的警告追踪栈信息： 当 Vue.js 组件在内部出现错误时，Vue.js 通常会抛出警告，并提供详细的追踪栈信息以帮助定位和解决问题。



### Vue3 异步组件写法

使用`defineAsyncComponent`函数定义异步组件。这个函数接受一个工厂函数，工厂函数可以返回一个 Promise，当 Promise 解析后，组件将被加载并渲染。推荐的做法是将异步组件和 工程化工具 的 code-splitting 功能一起配合使用。

js

```js
import { defineAsyncComponent } from "vue";
const AsyncComponent = defineAsyncComponent(() =>
  import("./AsyncComponent.vue")
);
```

js

```js
const AsyncComp = defineAsyncComponent({
  // 加载函数
  loader: () => import("./Foo.vue"),
  // 加载异步组件时使用的组件
  loadingComponent: LoadingComponent,
  // 展示加载组件前的延迟时间，默认为 200ms
  delay: 200,
  // 加载失败后展示的组件
  errorComponent: ErrorComponent,
  // 如果提供了一个 timeout 时间限制，并超时了
  // 也会显示这里配置的报错组件，默认值是：Infinity
  timeout: 3000,
});
```

- 先基于状态，默认渲染异步占位符节点。
- 组件加载完毕后，更新状态，渲染加载完毕的组件。

[Vue3 异步组件实现原理](https://github1s.com/vuejs/core/blob/main/packages/runtime-core/src/apiAsyncComponent.ts#L198-L199)





## keep-alive 平时在哪里使用？

### 1.1 概念

keep-alive 是 vue 中的内置组件，能在组件切换过程会缓存组件的实例，而不是销毁它们。在组件再次重新激活时可以通过缓存的实例拿到之前渲染的 DOM 进行渲染，无需重新生成节点。

### 1.2 使用场景

动态组件可以采用`keep-alive`进行缓存

vue

```vue
<template>
  <keep-alive :include="whiteList" :exclude="blackList" :max="count">
    <component :is="component"></component>
  </keep-alive>
</template>
```

在路由中使用 keep-alive

vue

```vue
<template>
  <!-- vue2写法 -->
  <keep-alive :include="whiteList" :exclude="blackList" :max="count">
    <router-view></router-view>
  </keep-alive>

  <!-- vue3写法 -->
  <router-view v-slot="{ Component }">
    <keep-alive :include="whiteList" :exclude="blackList" :max="count">
      <component :is="Component" />
    </keep-alive>
  </router-view>
</template>
```

也可以通过 meta 属性指定哪些页面需要缓存，哪些不需要

vue

```vue
<template>
  <!-- vue2写法 -->
  <keep-alive>
    <!-- 需要缓存的视图组件 -->
    <router-view v-if="$route.meta.keepAlive"></router-view>
  </keep-alive>
  <!-- 不需要缓存的视图组件 -->
  <router-view v-if="!$route.meta.keepAlive"></router-view>

  <!-- vue3写法 -->
  <router-view v-slot="{ Component }">
    <transition>
      <keep-alive>
        <!-- 需要缓存的视图组件 -->
        <component :is="Component" v-if="route.meta.keepAlive" />
      </keep-alive>
      <!-- 不需要缓存的视图组件 -->
      <component :is="Component" v-if="!route.meta.keepalive" />
    </transition>
  </router-view>
</template>
```

### 1.3 原理

##### 1).vue2 原理

js

```js
export default {
  name: 'keep-alive',
  abstract: true, // 不会放到对应的lifecycle
  props: {
    include: patternTypes, // 白名单
    exclude: patternTypes, // 黑名单
    max: [String, Number] // 缓存的最大个数
  },

  created () {
    this.cache = Object.create(null) // 缓存列表
    this.keys = []  // 缓存的key列表
  },

  destroyed () {
    for (const key in this.cache) { // keep-alive销毁时 删除所有缓存
      pruneCacheEntry(this.cache, key, this.keys)
    }
  },

  mounted () { // 监控缓存列表
    this.$watch('include', val => {
      pruneCache(this, name => matches(val, name))
    })
    this.$watch('exclude', val => {
      pruneCache(this, name => !matches(val, name))
    })
  },

  render () {
    const slot = this.$slots.default
    const vnode: VNode = getFirstComponentChild(slot) // 获得第一个组件
    const componentOptions: ?VNodeComponentOptions = vnode && vnode.componentOptions
    if (componentOptions) {
      // check pattern
      const name: ?string = getComponentName(componentOptions)
      const { include, exclude } = this
      if ( // 获取组件名 看是否需要缓存，不需要缓存则直接返回
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }
      const { cache, keys } = this
      const key: ?string = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')
        : vnode.key // 生成缓存的key
      if (cache[key]) { // 如果有key 将组件实例直接复用
        vnode.componentInstance = cache[key].componentInstance
        remove(keys, key)
        keys.push(key) // lru算法
      } else {
        cache[key] = vnode // 缓存组件
        keys.push(key)
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode) // 超过最大限制删除第一个
        }
      }

      vnode.data.keepAlive = true // 在firstComponent的vnode中增加keep-alive属性
    }
    return vnode || (slot && slot[0])
  }
}
```

##### 2).vue3 原理

js

```ts
const KeepAliveImpl: ComponentOptions = {
  name: `KeepAlive`,
  __isKeepAlive: true,

  props: {
    include: [String, RegExp, Array], // 包含需要缓存的组件名称规则
    exclude: [String, RegExp, Array], // 排除不需要缓存的组件名称规则
    max: [String, Number]  // 最大缓存的组件实例数量
  },

  setup(props: KeepAliveProps, { slots }: SetupContext) {
    const instance = getCurrentInstance()!

    const sharedContext = instance.ctx as KeepAliveContext

    // 缓存组件实例的 Map
    const cache: Cache = new Map()
    // 缓存组件实例的键集合
    const keys: Keys = new Set()
    let current: VNode | null = null

    const parentSuspense = instance.suspense

    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement }
      }
    } = sharedContext
    const storageContainer = createElement('div') // 用于存储组件对应DOM的容器
    // 激活组件时调用的方法
    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
      const instance = vnode.component!
      move(vnode, container, anchor, MoveType.ENTER, parentSuspense)
      // ...
    }
    // 失活组件时调用的方法
    sharedContext.deactivate = (vnode: VNode) => {
      const instance = vnode.component!
      move(vnode, storageContainer, null, MoveType.LEAVE, parentSuspense)
      // ...
    }
    // 卸载组件
    function unmount(vnode: VNode) {
      // reset the shapeFlag so it can be properly unmounted
      resetShapeFlag(vnode)
      _unmount(vnode, instance, parentSuspense, true)
    }
    // 处理缓存
    function pruneCache(filter?: (name: string) => boolean) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type as ConcreteComponent)
        if (name && (!filter || !filter(name))) {
          pruneCacheEntry(key)
        }
      })
    }
    // 移除头部缓存
    function pruneCacheEntry(key: CacheKey) {
      const cached = cache.get(key) as VNode
      if (!current || !isSameVNodeType(cached, current)) {
        unmount(cached)
      } else if (current) {
        resetShapeFlag(current)
      }
      cache.delete(key)
      keys.delete(key)
    }

    // 监听 include 和 exclude 属性的变化，然后清理缓存
    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache(name => matches(include, name))
        exclude && pruneCache(name => !matches(exclude, name))
      },
      // prune post-render after `current` has been updated
      { flush: 'post', deep: true }
    )

    // 在渲染后缓存子树
    let pendingCacheKey: CacheKey | null = null
    const cacheSubtree = () => {
      // fix #1621, the pendingCacheKey could be 0
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree))
      }
    }
    onMounted(cacheSubtree)
    onUpdated(cacheSubtree)

    // ...

    return () => {
      // ...
      if (cachedVNode) {
        vnode.el = cachedVNode.el // 复用缓存dom
        vnode.component = cachedVNode.component
        if (vnode.transition) {
          // recursively update transition hooks on subTree
          setTransitionHooks(vnode, vnode.transition!)
        }
        // 避免 vnode 作为新的组件实例被挂载
        vnode.shapeFlag |= ShapeFlags.COMPONENT_KEPT_ALIVE
        // LRU算法
        keys.delete(key)
        keys.add(key)
      } else {
        keys.add(key)
        // prune oldest entry
        if (max && keys.size > parseInt(max as string, 10)) {
          pruneCacheEntry(keys.values().next().value) // 删除缓存中的第一个
        }
      }
      // 避免组件卸载
      vnode.shapeFlag |= ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE

      current = vnode
      return isSuspense(rawVNode.type) ? rawVNode : vnode
    }
  }
}
```

> 核心原理就是缓存 + LRU 算法

### 1.4 keep-alive 中数据更新问题

beforeRouteEnter：在有 vue-router 的项目，每次进入路由的时候，都会执行`beforeRouteEnter`

js

```
beforeRouteEnter(to, from, next){
  next(vm=>{
    vm.getData()  // 获取数据
  })
},
```

actived：在`keep-alive`缓存的组件被激活的时候，都会执行`actived`钩子

js

```
activated(){
	this.getData() // 获取数据
},
```



## 自定义指令的应用场景

### 1.1 指令的概念

Vue 除了内置指令之外，同时 Vue 也允许用户注册自定义指令来对 Vue 进行扩展。指令的目的在于可以将操作 DOM 的逻辑进行复用。

### 1.2 指令的生命周期

- `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
- `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
- `update`：所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前**。指令的值可能发生了改变，也可能没有。
- `componentUpdated`：指令所在组件的 VNode **及其子 VNode** 全部更新后调用。
- `unbind`：只调用一次，指令与元素解绑时调用。

### 1.3 常见的指令编写

- 图片懒加载 v-lazy
- 防抖 v-debounce
- 按钮权限 v-has
- 拖拽指令 v-draggable （mousemove、 mouseup、 monsedown， dragenter、dragover、drop） 可视化拖拽编辑器
- 点击事件处理 v-click-outside

html

```
<div v-click-outside="hide">
  <input type="text" @focus="show" />
  <div v-if="isShow">显示面板</div>
</div>
```

js

```js
Vue.directive(clickOutside, {
  bind(el, bindings, vnode) {
    el.handler = function (e) {
      if (!el.contains(e.target)) {
        let method = bindings.expression;
        vnode.context[method]();
      }
    };
    document.addEventListener("click", el.handler);
  },
  unbind(el) {
    document.removeEventListener("click", el.handler);
  },
});
```



## Vue 常用的修饰符有哪些有什么应用场景？

- 表单修饰符 lazy、trim、number
- 事件修饰符 stop、prevent、self、once、capture、passive、`.native`
- 鼠标按键修饰符 left、right、middle
- 键值修饰符 对 keyCode 处理
- `.sync 修饰符`

> Vue3 中移除 `.sync`、`.native` 修饰符



## 函数组件的优势？

> 函数式组件是一种定义自身没有任何状态的组件的方式。它们很像纯函数：接收 props，返回 vnodes。函数式组件在渲染过程中不会创建组件实例 (也就是说，没有 this)，也不会触发常规的组件生命周期钩子。

在 Vue2 正常组件是通过`Vue.extend`方法进行创建， 函数式组件就是普通的函数，没有 new 的过程。最终就是将返回的虚拟 DOM 变成真实 DOM 替换对应的组件，同时函数式组件不会被记录在组件的父子关系中。

**因此在 Vue2 中函数式组件有以下优势：**

- 性能优化： 函数式组件相对于常规组件在渲染性能上具有优势。由于函数式组件是无状态的，不包含生命周期钩子和实例状态，渲染时的开销更小。
- 没有 this ： 函数式组件不依赖于 this，不再有 this 绑定问题。
- 可读性和维护性： 函数式组件更加简洁和直观。只是一个函数，没有复杂的选项对象和实例属性。这使得代码更易于阅读和维护。
- 易测试： 由于函数式组件是纯函数，因此更容易编写单元测试。

> 但在 Vue3 中因为所有的组件都不用 `new` 了，所以在性能上没有了优势，所以不在建议使用函数组件~



## vue 常见性能优化方式？

- Vue2 中数据层级不易过深，合理设置响应式数据；
- Vue2 非响应式数据可以通过 Object.freeze()方法冻结属性；
- 使用数据时缓存值的结果，不频繁取值；
- 合理设置 Key 属性；
- `v-show` 和 `v-if` 的选取；
- 控制组件粒度 -> Vue 采用组件级更新；
- 采用异步组件 -> 借助构建工具的分包的能力；
- 合理使用`keep-alive` 、`v-once` 进行逻辑优化；



## Vue 项目中你是如何解决跨域的呢？

跨域是浏览器同源策略导致的，这个是浏览器的行为 （协议、主机名、端口的不同都会导致跨域问题）。服务端和服务端之间进行通信是没有跨域问题的。跨域的实现方案有很多种。不过一般常用的就那么几种。

- CORS （Cross-Origin Resource Sharing，跨域资源共享） 由服务端设置，允许指定的客户端访问服务器。
- 构建工具中设置反向代理、使用 Nginx 做反向代理。
- 使用 Websocket 进行通信。
- 搭建 BFF(Backend For Frontend) 层解决跨域问题。



## Vue 项目中有封装过 axios 吗？主要是封装哪方面的？

- 设置请求超时时间。
- 根据项目环境设置请求路径。
- 设置请求拦截，自动添加 Token。
- 设置响应拦截，对响应的状态码或者数据进行格式化。
- 增添请求队列，实现 loading 效果。
- 维护取消请求 token，在页面切换时通过导航守卫可以取消上个页面中正在发送的请求。

js

```js
class AjaxRequest {
  constructor() {
    // development production
    this.baseURL =
      process.env.NODE_ENV !== "production" ? "http://localhost:3000/api" : "/"; // 基础路径
    this.timeout = 3000; // 超时时间
    this.queue = {};
  }
  setInterceptor(instance, url) {
    instance.interceptors.request.use(
      (config) => {
        // 每次请求前 将token 放到请求中
        config.headers.token = localStorage.getItem("token") || "";
        // 每次请求的时候 都拿到一个取消请求的方法
        let Cancel = axios.CancelToken; // 产生一个请求令牌
        config.cancelToken = new Cancel(function (c) {
          store.commit(types.PUSH_TOKEN, c);
        });
        // 只要页面变化 就要去依次调用cancel方法 路由的钩子 beforeEach
        // 显示loading
        if (Object.keys(this.queue).length === 0) {
          this.toast = Toast.$create({
            txt: "正在加载", // 每次显示toast组件时 都叫 正在加载 否则别人把txt的值改了
            time: 0,
          });
          this.toast.show(); // 如果没有请求过 显示loading
        }
        // 请求前 增加请求队列
        this.queue[url] = url; // 存入队列中
        return config;
      },
      (err) => {
        return Promise.reject(err);
      }
    );
    instance.interceptors.response.use(
      (res) => {
        // 响应拦截， 关闭loading
        delete this.queue[url];
        if (Object.keys(this.queue).length === 0) {
          this.toast.hide(); // 当队列被清空隐藏掉即可
        }
        if (res.data.code === 0) {
          return res.data.data;
        } else {
          return Promise.reject(res.data);
        }
      },
      (err) => {
        delete this.queue[url]; //  请求完成后删除对应的url
        if (Object.keys(this.queue).length === 0) {
          this.toast.hide(); // 当队列被清空隐藏掉即可
        }
        return Promise.reject(err);
      }
    );
  }
  request(options) {
    let instance = axios.create();
    let config = {
      ...options,
      baseURL: this.baseURL,
      timeout: this.timeout,
    };
    this.setInterceptor(instance, options.url); // 给这个实例增加拦截功能
    return instance(config); // 返回的是一个promise
  }
}
export default new AjaxRequest();
```



## vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？

- 登录鉴权：用户登录后返回 Token，前端将 Token 保存到本地，作为用户登录的凭证，每次发送请求时会携带 Token，后端会对 Token 进行验证。当页面刷新时我们可以使用 Token 来获得用户权限。
- 访问权限：根据用户是否登录判断能否访问某个页面，通过路由守卫实现判断用户是否有此权限。
- 页面权限：前端配置的路由分为两部分 “通用路由配置” 和 “需要权限的路由配置”。在权限路由中增加访问权限 meta(备注)。用户登录后可得到对应的权限列表，通过权限列表筛查出对应符合的路由信息，最后通过 addRoutes 方法，动态添加路由。
- 按钮权限：按钮权限一般采用自定义指令实现，当用户登录时后端会返回对应的按钮权限，在按钮上使用此指令，指令内部会判断用户是否有此按钮权限，如果没有则会移除按钮。



## 单页应用首屏加载速度慢的怎么解决？

- 使用路由懒加载、异步组件，实现组件拆分，减少入口文件体积大小,优化体验骨架屏
- 抽离公共代码，采用 splitChunks 进行代码分割。
- 组件加载采用按需加载的方式。
- 静态资源缓存，采用 HTTP 缓存 （强制缓存、对比缓存）、使用 localStorage 实现缓存资源。
- 图片资源的压缩，雪碧图、对小图片进行 base64 减少 http 请求。
- 打包时开启 gzip 压缩处理 `compression-webpack-plugin` 插件
- 静态资源采用 CDN 提速。终极的手段
- 使用 SSR 对首屏做服务端渲染。



## Vue 中使用了哪些设计模式?

### 1.**单例模式**

> 单例模式就是整个程序中有且仅有一个实例 (pinia 中的某一个 store)

js

```js
import { useCounterStore } from "./counterStore.js";
// 组件 1
const counterStore1 = useCounterStore();
// 组件 2
const counterStore2 = useCounterStore();
// 在组件1和组件2中使用的是同一个存储实例
```

> store 实现原理

js

```
function useStore(pinia?: Pinia | null, hot?: StoreGeneric): StoreGeneric {
  // ...
  if (!pinia._s.has(id)) {
    if (isSetupStore) { // 缓存实例
      createSetupStore(id, setup, options, pinia)
    } else {
      createOptionsStore(id, options as any, pinia)
    }
  }
  const store: StoreGeneric = pinia._s.get(id)!
  return store as any
}
```

### 2.**工厂模式**

> 传入参数即可创建实例 (`createComponentInstance`)

js

```js
export function createComponentInstance(
  vnode: VNode,
  parent: ComponentInternalInstance | null,
  suspense: SuspenseBoundary | null
) {
  const instance: ComponentInternalInstance = {
    vnode,
    parent,
    suspense,
    // ...
  };
  return instance;
}
```

### 3.**发布订阅模式**

> 订阅者把自己想订阅的事件注册到调度中心，当该事件触发时候，发布者发布该事件到调度中心，由调度中心统一调度订阅者注册到调度中心的处理代码。(`on、emit`)

vue

```vue
<!-- 事件绑定 -->
<MyComponent @myFn="a" @myFn="b"></MyComponent>
<!-- 触发事件 emit("myFn") -->
```

js

```js
export function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_MyComponent = _resolveComponent("MyComponent");
  return (
    _openBlock(),
    _createBlock(
      _component_MyComponent,
      {
        onMyFn: [_ctx.a, _ctx.b], // 订阅
      },
      null,
      8
    )
  );
}
```

### 4.**代理模式**

> *代理模式*给某一个对象提供一个代理对象,并由代理对象控制对原对象的引用。(`toRef`)

js

```ts
class ObjectRefImpl<T extends object, K extends keyof T> {
  public readonly __v_isRef = true

  constructor(
    private readonly _object: T,
    private readonly _key: K,
    private readonly _defaultValue?: T[K]
  ) {}
  // ref.value.key -> 访问原始 object.key
  get value() {
    const val = this._object[this._key]
    return val === undefined ? this._defaultValue! : val
  }

  set value(newVal) {
    this._object[this._key] = newVal
  }

  get dep(): Dep | undefined {
    return getDepFromReactive(toRaw(this._object), this._key)
  }
}
```

### 5.**中介者模式**

> *中介者*是一个行为设计*模式*,通过提供一个统一的接口让系统的不同部分进行通信。 (`pinia`)

### 6.**外观模式**

> 提供了统一的接口，用来访问子系统中的一群接口，以便隐藏底层复杂性。(`baseCompile`)

js

```js
// 可以粗略理解成外观模式 （主要目标是编译而不是隐藏复杂性，但抽象了底层的编译细节）
export function baseCompile(
  template: string | RootNode,
  options: CompilerOptions = {}
): CodegenResult {
  // ...
  // 1.编译
  const ast = isString(template) ? baseParse(template, options) : template;
  const [nodeTransforms, directiveTransforms] =
    getBaseTransformPreset(prefixIdentifiers);
  // 2.转化
  transform(
    ast,
    extend({}, options, {
      prefixIdentifiers,
      nodeTransforms: [
        ...nodeTransforms,
        ...(options.nodeTransforms || []), // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {} // user transforms
      ),
    })
  );
  // 3.生成代码
  return generate(
    ast,
    extend({}, options, {
      prefixIdentifiers,
    })
  );
}
```

### 7.**装饰模式**

> `Vue2`装饰器的用法 （对功能进行增强 @） 古老写法

js

```ts
import { Vue, Component, Prop } from 'vue-property-decorator'

@Component
export default class YourComponent extends Vue {
  @Prop(Number) readonly propA: number | undefined
  @Prop({ default: 'default value' }) readonly propB!: string
  @Prop([String, Boolean]) readonly propC: string | boolean | undefined
}
```

### 8.**策略模式**

> 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案。 (`Vue2中mergeOptions`)

js

```js
function mergeField(key: any) {
  const strat = strats[key] || defaultStrat;
  options[key] = strat(parent[key], child[key], vm, key);
}
return options;

// ...
strats.data = fn1;
strats[hook] = fn2;
strats[type + "s"] = fn3;
strats.watch = fn4;
strats.props = strats.methods = strats.inject = strats.computed = fn5;
strats.provide = fn6;
```

### 9.**观察者模式**

> Vue2 中`watcher`&`dep`的关系，无需用户主动触发更新，状态变化时会自动更新。

js

```ts
export default class Dep {
  addSub(sub: DepTarget) {  // 访问属性时， 订阅对应的watcher
    this.subs.push(sub)
  }
  notify(info?: DebuggerEventExtraInfo) { // 属性变化时，发布对应的watcher
    const subs = this.subs.filter(s => s) as DepTarget[]
    for (let i = 0, l = subs.length; i < l; i++) {
      const sub = subs[i]
      sub.update()
    }
  }
}
```

js

```ts
export default class Watcher implements DepTarget {
  //...更新逻辑
  update() {
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  }
}
```



## Vue-Router 有几种钩子函数，具体是什么及执行流程是怎样的?

三种

**全局导航钩子**

- `router.beforeEach`  全局前置守卫
- `router.beforeResolve` 全局解析守卫
- `router.afterEach` 全局后置钩子(不会接受 next 函数也不会改变导航本身)



**路由独享的守卫**

- `beforeEnter`

  

**组件内钩子**

- `beforeRouteEnter`(在渲染该组件的对应路由被 confirm 前调用)
- `beforeRouteUpdate`(在当前路由改变，但是该组件被复用时调用)
- `beforeRouteLeave`(导航离开该组件的对应路由时调用)



- 导航被触发。
- 在失活的组件里调用 beforeRouteLeave 守卫。
- 调用全局的 beforeEach 守卫。
- 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
- 在路由配置里调用 beforeEnter。
- 解析异步路由组件。
- 在被激活的组件里调用 beforeRouteEnter。
- 调用全局的 beforeResolve 守卫 (2.5+)。
- 导航被确认。
- 调用全局的 afterEach 钩子。
- 触发 DOM 更新。
- 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。

**模拟守卫运行**

js

```js
// 1.实现sleep方法用于延迟
async function sleep(n = 1000) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve();
    }, n);
  });
}
// 2.模拟离开钩子
const routeLeaveGuards = [
  () => {
    console.log("leave1");
    return sleep(3000);
  },
  () => {
    console.log("leave2");
  },
];
// 3.模拟进入钩子
const beforeEachGuards = [
  (next) => {
    console.log("each1");
    setTimeout(() => {
      next();
    }, 10000);
  },
  () => {
    console.log("each2");
  },
];
// 4.当前要运行的钩子，将钩子转化成promise
let guards = [];
function guardToPromiseFn(guard) {
  return () =>
    new Promise((resolve, reject) => {
      const next = resolve;
      let guardReturn = guard(next);
      Promise.resolve(guardReturn).then(next);
    });
}
for (let guard of routeLeaveGuards) {
  guards.push(guardToPromiseFn(guard));
}
// 5.组合钩子
function runGuardQueue(guards) {
  return guards.reduce(
    (promise, guard) => promise.then(() => guard()),
    Promise.resolve()
  );
}
runGuardQueue(guards).then(() => {
  guards = [];
  for (let guard of beforeEachGuards) {
    guards.push(guardToPromiseFn(guard));
  }
  return runGuardQueue(guards);
});
```

> [源码执行流程解析](https://github1s.com/vuejs/router/blob/main/packages/router/src/router.ts#L788-L789)



## Vue-Router 几种模式的区别？

### Hash 模式：

- 工作原理：在 URL 中使用哈希（#）来管理路由。例如，#/home。哈希变化时，浏览器不会重新加载页面，而是根据哈希路径变化更新页面视图。
- 优点：兼容性很好，因为哈希变化不会导致浏览器向服务器发送请求，所以不会出现 404 错误。这使得在旧浏览器和不支持 HTML5 API 的环境中使用很方便。
- 缺点：URL 中有 # 符号，不够美观，不利于 SEO 优化，因为搜索引擎通常不会解析哈希部分的内容。哈希部分的内容也无法被服务器端获取。

### History 模式：

- 工作原理：使用 HTML5 History API 来管理路由，URL 不再需要 # 号。例如，/home，根据路径变化更新页面视图。
- 优点：URL 更美观，不包含 # 符号，对 SEO 友好。
- 缺点：但是强制刷新时，浏览器会向服务器发送请求。需要服务器端的额外配置，以确保在任何路由请求下都返回应用的入口 HTML，否则会导致 404 错误。

### memory 模式：

- 工作原理：适用于不支持浏览器 API 的环境，如服务器端渲染（Server-Side Rendering，SSR）。它不依赖于浏览器历史。

- 用途：通常在服务器端渲染或非浏览器环境中使用

  

## vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？

如果你使用的是 Vue Router 的 history 模式。刷新时会像服务端发起请求，服务端无法响应到对应的资源，所以会出现 404 问题。需要在服务端进行处理将所有请求重定向到你的 Vue 应用的入口文件。

> 配置后服务端不会在出现 404 问题，Vue 应用中要覆盖所有的路由情况。 [配置方式](https://v3.router.vuejs.org/zh/guide/essentials/history-mode.html#后端配置例子)



## 谈一下你对 vuex 的个人理解

#### 1.概念

- Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。采用集中式存储管理应用的所有组件的状态。核心就是解决数据的共享。
- 以相应的规则保证状态以一种可预测的方式发生变化。

![img](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/vuex.png)

#### 2 状态修改

- 组件中 `commit('mutation')` -> 修改状态
- 组件中 `dispatch(action)`(为了解决接口的复用问题，封装公共的逻辑) -> `commit('mutation')` -> 修改状态

#### 3 缺点

Vuex 中 store 只有一份，复杂的数据需要依赖于模块。Vuex 状态是一个树状结构，最终会将模块的状态挂载到根模块上。

- 模块和状态的名字冲突。
- 数据不够扁平化、调用的时候过长。
- 更改状态 mutation 和 action 的选取。
- 模块需要增加 namespaced
- 对 TS 支持并不友好
- 在 Vue3 中使用不支持 composition Api
- ......

#### 4 原理

对于 Vuex3 核心就是通过 new Vue()创建了一个 Vue 实例，进行数据共享。

对于 Vuex4 核心就是通过创建一个响应式对象进行数据共享 `reactive()`

> 在 Vue3 中使用 pinia 进行状态管理，不再使用 Vuex



## 页面刷新后 Vuex 的数据丢失怎么解决？

> Vuex 的数据是保存在前端应用的内存中的，刷新页面会导致内存清空，数据丢失

- 使用持久化存储：将 Vuex 的数据保存到浏览器的本地存储（LocalStorage 或 SessionStorage）也可以采用 `vuex-persistedstate` 持久化插件进行本地存储。
- 每次获取数据前检测 Vuex 数据是否存在，不存在则发请求重新拉取数据，存储到 Vuex 中。

> [插件原理](https://github1s.com/robinvdvleuten/vuex-persistedstate/blob/HEAD/src/index.ts#L29-L30)

- 应用加载时获取存储的状态进行替换。
- 状态变化后将状态同步到浏览器存储中。

**那如何监听 Vuex 中数据的变化？**

- 通过 watch 监控 vuex 中状态变化。
- 通过 store.subscribe （本质也是 watch） 监控状态变化。



## mutation 和 action 的区别

- 在 action 中可以处理异步逻辑，可以获取数据后将结果提交给 mutation，mutation 中则是修改 state。
- 在 action 中可以多次进行 commit 操作，包括 action 中也可以调用 action。
- 在非 mutation 中修改数据，在严格模式下会发生异常
- dispatch 时会将 action 包装成 promise，而 mutation 则没进行包装

### 1.action 异步逻辑

js

```
dispatch (_type, _payload) {
    // ...
    const result = entry.length > 1
    ? Promise.all(entry.map(handler => handler(payload)))
    : entry[0](payload)

    // 最终返回promise
    return new Promise((resolve, reject) => {
        // 等待所有action执行完毕
        result.then(res => {
            // ...
            resolve(res)
        }, error => {
            // ...
            reject(error)
        })
    })
}
```

### 2.严格模式下发生异常

[源码](https://github1s.com/vuejs/vuex/blob/main/src/store-util.js#L271-L277)

js

```js
class Store {
  commit(_type, _payload, _options) {
    this._withCommit(() => {
      // commit 中的处理
      entry.forEach(function commitIterator(handler) {
        handler(payload);
      });
    });
  }
  _withCommit(fn) {
    const committing = this._committing;
    this._committing = true;
    fn(); // 如果函数内部有异步修改状态逻辑，则watch时会报错
    this._committing = committing;
  }
}
```

js

```js
function enableStrictMode(store) {
  watch(
    () => store._state.data,
    () => {
      if (__DEV__) {
        assert(
          store._committing,
          `do not mutate vuex store state outside mutation handlers.`
        );
      }
    },
    { deep: true, flush: "sync" } // 同步监控
  );
}
```



## 有使用过 vuex 的 module 吗？在什么情况下会使用？

使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。

Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。

ts

```ts
const moduleA = {
  state: () => ({ ... }),
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: () => ({ ... }),
  mutations: { ... },
  actions: { ... }
}

const store = createStore({
  modules: {
    a: moduleA,
    b: moduleB
  }
})

store.state.a // -> moduleA 的状态
store.state.b // -> moduleB 的状态
```



## 为什么 Virtual DOM 比原生 DOM 快？

首先这个问题得分场景来说，如果无脑替换所有的 DOM 这种场景来说，Virtual DOM 的局部更新肯定要来的快。但是如果你可以人肉也同样去局部替换 DOM，那么 Virtual DOM 必然没有你直接操作 DOM 来的快，毕竟还有一层 diff 算法的损耗。

## 如何用 JS 模拟 DOM 结构？

DOM

```html
<div id="root">
  <div title="tt1" id="container">张三</div>
  <ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
  </ul>
</div>
```

JS 模拟 DOM

```vue
var vdom = {
  tag: 'div',
  type: 1,
  value: undefined,
  data: {
    id: 'root',
  },
  children: [
    {
      tag: 'div',
      type: 1,
      value: undefined,
      data: {
        title: 'tt1',
        id: 'container'
      },
      children: [
        tag: 'undefined',
        type: 3,
        value: "张三",
        data: undefined,
        children: []
      ]
    },{
      tag: "ul"
      type: 1,
      value: undefined,
      data: {},
      children: [{
        tag: "li",
        type: 1,
        value: undefined,
        data: {},
        children: [
          {
            tag: undefined,
            type: 3,
            value: "1",
            data: undefined,
            children: []
          }
        ]

      },{
        {
          tag: "li",
          type: 1,
          value: undefined,
          data: {},
          children: [
            {
              tag: undefined,
              type: 3,
              value: "2",
              data: undefined,
              children: []
            }
          ]
        },
        {
          tag: "li",
          type: 1,
          value: undefined,
          data: {},
          children: [
            {
              tag: undefined,
              type: 3,
              value: "3",
              data: undefined,
              children: []
            }
          ]
        }
      }]
    }
  ],
};
```



## 





## Vue 和 React 之间的区别

Vue 和 React 的核心区别在于：

**Vue 是开箱即用的渐进式框架，通过模板语法和双向绑定降低开发门槛，适合快速构建中小型应用**。

**React 是灵活的函数式库，依赖 JSX 和单向数据流，强调组合性与运行时优化，更适合大型复杂应用及跨平台开发**。



简而言之：
**Vue 像“自动挡”，简化开发；React 像“手动挡”，提供深度控制**。



- 













### module chunk bundle 分别什么意思，有何区别?

- module： 各个源码文件， webpack 中一切皆模块
- chunk： 多模块合并成的， 如 entry import() splitChunk
- bundle： 最终输出的文件
- ![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/bundle.png)



## 前端代码为何要进行构建和打包?

- 体积更小（Tree-Shaking、压缩、合并），加载更快
- 能够编译高级语言或语法（TS、ES6+、模块化、SCSS）
- 兼容性和错误检查（Polyfill、postcss、eslint）

#### 研发流程方面：

- 统一，高效的开发环境
- 统一的构建流程和产出标准
- 集成公司构建规范（提测、上线等）



## Plugin 与 loader 的区别？

#### loader

- loader 模块转换器， 如 less > css

  loader 是一个打包方案，它是针对于某一个特定类型的文件，webpack 该如何进行打包。本身 webpack 是不知道对于一些文件（jpg，txt，excel）该如何处理的，但是 loader 知道。 所以 webpack 去求助 loader 就可以啦。

- Plugin

  plugin 扩展插件，如 HtmlWebpackPlugin

  在我们做打包的时候， 在某一个具体时刻上。 比如说， 当我打包结束后，我要自动生成一个 html 文件， 这时候我们就可以使用一个 html-webpack-plugin 的插件。它会在打包结束后生成 html 文件。

  Plugin 可以在我们打包过程的某个时刻想做一些事情。

## 常见 loader 有哪些？

1. file-loader

   打包图片文件，先将文件转移到打包目录下，再将 dist 中的文件路径返回给 index.js。

1. url-loader

   可以通过图片大小来判断是使用 base64 格式图片还是直接打包成一个图片资源文件。

1. css-loader

   帮我们分析出几个 css 文件的引入关系， 最终将这些 css 文件合并成一段 css。

1. style-loader

   再得到 css-loader 生成的内容后， 会把这段代码挂载到 html 的 head 部分。

1. sass-loader

   sass 文件打包

1. postcss-loader

   自动加厂商前缀

1. babel-loader

   babel 与 webpack 沟通的桥梁，帮你把新版本的 JavaScript 代码转换成老版本浏览器也能理解的代码。

1. ts-loader

   TypeScript 的打包配置， 帮助你在构建过程中编译 TypeScript 文件为 JavaScript 文件。

1. eslint-loader

   可以使团队统一使用一套 eslint





### 常见 plugin 有哪些？

1.  html-webpack-plugin 会在打包结束的时刻， 自动生成一个 html 文件， 并把打包生成的 js 自动注入到这个 html 文件中。
1.  clean-webpack-plugin 打包流程执行前清空 dist 目录
1.  webpack.HotModuleReplacementPlugin 模块热更新
1.  webpack.IgnorePlugin 忽略无用文件
1.  webpack-bundle-analyzer 打包分析
1.  happypack 多进程打包
1.  webpack-parallel-uglify-plugin 多进程压缩 JS
1.  mini-css-extract-plugin 将 CSS 提取为独立的文件
1.  optimize-css-assets-webpack-plugin 压缩 css 代码
1.  workbox-webpack-plugin 实现 PWA，是一种强缓存技术
1.  add-asset-html-webpack-plugin 将 JavaScript 或 CSS 资源添加到 html-webpack-plugin 生成的 HTML 中
1.  webpack.DllPlugin 我们引入了一个 lodash 库， 我们知道这个库的文件它是不会变的， 但是每次打包都会打包它， 我们可以让它只在第一次打包， 下次就不打包了。



## babel 和 webpack 的区别

- babel JS 新语法编译工具， 不关心模块化
- webpack 打包构建工具， 是多个 loader plugin 的集合



## 简述三次握手是什么？

HTTP 协议是使用 TCP 协议作为其传输层协议的，在拿到服务器的 IP 地址后，浏览器客户端会与服务器建立 TCP 连接。该过程包括三次握手：

1. 建立连接时，客户端向服务器**发送请求报文**
2. 服务器收到请求报文后，**如同意连接**，则向客户端**发送确认报文**
3. 客户端收到服务器的确认后，**再次向服务器发出确认报文**，完成连接。

三次握手主要是为了防止已经失效的请求报文字段发送给服务器，浪费资源。



#### 为什么浪费资源？

- 第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
- 第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
- 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

假设没有第三次握手，仅通过两次握手来建立连接的话，可能会发生这种情况：客户端发送了一个连接请求报文，但由于网络问题这个请求被延迟了，所以没有及时得到服务器的响应。于是客户端重新发送请求，并成功建立了连接。当使用完连接并断开后，之前被延迟的那个连接请求报文突然到达了服务器。在这种情况下，如果没有进一步确认（即第三次握手），服务器会认为这是一个新的连接请求并作出响应，尝试建立连接。但实际上，这个请求是过时的，客户端并不期望建立这样一个连接。这将导致服务器为一个无效的、不被需要的连接请求分配资源，等待最终超时，从而造成了资源的浪费。

因此，第三次握手保证了只有在客户端确实希望与服务器建立连接的情况下才会建立连接，避免了由于过期的请求报文导致的不必要的资源预留和浪费。这就是为什么三次握手对于保证TCP连接的可靠性和效率是非常重要的。



## 简述四次挥手是什么？

1. 客户端**想断开连接**，发送消息给服务器
2. 服务器通知客户端已经接收到断开连接请求，但**还没做好断开连接准备（服务器可能还在向客户端发送数据）**
3. 服务器已经**做好断开连接准备**，通知客户端
4. 客户端**发送消息**给服务器，**确定断开连接**，服务器关闭连接



## 输入 URL 到页面渲染的整个流程

#### 一. 首先浏览器根据请求的 URL 交给 DNS 域名解析

DNS 的作用就是通过域名查询到具体的 IP。

在 TCP 握手之前就已经进行了 DNS 查询，这个查询是操作系统自己做的。当你在浏览器中想访问 `www.google.com` 时，会进行一下操作：

- DNS 查询解析的详细过程

过程：`. -> .com -> google.com. -> www.google.com`

1. 首先在**本地域名服务器**中查询 IP 地址
2. 如果没有找到的情况下，本地域名会向**根域名服务器**发送请求
3. 如果根域名服务器也不存在该域名时，本地域名会向**com 顶级域名服务器**发送请求
4. 依次类推下去。直到最后本地域名服务器得到`google`的 IP 地址并把它缓存到本地，供下次查询使用。

#### 二. 接下来是 TCP 三次握手：

1. 得到 ip 地址后向服务器**发送请求报文**
2. 服务器收到请求报文后，**如同意连接**，则向客户端**发送确认报文**
3. 客户端收到服务器的确认后，**再次向服务器发出确认报文**，完成连接。

#### 三. 浏览器接收相应的数据后开始解析文件

- 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件。

- 首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。

- 浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。

- 文件解码成功后会正式开始渲染流程：

  - 先会根据 HTML 构建 DOM 树，

  - 有 CSS 的话会去构建 CSSOM 树。

  - 如果遇到 script 标签的话，会判断是否存在 `async` 或者 `defer` ，`async`  会并行进行下载并执行 JS，`defer` 会先下载文件，然后等待 HTML 解析完成后顺序执行。（如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP/2 协议的话会极大的提高多图的下载效率。）

  - CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西。在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。





## 浏览器渲染过程？

> 我们知道执行 JS 有一个 JS 引擎，那么执行渲染也有一个渲染引擎。同样，渲染引擎在不同的浏览器中也不是都相同的。比如在 Firefox 中叫做 **Gecko**，在 Chrome 和 Safari 中都是基于 **WebKit** 开发的。在这一章节中，我们也会主要学习关于 **WebKit** 的这部分渲染引擎内容。



#### 浏览器接收到 HTML 文件并转换为 DOM 树

`字节数据 => 字符串 => Token => Node => DOM`

- 当我们打开网页时，浏览器先去请求对应的 HTML 文件。HTML 只是字符串，计算机不识别，网络传输内容都是`0`和`1`这样的**字节数据**。浏览器会先把**字节数据转换为字符串**，也就是我们写的代码。
- 然后将字符串**语法分析**转换为**标记**（token）。这一过程在词法分析中叫做标记化（tokenization）。
- 标记化后紧接着转换为**Node**
- 然后根据 Node 之间的联系构建成**DOM 树**。
- 在解析 HTML 文件的时候，浏览器还会遇到 CSS 和 JS 文件，这时候浏览器也会去下载并解析这些文件。

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/htmltoken.png)

什么是标记呢？这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，是构成代码的**最小单位**。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。<br />![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/imageabaioqian.png)



#### 将 CSS 文件转换为 CSSOM 树

- 和转化 DOM 树基本相似，浏览器会**先确定每个节点的样式**，样式可以自行设置，也是可以继承的。（**很消耗资源**）
- 浏览器需要**递归 CSSOM** 树，确定元素的具体样式。
- 由于递归过程是很复杂的，我们应该避免写**过于具体**的 CSS 选择器，HTML 也不要添加无意义标签，保证**层级扁平**。

#### 生成渲染树

- 当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。
- 渲染树只会渲染**需要显示的节点**，如果`display: none`就不会显示。
- 然后开始进行布局，（也可以叫做回流），调用 GPU 绘制，合成图层，显示在页面。



## 如何进行性能优化？

1. 如何进行性能优化?

   1.  多使用内存 , 缓存 , 减少 cpu 计算

   - 强缓存表示在缓存期间，不需要请求，`State Code`为 200，`Cache-Control`可以组合使用多个
   - 强缓存可以通过设置`Expires` `Cache-Control`来实现。如果两个都有以后者为准。
   - 协商缓存： 协商缓存表示如果缓存过期了，那么就需要重新发起请求验证资源是否有更新，
   - 可通过设置`HTTP Header`的`Last-Modified`和`ETag`来实现，如果资源没有改变，`State Code`为`304`

   2.  资源压缩 ,合并, 减少 http 请求
   3.  非核心代码异步加载  

   #### 异步加载的方式

   1.  动态脚本加载：动态创建 script 标签添加到页面
   1.  `defer`: 在 html 解析完成执行 , 如果是多个 , 则按照加载顺序执行
   1.  `async`: 加载完成后立即执行 , 如果是多个 , 执行顺序与加载顺序无关

   1.  使用 CDN：

   CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。

   因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。

   5. DNS 预解析

   DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。

   ```html
   <meta http-equiv="x-dns-prefetch-control" content="on" />
   //在https中强制打开a标签预解析
   
   <link rel="dns-prefetch" href="//baidu.com" /> //dns预解析
   ```

   

   ### 图片类:

   1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。
   1. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
   1. 小图使用 base64 格式
   1. 将多个图标文件整合到一张图片中（雪碧图）
   1. 选择正确的图片格式：
      - 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
      - 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
      - 照片使用 JPEG

   

   ### CSS 类:

   1.  css 放在 head 里 (先加载 css 然后渲染 否则渲染两次)
   1.  不使用 css 表达式
   1.  正确使用选择器 (应从右向左匹配 , 避免层级过多 , 扁平化)

   

   ### JS 类:

   1.  JS 放在 body 最下面 (不会阻塞渲染过程 性能优化问题； 再执行 JS script 能拿到所有标签)
   1.  减少 DOM 操作 , 对 DOM 查询进行缓存
   1.  频繁 DOM 操作， 合并到一起插入 DOM 结构
   1.  尽早在 dom 渲染完就执行，用 DOMContentLoaded 触发
   1.  删除不需要的脚本
   1.  节流
   1.  防抖
   1.  预加载:

   - 优点:降低首屏加载时间
   - 缺点:兼容性不好

   如果有些资源需要马上使用，可以使用如下代码实现，预加载不会阻塞`onload`事件

   ```html
   <link rel="preload" href="http://example.com" />
   ```

   9. 预渲染:
      - 要确保用户大概率会打开的资源进行预渲染，可以提升网页的加载速度

   可以通过预渲染将下载的文件预先在后台渲染，

   ```html
   <link rel="prerender" href="http://example.com" />
   ```

   10. 懒加载:

   懒加载就是将不关键的资源延后加载。

   对于图片来说，先设置图片标签的 `src` 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 `src` 属性，这样图片就会去下载资源，实现了图片懒加载。

   懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。

   ```javascript
   var myImage = (function () {
     var imgNode = document.createElement("img");
     document.body.appendChild(imgNode);
     var img = new Image();
     img.onload = function () {
       imgNode.src = img.src;
     };
     return {
       setSrc: function (src) {
         imgNode.src = "loading.gif";
         img.src = src;
       },
     };
   })();
   myImage.setSrc("https://img1.sycdn.imooc.com/5c09123400014ba418720632.jpg");
   ```




## 手写 promise

```js
function Promise(executor) {
  this.status = "pending";
  this.value = null;
  this.reason = null;
  this.onFulfilledArray = [];
  this.onRejectedArray = [];

  const resolve = (value) => {
    if (value instanceof Promise) {
      return value.then(resolve, reject);
    }
    setTimeout(() => {
      if (this.status === "pending") {
        this.value = value;
        this.status = "fulfilled";

        this.onFulfilledArray.forEach((func) => {
          func(value);
        });
      }
    });
  };

  const reject = (reason) => {
    setTimeout(() => {
      if (this.status === "pending") {
        this.reason = reason;
        this.status = "rejected";

        this.onRejectedArray.forEach((func) => {
          func(reason);
        });
      }
    });
  };

  try {
    executor(resolve, reject);
  } catch (e) {
    reject(e);
  }
}

Promise.prototype.then = function (onfulfilled, onrejected) {
  onfulfilled =
    typeof onfulfilled === "function" ? onfulfilled : (data) => data;
  onrejected =
    typeof onrejected === "function"
      ? onrejected
      : (error) => {
          throw error;
        };

  if (this.status === "fulfilled") {
    onfulfilled(this.value);
  }
  if (this.status === "rejected") {
    onrejected(this.reason);
  }
  if (this.status === "pending") {
    this.onFulfilledArray.push(onfulfilled);
    this.onRejectedArray.push(onrejected);
  }
};

let promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("data");
  }, 2000);
});

promise.then((data) => {
  console.log(`1: ${data}`);
});
promise.then((data) => {
  console.log(`2: ${data}`);
});
```



## 如何理解 OSI 七层模型？

OSI（Open Systems Interconnection）七层模型，是理想化的模型，模型将网络通信过程分为七个不同的层次，每个层次都有特定的任务和功能（可以更容易地设计、维护和故障排除）。其目的是将复杂的流程简单化，从而实现**分而治之**。



### 网络分层的含义?

> 下层是为了上层提供服务的。

- 应用层： 用户应用程序和网络服务进行交互，通过不同的应用层协议为不同的网络应用提供服务。（用户最终使用的接口） **常用协议 HTTP、SMTP、FTP、DNS**
- 表示层： 处理数据的格式和编码，以及数据加密、压缩和数据转。
- 会话层： 负责建立、管理和终止通信会话。如会话初始化和维护。
- 传输层：提供端到端的数据传输和错误检测。管理数据的分段、流量控制和可靠传输。 **常用协议 TCP、UDP**
- 网络层：处理数据包的路由和转发，以确保数据在不同网络之间的传输。使用逻辑地址（如 IP 地址）来标识设备和网络。 **常用协议 IP**
- 数据链路层：主要负责数据帧的传输和物理地址的分配。将数据组合成数据帧进行传递 (差错校测，可靠传输)
- 物理层：最底层的层次，处理物理介质和数据传输。（负责比特流的传输，主要是硬件）

![七层网络](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/osi.png)

> OSI 模型是理论上的参考模型，网络通信更常用的是 TCP/IP 模型。



## 如何理解 TCP/IP 协议?

TCP/IP（传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。其中 TCP 和 IP 是核心的两个协议所以用它来命名。

- TCP（传输控制协议）一种面向连接的、可靠的、基于字节流的传输层通信协议
- IP（网际协议）用于封包交换数据网络的协议

> 协议簇中包含众多的协议 `FTP（文件传输协议）`、`DNS（域名系统）`、`SMTP（简单邮件传输协议）`、`HTTP（超文本传输协议）`、`UDP（用户数据报协议）` 、`ICMP(Internet控制消息协议)` 、`ARP(地址解析协议)` 、`DHCP(动态主机配置协议)`、`IGMP(Internet组管理协议)`等

OSI 采用的七层模型(实现起来较困难)； TCP/IP 是四层或五层结构

![img](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20231011161220312.png)



## UDP 与 TCP 的区别是什么？

首先 UDP 协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方。然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且 UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便。

**面向无连接**

首先 UDP 是不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。

并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。

具体来说就是：

- 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
- 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作

**不可靠性**

首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。

并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。

再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。

**高效**

虽然 UDP 协议不是那么的可靠，但是正是因为它不是那么的可靠，所以也就没有 TCP 那么复杂了，需要保证数据不丢失且有序到达。

**传输方式**

UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

**适合使用的场景**

UDP 虽然对比 TCP 有很多缺点，但是正是因为这些缺点造就了它高效的特性，在很多实时性要求高的地方都可以看到 UDP 的身影。

- 直播

  想必大家都看过直播吧，大家可以考虑下如果直播使用了基于 TCP 的协议会发生什么事情？

TCP 会严格控制传输的正确性，一旦有某一个数据对端没有收到，就会停止下来直到对端收到这个数据。这种问题在网络条件不错的情况下可能并不会发生什么事情，但是在网络情况差的时候就会变成画面卡住，然后再继续播放下一帧的情况。

但是对于直播来说，用户肯定关注的是最新的画面，而不是因为网络条件差而丢失的老旧画面，所以 TCP 在这种情况下无用武之地，只会降低用户体验。

- 王者荣耀

  虽然不知道王者荣耀底层使用了什么协议，但是对于这类实时性要求很高的游戏来说，UDP 是跑不了的。

为什么这样说呢？首先对于王者荣耀来说，用户体量是相当大的，如果使用 TCP 连接的话，就可能会出现服务器不够用的情况，因为每台服务器可供支撑的 TCP 连接数量是有限制的。

再者，因为 TCP 会严格控制传输的正确性，如果因为用户网络条件不好就造成页面卡顿然后再传输旧的游戏画面是肯定不能接受的，毕竟对于这类实时性要求很高的游戏来说，最新的游戏画面才是最需要的，而不是老旧的画面，否则角色都不知道死多少次了。

**小结：**

- UDP 相比 TCP 更加简单，不需要**建立连接**，不需要**验证数据报文**，不需要**流量控制**，只会把想发的数据报文一股脑的丢给对端
- UDP 并没有 TCP 传输来的**准确**，但是能在很多实时性要求高的地方有所作为（直播，王者荣耀）



## Get 请求和 Post 请求的区别是什么?主要作用在哪?

1. `get`点击浏览器回退按钮**不会再次提交** , `post`**会再次提交请求**
2. `get`请求会被浏览器主动**缓存** , `post`不会 (除非手动设置)
3. `get`的参数可以保留在浏览器**历史记录** , `post`不会
4. `get`产生的 URL 地址可以被**收藏**，`post`不可以
5. `get`参数通过 url 传递 ，是**明文显示**的, `post`通过`Request body`, `post`传递敏感信息相对更安全
6. `get`传送参数**长度**是有限制的(2kb) , `post`无限制（浏览器规定的长度）
7. `post` 支持更多的**编码类型**, 且不对数据类型限制



## 说说 HTTP 常⻅的状态码有哪些，适⽤场景？

HTTP 状态码是用来表示服务器对客户端请求的响应状态的 3 位数字代码，提供了关于请求处理结果的信息，帮助客户端和开发人员理解服务器的行为。

### 1xx - 信息类（Informational）

- 100：客户端应继续发送请求，服务器用于通知客户端部分请求已被接收。
- 101：服务器根据客户端的请求切换协议，主要用于 WebSocket 或 HTTP/2 升级。

### 2xx - 成功类（Successful）

- 200：请求成功，服务器正确处理了请求并返回了请求的资源。
- 204：请求成功，但服务器没有返回任何内容。通常用于表示操作成功，但不需要返回附加信息。
- 206：表示范围请求（视频，音频文件很大的时候，基本返回的都是 206）

### 3xx - 重定向类（Redirection）

- 301：永久重定向，被分配新的 url
- 302：临时重定向，临时分配新 url
- 304：服务器告诉客户端可以使用缓存的版本，无需重新请求。

### 4xx - 客户端错误类（Client Error）

- 400：客户端请求错误，通常表示请求的语法有问题，服务器无法理解。
- 401：请求未经授权
- 403：请求页面的访问被禁止
- 404：请求的资源不存在，服务器无法找到请求的网页或资源。
- 405：表明客户端尝试使用的 HTTP 请求方法不被服务器允许或支持

### 5xx - 服务器错误类（Server Error）

- 500：服务器遇到错误，无法完成请求。
- 501：服务器不支持当前请求所需的某个功能。
- 503：服务器目前无法使用，通常因超载或维护



## 说说 HTTP 常⻅的请求头有哪些? 作⽤是？

HTTP 头是在 HTTP 请求和响应中包含的元数据信息，用于传递关于消息的附加信息。HTTP 协议定义了一些标准的头字段，这些头字段有明确定义的含义和用途。同时 HTTP 头部字段也可以根据需要自定义。

### 1.内容协商

| 客户端 Header    | 描述                                                 |
| :--------------- | :--------------------------------------------------- |
| Accept           | 用于客户端指定其所期望的响应的媒体类型（即内容类型） |
| Accept- encoding | 客户端指定所需的编码方式。                           |
| Accept- language | 客户端向服务器传递其首选的自然语言或语言区域设置。   |
| Range            | 用于请求服务器发送部分响应内容而不是完整的资源。     |

| 服务端 Header     | 描述                             |
| :---------------- | :------------------------------- |
| Content-Type      | 用于指定响应体的多媒体类型。     |
| Content- Encoding | 用于指定响应主体内容的编码方式。 |
| Content- Range    | 用于指定响应主体内容的部分范围。 |
| Content-Length    | 用于指定响应主体内容的字节长度。 |

### 2.HTTP 缓存

#### 1).强缓存 Expires/ Cache-Control

服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应 header 中。强制缓存存在有效期，缓存期内不会向服务端发送请求。超过时间后需要去服务端验证是否是最新版本。

![cache-control](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20231013232729521.png)

> HTTP/1.1 建议使用 `Cache-Control` 头（Expires 有时间同步问题，受限本地时间），同时设置时`Cache-Control`优先级更高，而且缓存控制更丰富。

- `public`：表示响应可以被共享缓存（如代理服务器）存储。
- `private`：表示响应只能被客户端缓存，不应该被共享缓存存储。
- `max-age`：指定响应可以被缓存的最长时间，以秒为单位。
- `no-store`：表示响应不应被缓存，客户端必须始终从服务器获取最新内容。
- `no-cache`：表示客户端必须在使用缓存之前先验证响应的新鲜度。

#### 2).协商缓存 Last-Modified 和 If-Modified-Since

- 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 `Last-Modified` 被修改，服务端不能命中缓存导致发送相同的资源
- 因为 `Last-Modified` 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

#### 3).协商缓存 ETag 和 If-None-Match

- ETag 可以表示资源内容的更精确的变化，包括内容的任何更改。
- 需要服务器生成和维护 ETag 开销大。

> 绝大多数情况下，采用 ETag（基于最后修改时间和资源长度生成）进行协商缓存是最常见的方式，因为它既减少了计算开销，又提供了足够的准确性。

### 3.客户端常用 Header

- `User-Agent`：用于标识客户端（例如浏览器）的类型和版本。
- `Cookie`：用于在客户端和服务器之间传递状态信息。
- `Authorization`： 用于传递身份验证信息，以允许访问受保护的资源。
- `origin`：浏览器在跨域请求中发送，用于表示请求的来源。
- `referer`：指示当前请求的来源页面的 URL
- `host`：正在请求的服务器的主机名（域名）和端口号
- `Connection`： 用于指示客户端与服务器之间的连接属性，以及如何处理连接。

### 4.服务端常用 Header

- `Server`： 用于标识服务器的软件和版本信息。
- `Date`： 用于指定消息的日期和时间。
- `Location`： 用于执行重定向，指示客户端应该跳转到的新 URL。
- `Set-Cookie`： 用于在客户端上设置和管理会话 cookie。



## HTTP 与 HTTPS 的区别？

- HTTP 协议通常**承载于 TCP 协议**之上，在 HTTP 和 TCP 之间添加一个**安全协议层**（SSL 或 TLS），就成了我们常说的 HTTPS。
- 默认 HTTP 的端口号为`80`，HTTPS 的端口号为`443`。

## 为什么 HTTPS 安全？

因为网络请求需要中间有很多的**服务器路由器的转发**。中间的节点很有可能篡改信息，而如果使用 HTTPS，密钥在你和终点站才有。
https 之所以比 http 安全，是因为他利用了 `ssl/tls` 协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，`refer` 传递等，保障了传输过程的安全性。



## 重绘（Repaint）和回流（Reflow）

重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。

- 重绘(Repaint)是当节点需要更改外观而不会影响布局的，比如改变 `color` 就叫称为重绘
- 回流(Reflow)是布局或者几何属性需要改变就称为回流。

回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

**以下几个动作可能会导致性能问题：**

- 改变 `window` 大小
- 改变字体
- 添加或删除样式
- 文字改变
- 定位或者浮动
- 盒模型

并且很多人不知道的是，重绘和回流其实也和 Eventloop 有关。

1. 当 Eventloop 执行完 Microtasks（微任务） 后，会判断 `document` 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次。
2. 然后判断是否有 `resize` 或者 `scroll` 事件，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 16ms 才会触发一次，并且自带节流功能。
3. 判断是否触发了 media query(媒体查询)
4. 更新动画并且发送事件
5. 判断是否有全屏操作事件
6. 执行 `requestAnimationFrame` 回调
7. 执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
8. 更新界面
9. 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 `requestIdleCallback` 回调。



## 解释一下什么是 Event Loop ？

### 事件循环执行顺序？

![输入图片说明](https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/shijianxunhuan.png)

Event Loop 执行顺序如下所示：

- 首先执行同步代码，这属于宏任务
- 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行
- 执行所有微任务
- 当执行完所有微任务后，如有必要会渲染页面
- 然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数

微任务包括 process.nextTick ，promise ，MutationObserver，其中 process.nextTick 为 Node 独有。
宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。
这里很多人会有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话才会先执行微任务。



## 做一下自我介绍

您好，我叫***，前端开发，有6年的工作经验。之前做的是一个偏向金融的CRM管理系统，主要用的技术栈是Vue。

平时的话也会学习新技术，写写自己的博客之类的。目标是想成为一名全栈工程师。


## 你的职业规划是什么？

近3年的话想深入学习一下python后端方面的知识，包括接触一些AI相关的东西。

长期来说的话也会打算了解一下UI设计，运维相关知识。总之尽量往技术的广度方面去发展。

我是打算在5年之内成为一名成熟的全栈工程师。

## 项目中遇到的困难？

之前我们做过一个pc端打电话的功能。

手机端采用uniApp，pc是网页。两者使用socket进行通信，pc端点击拨打电话后手机进行拨打，然后将通话状态传递给PC端展示。


**第一个难的点就是权限**

为了保证通话录音正常，我们需要获取通话状态、通话记录、通讯录、存储、电池保活等这些权限。

然后就是对不同品牌的手机还要检测自动录音是不是开启了，没开启的话打开对应设置界面。

还有一个是录音文件，它必须拷贝到公共目录进行读取上传。（这里也是折腾了比较久的。）

**还有就是保活，这个是最难的**

（由于安卓新版本对保活控制越来越严格，保活越来越困难。大厂可以通过合作，让手机厂商将其加入到手机系统保活白名单）

一方面我们通过原生安卓的intent来检测是否忽略电池优化，没有忽略的话打开相应设置界面。

还有就是引入一个保活插件提高保活率。（这是一个作者开发的，它里边用了双守护，1像素锁屏显示等来提高保活。）

（未使用：背景音乐保活，常驻通知栏等。）

socket使用心跳检测保证活跃。

**还有一个是系统兼容,这个比较麻烦**

比如华为录音文件lastModified（最后修改时间）为创建时间，其它系统为结束时间。（通过录音时长计算得到录音结束时间，以便匹配录音文件。）

鸿蒙系统录音文件无法读取，需要把targetSdkVersion 降到 28，安卓9。

OPPO只要手机号已经存在联系人里边，录音文件就只有姓名，没有手机号。通过手机号在联系人里边找，找到后在录音文件名称里加上电话号码以便录音文件匹配。）

小米系统默认开启空白通行证后没办法读取通话状态，而且无法检测该权限给用户提示。为了兼容换成读取通话记录，当它多出后认为通话结束。查找录音文件。

**服务器性能：**

三端频繁通信带来的服务器压力，特别是多标签页导致的socket重复连接问题，我们在前端采用了shareWorker技术统一管理socket操作，从而减轻了服务器压力。







## 你的优点和缺点？

- 优点
  - 注重细节。
- 缺点

  - 面对新环境适应的比较慢。

## 你对AI怎么看？

我对AI感受很深，从22年开始用ChatGPT和Copilot，这些工具真的改变了我的工作方式。它们不仅能大幅减少编写简单代码的时间，还能帮我们找到解决复杂问题的新思路。我觉得我们应该尽量多接触AI，无论是直接使用还是结合开发新功能，这里面都是大有可为的。
