# 前端面试题库

:::tip
本文档是学习时的记录，仅作为笔记回顾已学习知识。
:::

## 浏览器：

### HTTP 协议类

#### HTTP 协议的主要特点?

1. 简单快速 (每个资源都是固定的 URI)

2. 灵活 (通过一个 HTTP 协议可以完成不同数据类型的传输)

3. **无连接 (连接一次断掉 , 不会一直连接)**

4. **无状态 (客服端和服务端是两种身份，一次连接后就断开，下次再连接，服务端无法区分两次是否由同一客户端发起的请求)**

#### HTTP 报文的组成部分?

**由请求报文和响应报文组成:**

1. 请求报文：请求行、请求头、空行、请求体

   - 请求行包含：页面地址、http 方法、协议以及版本 (`GET` / `HTTP1.1`)
   - 请求头：就是一些 key\value 值 , **告诉服务端我要什么内容** , 和要注意什么类型
   - 空行：遇到空行就能知道 下面不是请求头的部分了
   - 请求体：数据

2. 响应报文：状态行，响应头、空行、响应体

   - 状态行: HTTP 协议、状态码 (`HTTP1.1`/ `200` ok)
   - 其它都是与请求报文大同小异的

#### HTTP 方法有哪些?

- GET---------获取资源
- POST-------传输资源
- PUT---------更新资源
- DELETE------删除资源
- HEAD--------获取报文首部

####  Get 请求和 Post 请求的区别是什么?主要作用在哪?

1. `get`点击浏览器回退按钮**不会再次提交** , `post`**会再次提交请求**
2. `get`请求会被浏览器主动**缓存** , `post`不会 (除非手动设置)
3. `get`的参数可以保留在浏览器**历史记录** , `post`不会
4. `get`产生的 URL 地址可以被**收藏**，`post`不可以
5. `get`参数通过 url 传递 ，是**明文显示**的, 不能用来传敏感信息 , `post`通过`Request body`, `post`相对更安全
6. `get`传送参数**长度**是有限制的(2kb) , `post`无限制（浏览器规定的长度）
7. `post` 支持更多的**编码类型**, 且不对数据类型限制


#### http首部

首部分为请求首部和响应首部，并且部分首部两种通用。

**通用首部**
![通用首部](https://gitee.com/l544402029/res/raw/master/小书匠/1621410618962.png)

**请求首部**
![请求首部](https://gitee.com/l544402029/res/raw/master/小书匠/1621410593330.png)

**响应首部**
![响应首部](https://gitee.com/l544402029/res/raw/master/小书匠/1621410659764.png)

**实体首部**
![实体首部](https://gitee.com/l544402029/res/raw/master/小书匠/1621410695691.png)


#### 什么是持久链接?

持久连接 `Keep-alive`

非`Keep-ailve`模式时，每个请求/应答客户端和服务器都要新建一个连接，完成后就断开

当`Keep-ailve`模式（又称持久连接、连接重用）时，客户端到服务器端的**连接持续有效**，避免后续请求时，重新建立连接。
并且必须是**http1.1**版本才支持持久连接。

#### 什么是管线化?

- **GET** 和 **HEAD** 可以管线化 ， **POST 是有所限制**
- 初次创建连接时不应该启动管线机制， 因为对方（服务器）不一定支持 HTTP/1.1 版本的协议

持久连接：请求 1 -》响应 1-》请求 2-》响应 2-》请求 3 -》响应 3

管线化：请求 1-》请求 2-》请求 3-》响应 1-》响应 2-》响应 3 把现在的请求一次打包传输过去，响应也是一次性返回过来，并且是在持久连接的情况下完成的， 管线化是通过持久连接完成，仅 HTTP/1.1 支持此技术。

#### HTTP 与 HTTPS 的区别？

- HTTP 协议通常**承载于 TCP 协议**之上，在 HTTP 和 TCP 之间添加一个**安全协议层**（SSL 或 TLS），就成了我们常说的 HTTPS。

- 默认 HTTP 的端口号为`80`，HTTPS 的端口号为`443`。

#### 为什么 HTTPS 安全？

因为网络请求需要中间有很多的**服务器路由器的转发**。中间的节点很有可能篡改信息，而如果使用 HTTPS，密钥在你和终点站才有。 https 之所以比 http 安全，是因为他利用了 `ssl/tls` 协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，`refer` 传递等。保障了传输过程的安全性。

#### 简述三次握手是什么？

HTTP 协议是使用 TCP 协议作为其传输层协议的，在拿到服务器的 IP 地址后，浏览器客户端会与服务器建立 TCP 连接。该过程包括三次握手：

1. 建立连接时，客户端向服务器**发送请求报文**
2. 服务器收到请求报文后，**如同意连接**，则向客户端**发送确认报文**
3. 客户端收到服务器的确认后，**再次向服务器发出确认报文**，完成连接。

三次握手主要是为了防止已经失效的请求报文字段发送给服务器，浪费资源。

#### 简述四次挥手是什么？

1. 客户端**想断开连接**，发送消息给服务器
2. 服务器通知客户端已经接收到断开连接请求，但**还没做好断开连接准备**
3. 服务器已经**做好断开连接准备**，通知客户端
4. 客户端**发送消息**给服务器，**确定断开连接**，服务器关闭连接

#### 为什么 TCP 建立连接需要三次握手，明明两次就可以建立起连接?

为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。

可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求，然后接收数据后释放了连接。
假设这时候连接请求 A 在两端关闭后终于抵达了服务端，那么此时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED(建立了) 状态。但是客户端其实是 CLOSED（关闭） 的状态，那么就会导致服务端一直等待，造成资源的浪费。

#### contenttype 有哪几种类型?

1. `application/json`

2. `text/xml`

3. `multipart/form-data`

4. `application/x-www-form-urlencoded`

#### 如何保持登录状态？

- `cookie`+`session`

`cookie`的特点：`cookie`会伴随每次请求，在浏览器和服务器之间来回传递；

![web端状态保持原理图](https://gitee.com/l544402029/res/raw/master/小书匠/cookie.png)

- `token` 令牌机制

非 web 端，没有 `cookie` ，因此不能用 `cookie` + `sessionid` 这种机制实现状态保持。
但是我们可以借鉴这个实现思路，自己模拟 `cookie` 和 `session` 的机制，`token`机制（令牌机制）。

#### readyState 状态码

- 0 - 未初始化 , 还**没有**调用`send`方法

- 1 - 载入 **已调用**`send`方法,**正在发送请求**

- 2 - 载入完成 `send`方法**执行完成** , 已**接收到全部**响应内容

- 3 - 交互 正在**解析**响应内容

- 4 - 完成 **响应内容解析完成** , 可以在客户端**调用**

#### status 状态码

- 1xx 指示信息

  - 表示请求一接收，继续处理

- 2xx 表示成功处理请求

  - `200`表示客户端请求成功
  - `206`表示范围请求（视频，音频文件很大的时候，基本返回的都是 206）

- 3xx 重定向

  - `301`永久重定向，被分配新的 url
  - `302`临时重定向，临时分配新 url
  - `304`表示使用缓存

- 4xx 客户端请求错误

  - `400`语法错误，不能被服务器所理解
  - `401`请求未经授权
  - `403`请求页面的访问被禁止
  - `404`请求资源不存在

- 5xx 服务器端错误
  - `500`服务器执行请求发生错误
  - `501`服务器不支持当前请求所需的某个功能
  - `503`服务器过载或宕机





#### UDP 与 TCP 的区别是什么？

首先 UDP 协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方。然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便。

**面向无连接**
首先 UDP 是不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。

并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。

具体来说就是：

- 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
- 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作



**不可靠性**

首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。

并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。

再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。

**高效**
虽然 UDP 协议不是那么的可靠，但是正是因为它不是那么的可靠，所以也就没有 TCP 那么复杂了，需要保证数据不丢失且有序到达。

![enter description here](https://gitee.com/l544402029/res/raw/master/小书匠/1621245018759.png)

因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。



UDP 头部包含了以下几个数据

- 两个十六位的端口号，分别为源端口（可选字段）和目标端口
- 整个数据报文的长度
- 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误


**传输方式**
UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

**适合使用的场景**

UDP 虽然对比 TCP 有很多缺点，但是正是因为这些缺点造就了它高效的特性，在很多实时性要求高的地方都可以看到 UDP 的身影。

- 直播
想必大家都看过直播吧，大家可以考虑下如果直播使用了基于 TCP 的协议会发生什么事情？

TCP 会严格控制传输的正确性，一旦有某一个数据对端没有收到，就会停止下来直到对端收到这个数据。这种问题在网络条件不错的情况下可能并不会发生什么事情，但是在网络情况差的时候就会变成画面卡住，然后再继续播放下一帧的情况。

但是对于直播来说，用户肯定关注的是最新的画面，而不是因为网络条件差而丢失的老旧画面，所以 TCP 在这种情况下无用武之地，只会降低用户体验。

- 王者荣耀
虽然不知道王者荣耀底层使用了什么协议，但是对于这类实时性要求很高的游戏来说，UDP 是跑不了的。

为什么这样说呢？首先对于王者荣耀来说，用户体量是相当大的，如果使用 TCP 连接的话，就可能会出现服务器不够用的情况，因为每台服务器可供支撑的 TCP 连接数量是有限制的。

再者，因为 TCP 会严格控制传输的正确性，如果因为用户网络条件不好就造成页面卡顿然后再传输旧的游戏画面是肯定不能接受的，毕竟对于这类实时性要求很高的游戏来说，最新的游戏画面才是最需要的，而不是老旧的画面，否则角色都不知道死多少次了。

**小结：**
- UDP 相比 TCP 更加简单，不需要**建立连接**，不需要**验证数据报文**，不需要**流量控制**，只会把想发的数据报文一股脑的丢给对端
- UDP 并没有 TCP 传输来的**准确**，但是能在很多实时性要求高的地方有所作为（直播，王者荣耀）

#### TCP
TCP 基本是和 UDP 反着来，建立连接断开连接都需要先需要进行握手。在传输数据的过程中，通过各种算法保证数据的可靠性，当然带来的问题就是相比 UDP 来说不那么的高效。

**头部**

![头部](https://gitee.com/l544402029/res/raw/master/小书匠/1621303212692.png)

从这个图上我们就可以发现 TCP 头部比 UDP 头部复杂的多。



对于 TCP 头部来说，以下几个字段是很重要的

- Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文
- Acknowledgement Number，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到
- Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制
- 标识符
    - URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。
    - ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。
    - PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。
    - RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。
    - SYN=1：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。
    - FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。


**状态机**

TCP 的状态机是很复杂的，并且与建立断开连接时的握手息息相关，接下来就来详细描述下两种握手。

![握手](https://gitee.com/l544402029/res/raw/master/小书匠/1621304194808.png)



在这之前需要了解一个重要的性能指标 RTT。该指标表示发送端发送数据到接收到对端数据所需的往返时间。

**建立连接三次握手**


首先假设主动发起请求的一端称为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 是一个全双工的协议。

起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后便进入 LISTEN 状态，此时开始等待客户端发送数据。

**第一次握手**

客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。

**第二次握手**

服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。

**第三次握手**

当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。

PS：第三次握手中可以包含数据，通过快速打开（TFO）技术就可以实现这一功能。其实只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端存储相同的 cookie，下次握手时发出 cookie 达到减少 RTT 的目的。

#### 为什么 TCP 建立连接需要三次握手，明明两次就可以建立起连接？

因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。

可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求，然后接收数据后释放了连接。

假设这时候连接请求 A 在两端关闭后终于抵达了服务端，那么此时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。但是客户端其实是 CLOSED 的状态，那么就会导致服务端一直等待，造成资源的浪费。

PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN Flood 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。

**断开链接四次握手**

![四次挥手](https://gitee.com/l544402029/res/raw/master/小书匠/1621305387092.png)


TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。

**第一次握手**

若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。

**第二次握手**

B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。

**第三次握手**

B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。

PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。

**第四次握手**

A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。

**为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？**

为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。

**ARQ 协议**
ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含停止等待 ARQ 和连续 ARQ 两种协议。

**停止等待 ARQ**

- 正常传输过程

只要 A 向 B 发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。

- 报文丢失或出错

在报文传输的过程中可能会出现丢包。这时候超过定时器设定的时间就会再次发送丢失的数据直到对端响应，所以需要每次都备份发送的数据。

即使报文正常的传输到对端，也可能出现在传输过程中报文出错的问题。这时候对端会抛弃该报文并等待 A 端重传。

PS：一般定时器设定的时间都会大于一个 RTT 的平均时间。

- ACK 超时或丢失

对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报文。这时候 B 端收到相同序号的报文会丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。

在超时的情况下也可能出现应答很迟到达，这时 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。

从上面的描述中大家肯定可以发现这肯定不是一个高效的方式。假设在良好的网络环境中，每次发送数据都需要等待片刻肯定是不能接受的。那么既然我们不能接受这个不那么高效的协议，就来继续学习相对高效的协议吧。

**连续 ARQ**

在连续 ARQ 中，发送端拥有一个**发送窗口**，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率。

- 累计确认
连续 ARQ 中，接收端会持续不断收到报文。如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 标志位可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号后的数据。

但是累计确认也有一个弊端。在连续接收报文时，可能会遇到接收到序号 5 的报文后，并未接收到序号 6 的报文，然而序号 7 以后的报文已经接收。遇到这种情况时，ACK 只能回复 6，这样就会造成发送端重复发送数据的情况。

**滑动窗口**

在上面小节中讲到了发送窗口。在 TCP 中，两端其实都维护着窗口：分别为发送端窗口和接收端窗口。

发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据。

![enter description here](https://gitee.com/l544402029/res/raw/master/小书匠/1621306800248.png)



发送端窗口是由接收窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。

当发送端接收到应答报文后，会随之将窗口进行滑动

![enter description here](https://gitee.com/l544402029/res/raw/master/小书匠/1621306811825.png)



滑动窗口是一个很重要的概念，它帮助 TCP 实现了流量控制的功能。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据，防止出现接收方带宽已满，但是发送方还一直发送数据的情况。

**Zero 窗口**

在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。

**拥塞处理**

拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。

拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。

- 慢开始算法
慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。想必大家都下载过资源，每当我们开始下载的时候都会发现下载速度是慢慢提升的，而不是一蹴而就直接拉满带宽。

慢开始算法步骤具体如下

1. 连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）
2. 每过一个 RTT 就将窗口大小乘二
3. 指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。

- 拥塞避免算法
 
拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。

在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：

1. 将阈值设为当前拥塞窗口的一半
2. 将拥塞窗口设为 1 MSS
3. 启动拥塞避免算法

**快速重传**

快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号。如果发送端收到三个重复的 ACK，无需等待定时器超时而是直接启动快速重传算法。具体算法分为两种：

**TCP Taho 实现如下**

- 将阈值设为当前拥塞窗口的一半
- 将拥塞窗口设为 1 MSS
- 重新开始慢开始算法

**TCP Reno 实现如下**

- 拥塞窗口减半
- 将阈值设为当前拥塞窗口
- 进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段），这种方式在丢失多个包的情况下就不那么好了
- 使用拥塞避免算法


**TCP New Ren 改进后的快恢复**

**TCP New Reno** 算法改进了之前 **TCP Reno** 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。

在 **TCP New Reno** 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。

假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收的话就会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。

**小结**

- 建立连接需要三次握手，断开连接需要四次握手
- 滑动窗口解决了数据的丢包、顺序不对和流量控制问题
- 拥塞窗口实现了对流量的控制，保证在全天候环境下最优的传递数据


### 通信类

#### 什么是同源策略及限制？

- 同源：**协议**，**域名**，**端口**三者必须一致！

同源策略限制两个不同源加载的文档和脚本进行交互，它是一个隔离潜在恶意文件的安全机制。


- 限制：
  - cookie LocalStorage IndexDB 无法获取
  - DOM 无法取得
  - Ajax 不能发送

前端： `http://a.com:8080/`；
server： `https://b.com/api/xxx`

`http` `https`是协议 ， `a.com`是域名 ， 默认端口是`80`。
如上， 协议， 域名， 端口都不相同， 无法发送请求。


#### 为什么浏览器要使用同源策略？

那么是出于什么安全考虑才会引入这种机制呢？ 其实主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求。

也就是说，没有同源策略的情况下，A 网站可以被任意其他来源的 Ajax 访问到内容。如果你当前 A 网站还存在登录态，那么对方就可以通过 Ajax 获得你的任何信息。当然跨域并不能完全阻止 CSRF。

然后我们来考虑一个问题，请求跨域了，那么请求到底发出去没有？ 请求必然是发出去了，但是浏览器拦截了响应。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会。因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。



**加载图片，js，css 可无视同源策略**

- `<img/>`可用于统计打点，可使用第三方统计服务
- `<link/>`、`<script/>`可使用 CDN， CDN 一般都是外域
- `<script/>`可实现 JSONP


#### 你有几种方式可以解决跨域问题？


* JSONP

利用 `<script>` 标签没有跨域限制。通过 `<script>` 标签指向一个需要访问的地址并提供一个回调函数来接收数据。

JSONP 使用简单且兼容性不错，但是只限于 `get` 请求。

```js
<script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
<script>
    function jsonp(data) {
    	console.log(data)
	}
</script>
```

服务器返回的东西类似于以下代码

```
jsonp({})
```

##### 手动封装 SONP

在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP，以下是简单实现:

```js
function jsonp(url, jsonpCallback, success) {
  let script = document.createElement('script');
  script.src = url;
  script.async = true;
  script.type = 'text/javascript';
  window[jsonpCallback] = function (data) {
    success && success(data);
  };
  document.body.appendChild(script);
}
jsonp('https://webapi.amap.com/maps?v=1.4.10&key=76&callback=onmaploaded', 'onmaploaded', function (value) {
  console.log(value);
});
```

**原理：**

1. jsonp 发送的不是 ajax 请求。
2. jsonp 动态创建一个`script`标签， 因为`script`标签是没有同源策略限制的，是可以跨域的。
3. 把这个`script`标签的src指向我们请求的服务端地址， 这个地址会携带一个参数：callback。 一个回调函数 ， 服务端会把数据通过这个回调函数返回给客户端，但是客户端没有这个函数怎么接受呢？ 所以在发送请求之前，要在全局（window）注册这样一个方法， 利用这个方法， 来获得数据。
4. 这个回调函数名需要跟服务器约定好， 是一致的。



* CORS

CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。

浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。


![enter description here](https://gitee.com/l544402029/res/raw/master/小书匠/1582717982532.png)


虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。

- 简单请求
以 Ajax 为例，当满足以下条件时，会触发简单请求

1. 使用下列方法之一：
    - GET
    - HEAD
    - POST
    
    
2. `Content-Type` 的值仅限于下列三者之一：   
    - text/plain
    - multipart/form-data
    - application/x-www-form-urlencoded
    
请求中的任意 `XMLHttpRequestUpload` 对象均没有注册任何事件监听器； `XMLHttpRequestUpload` 对象可以使用 `XMLHttpRequest.upload` 属性访问。

- 复杂请求

那么很显然，不符合以上条件的请求就肯定是复杂请求了。

对于复杂请求来说，首先会发起一个预检请求，该请求是 `option` 方法的，通过该请求来知道服务端是否允许跨域请求。

对于预检请求来说，如果你使用过 Node 来设置 CORS 的话，可能会遇到过这么一个坑

以下以 express 框架举例：

```js
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*')
  res.header('Access-Control-Allow-Methods', 'PUT, GET, POST, DELETE, OPTIONS')
  res.header(
    'Access-Control-Allow-Headers',
    'Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials'
  )
  next()
})
```

该请求会验证你的 Authorization 字段，没有的话就会报错。

当前端发起了复杂请求后，你会发现就算你代码是正确的，返回结果也永远是报错的。因为预检请求也会进入回调中，也会触发 next 方法，因为预检请求并不包含 Authorization 字段，所以服务端会报错。

想解决这个问题很简单，只需要在回调中过滤 option 方法即可

```js
res.statusCode = 204
res.setHeader('Content-Length', '0')
res.end()
```

* postmessage

获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息

```js
// 发送消息端
window.parent.postMessage('message', 'http://test.com');
// 接收消息端
var mc = new MessageChannel();
mc.addEventListener('message', (event) => {
  var origin = event.origin || event.originalEvent.origin;
  if (origin === 'http://test.com') {
    console.log('验证通过');
  }
});
```

- document.domain

该方式只能用于二级域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式。

只需要给页面添加 `document.domain = 'test.com'` 表示二级域名都相同就可以实现跨域

#### Ajax 原理

`Ajax`的原理简单来说是在用户和服务器之间**加了—个中间层(`AJAX`引擎)**，通过`XmlHttpRequest`对象来**向服务器发异步请求**，从服务器**获得数据**，然后用`JS`来**操作`DOM`而更新页面**。使用户操作与服务器响应**异步化**。`XMLHttpRequest`是`ajax`的核心机制。

#### Ajax 具体怎么实现?

```js
let xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
  if (xhr.readyState == 4) {
    try {
      if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
        alert(xhr.responseText);
      } else {
        alert("Request was unsuccessful: " + xhr.status);
      }
    } catch (ex) {
      // 假设由ontimeout处理
    }
  }
};

xhr.open("get", "timeout.php", true);
xhr.timeout = 1000; // 设置1秒超时
xhr.ontimeout = function() {
  alert("Request did not return in a second.");
};
xhr.send(null);
```

### 安全防范

#### 什么是 XSS 攻击？如何防范 XSS 攻击？

基本概念: **跨域脚本攻击**

XSS 简单点来说，就是攻击者将可以执行的代码注入到网页中。

**举例：**

- 一个博客网站, 我发表一篇博客， 其中嵌入`<script>`脚本
- 脚本内容： 获取 cookie ， 发送到我的服务器（服务器配合跨域）
- 发布这篇博客， 有人查看它， 我轻松收割访问者的 cookie

##### 防范:

转义输入输出的内容，对于引号、尖括号、斜杠进行转义

#### 什么是 CSRF 攻击？如何防范 CSRF 攻击？

CSRF , 通常称为**跨站请求伪造**

**原理:**

原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。

举个例子，假设网站中有一个通过 GET 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口

```html
<img src="http://www.domain.com/xxx?comment='attack'"/>
```

那么你是否会想到使用 POST 方式提交请求是不是就没有这个问题了呢？其实并不是，使用这种方式也不是百分百安全的，攻击者同样可以诱导用户进入某个页面，在页面中通过表单提交 POST 请求。


**预防：**

1. Get 请求不对数据进行修改
2. 不让第三方网站访问到用户 `Cookie`
3. 阻止第三方网站请求接口
4. 请求时附带验证信息，比如验证码或者 Token
    1. token 验证：登陆成功后服务器下发 token 令牌存到用户本地，再次访问时要**主动发送 token**，浏览器只能主动发`cookie`，做不到主动发`token`
    2. referer 验证：判断页面来源是否自己站点的页面，不是不执行请求
    3. 隐藏令牌： 令牌放在`http header`头中，而不是链接中 (和`token`类似)
    4. 验证码。
    
    
**SameSite**
可以对 `Cookie` 设置 `SameSite` 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。

**验证 Referer**
对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。

Token
服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。


#### CSRF 与 XSS 的区别：

CSRF 需要用户登陆，利用网站自己的接口漏洞进行攻击

xss 通过注入脚本执行自己的代码


#### 什么是点击劫持？如何防范点击劫持？

点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 `iframe` 嵌套的方式嵌入自己的网页中，并将 `iframe` 设置为透明，在页面中透出一个按钮诱导用户点击。

- X-FRAME-OPTIONS
`X-FRAME-OPTIONS` 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 `iframe` 嵌套的点击劫持攻击。

该响应头有三个值可选，分别是

 - `DENY`，表示页面不允许通过 iframe 的方式展示
 - `SAMEORIGIN`，表示页面可以在相同域名下通过 iframe 的方式展示
 - `ALLOW-FROM`，表示页面可以在指定来源的 iframe 中展示


JS 防御
对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。

```html
<head>
  <style id="click-jack">
    html {
      display: none !important;
    }
  </style>
</head>
<body>
  <script>
    if (self == top) {
      var style = document.getElementById('click-jack')
      document.body.removeChild(style)
    } else {
      top.location = self.location
    }
  </script>
</body>
```
以上代码的作用就是当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。


#### 什么是中间人攻击？如何防范中间人攻击？
中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。

通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。

当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。

### 存储

#### 有几种方式可以实现存储功能，分别有什么优缺点？

cookie，localStorage，sessionStorage，indexDB

我们先来通过表格学习下这几种存储方式的区别:

![存储](https://gitee.com/l544402029/res/raw/master/小书匠/1584256285204.png)

从上表可以看到，`cookie` 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 `localStorage` 和 `sessionStorage` 。对于不怎么改变的数据尽量使用 `localStorage` 存储，否则可以用 `sessionStorage` 存储。

对于`cookie` 来说，我们还需要注意安全性。

![cookie](https://gitee.com/l544402029/res/raw/master/小书匠/1584256604881.png)


### 浏览器渲染原理

#### 输入 URL 到页面渲染的整个流程

##### 一. 首先浏览器根据请求的 URL 交给 DNS 域名解析

DNS 的作用就是通过域名查询到具体的 IP。

因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。

在 TCP 握手之前就已经进行了 DNS 查询，这个查询是操作系统自己做的。当你在浏览器中想访问 `www.google.com` 时，会进行一下操作：

- DNS 查询解析的详细过程

过程：`. -> .com -> google.com. -> www.google.com`

1. 首先在**本地域名服务器**中查询 IP 地址
2. 如果没有找到的情况下，本地域名会向**根域名服务器**发送请求
3. 如果根域名服务器也不存在该域名时，本地域名会向**com 顶级域名服务器**发送请求
4. 依次类推下去。直到最后本地域名服务器得到`google`的 IP 地址并把它缓存到本地，供下次查询使用。

##### 二. 接下来是 TCP 三次握手：

1. 得到 ip 地址后向服务器**发送请求报文**
2. 服务器收到请求报文后，**如同意连接**，则向客户端**发送确认报文**
3. 客户端收到服务器的确认后，**再次向服务器发出确认报文**，完成连接。

##### 三. 浏览器接收相应的数据后开始解析文件

数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件。

首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。

浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。

文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。

如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP/2 协议的话会极大的提高多图的下载效率。

CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西

在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。

- 根据 HTML 构建 DOM 树。

- 有 CSS 的话会去构建 CSSOM 树。

- 如果遇到 script 标签的话，会判断是否存在 `async` 或者 `defer` ，`async`的话并行下载并执行 JS，`defer`的话会先下载文件，然后等待 HTML 解析完成后按顺序执行。

- CSSOM 树和 DOM 树构建完成后结合后生成 Render 树，确定页面元素的布局、样式等。在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将要显示的节点显示在页面。

#### 浏览器渲染过程？

:::tip
我们知道执行 JS 有一个 JS 引擎，那么执行渲染也有一个渲染引擎。同样，渲染引擎在不同的浏览器中也不是都相同的。比如在 Firefox 中叫做 **Gecko**，在 Chrome 和 Safari 中都是基于 **WebKit** 开发的。在这一章节中，我们也会主要学习关于 **WebKit** 的这部分渲染引擎内容。
:::

##### 浏览器接收到 HTML 文件并转换为 DOM 树

`字节数据 => 字符串 => Token => Node => DOM`

- 当我们打开网页时，浏览器先去请求对应的 HTML 文件。HTML 只是字符串，计算机不识别，网络传输内容都是`0`和`1`这样的**字节数据**。浏览器会先把**字节数据转换为字符串**，也就是我们写的代码。
- 然后将字符串**语法分析**转换为**标记**（token）。这一过程在词法分析中叫做标记化（tokenization）。
- 标记化后紧接着转换为**Node**
- 然后根据 Node 之间的联系构建成**DOM 树**。
- 在解析 HTML 文件的时候，浏览器还会遇到 CSS 和 JS 文件，这时候浏览器也会去下载并解析这些文件。

![DOM树](https://gitee.com/l544402029/res/raw/master/小书匠/1620463115865.png)

:::tip
什么是标记呢？？这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，是构成代码的**最小单位**。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。
![标记](https://gitee.com/l544402029/res/raw/master/小书匠/1620462997739.png)
:::

##### 将 CSS 文件转换为 CSSOM 树

- 和转化 DOM 树基本相似，浏览器会**先确定每个节点的样式**，样式可以自行设置，也是可以继承的。（**很消耗资源**）
- 浏览器需要**递归 CSSOM** 树，确定元素的具体样式。
- 由于递归过程是很复杂的，我们应该避免写**过于具体**的 CSS 选择器，HTML 也不要添加无意义标签，保证**层级扁平**。

##### 生成渲染树

- 当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。
- 渲染树只会渲染**需要显示的节点**，如果`display: none`就不会显示。
- 然后开始进行布局，（也可以叫做回流），调用 GPU 绘制，合成图层，显示在页面。

#### 加载一个资源的过程
1.  浏览器根据 DNS 服务器获取域名的 IP 地址
2.  向这个 IP 的服务器发送 http 请求
3.  服务器收到,处理,并返回 http 请求
4.  浏览器得到返回内容



#### 为什么操作 DOM 慢？

想必大家都听过操作 DOM 性能很差，但是这其中的原因是什么呢？

因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了**两个线程之间的通信**，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来**重绘回流**的情况，所以也就导致了性能上的问题。

#### 插入几万个 DOM，如何实现页面不卡顿？

使用[虚拟滚动（virtualized scroller）](https://github.com/bvaughn/react-virtualized)。
这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。

#### 什么情况阻塞渲染?

首先渲染的前提是生成渲染树，所以 **HTML** 和 **CSS** 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的**文件大小**，并且**扁平层级**，**优化选择器**。

然后当浏览器在解析到 `script`标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 `script`标签放在 `body` 标签底部的原因。

当然在当下，并不是说 `script`标签必须放在底部，因为你可以给 `script`标签添加 `defer`或者 `async`属性。

当 `script`标签加上 `defer` 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 `script`标签放在任意位置。

 `async` 属性下载完就立即执行，会阻塞 html 解析


### 性能优化


#### 如何进行性能优化?

1. 多使用内存 , 缓存 , 减少 cpu 计算

   - 强缓存表示在缓存期间，不需要请求，`State Code`为 200，`Cache-Control`可以组合使用多个
   - 强缓存可以通过设置`Expires` `Cache-Control`来实现。如果两个都有以后者为准。

   - 协商缓存： 协商缓存表示如果缓存过期了，那么就需要重新发起请求验证资源是否有更新，
   - 可通过设置`HTTP Header`的`Last-Modified`和`ETag`来实现，如果资源没有改变，`State Code`为`304`

2) 资源压缩 ,合并, 减少 http 请求

3) 非核心代码异步加载

   ##### 异步加载的方式

   1. 动态脚本加载：动态创建 script 标签添加到页面
   2. `defer`: 在 html 解析完成执行 , 如果是多个 , 则按照加载顺序执行
   3. `async`: 加载完成后立即执行 , 如果是多个 , 执行顺序与加载顺序无关

4) 使用 CDN：

CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。

因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。

5. DNS 预解析

DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。

```html
<meta http-equiv="x-dns-prefetch-control" content="on" />
//在https中强制打开a标签预解析

<link rel="dns-prefetch" href="//baidu.com" /> //dns预解析
```

#### 图片类:

1. 修饰类图片用 css

2. 将多个图标文件整合到一张图片中（雪碧图）

3. 选择正确的图片格式

4. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。

5. 小图使用 base64 格式

::: tip
照片使用 JPEG

小图 , 图标 ,背景类使用 png 或者 svg

对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
:::

#### CSS 类:

1. css 放在 head 里 (先加载 css 然后渲染 否则渲染两次)

2. 不使用 css 表达式

3. 正确使用选择器 (应从右向左匹配 , 避免层级过多 , 扁平化)

#### JS 类:

1. JS 放在 body 最下面 (不会阻塞渲染过程 性能优化问题； 再执行 JS script 能拿到所有标签)

2. 减少 DOM 操作 , 对 DOM 查询进行缓存

3. 频繁 DOM 操作， 合并到一起插入 DOM 结构

4. 尽早在 dom 渲染完就执行，用 DOMContentLoaded 触发

5. 删除不需要的脚本


6. 节流:

隔一段时间发送请求:如在用户输入时,用户输入过快会导致一直发送请求,这时候我们可以使用节流函数,使隔一小段时间发送请求.

```js
// func是用户传入需要防抖的函数
// wait是等待时间
const throttle = (func, wait = 50) => {
  // 上一次执行该函数的时间
  let lastTime = 0
  return function(...args) {
    // 当前时间
    let now = +new Date()
    // 将当前时间和上一次执行函数时间对比
    // 如果差值大于设置的等待时间就执行函数
    if (now - lastTime > wait) {
      lastTime = now
      func.apply(this, args)
    }
  }
}

setInterval(
  throttle(() => {
    console.log(1)
  }, 500),
  1
)
```

7. 防抖:
   有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们就可以使用防抖。

```js
// func是用户传入需要防抖的函数
// wait是等待时间
const debounce = (func, wait = 50) => {
  // 缓存一个定时器id
  let timer = 0
  // 这里返回的函数是每次用户实际调用的防抖函数
  // 如果已经设定过定时器了就清空上一次的定时器
  // 开始一个新的定时器，延迟执行用户传入的方法
  return function(...args) {
    if (timer) clearTimeout(timer)
    timer = setTimeout(() => {
      func.apply(this, args)
    }, wait)
  }
}

var btn = document.getElementById('input');
btn.addEventListener(
  'click',
  debounce(function () {
    console.log('发送ajax请求');
  }),
  1000
);
```

8. 预加载:

   - 优点:降低首屏加载时间
   - 缺点:兼容性不好

如果有些资源需要马上使用，可以使用如下代码实现，预加载不会阻塞`onload`事件

```html
<link rel="preload" href="http://example.com" />
```



9. 预渲染:
    - 要确保用户大概率会打开的资源进行预渲染，可以提升网页的加载速度

可以通过预渲染将下载的文件预先在后台渲染，

```html
<link rel="prerender" href="http://example.com" />
```

10. 懒加载:

懒加载就是将不关键的资源延后加载。

对于图片来说，先设置图片标签的 `src` 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 `src` 属性，这样图片就会去下载资源，实现了图片懒加载。

懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。

```js
var myImage = (function () {
  var imgNode = document.createElement('img');
  document.body.appendChild(imgNode);
  var img = new Image();
  img.onload = function () {
    imgNode.src = img.src;
  };
  return {
    setSrc: function (src) {
      imgNode.src = 'loading.gif';
      img.src = src;
    },
  };
})();
myImage.setSrc('https://img1.sycdn.imooc.com/5c09123400014ba418720632.jpg');
```

### 浏览器缓存机制

缓存可以说是性能优化中**简单高效**的一种优化方式了，它可以**显著减少网络传输所带来的损耗。**

对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。

#### 缓存位置

从缓存位置上来说分为四种，并且各自有**优先级**，当依次查找缓存且都没有命中的时候，才会去请求网络

 1. Service Worker
 2. Memory Cache
 3. Disk Cache
 4. Push Cache
 5. 网络请求
 
##### Service Worker
 
 Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。
 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。

 
##### Memory Cache
 
Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存
那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？

先说结论，这是不可能的。首先计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。内存中其实可以存储大部分的文件，比如说 JSS、HTML、CSS、图片等等。但是浏览器会把哪些文件丢进内存这个过程就很玄学了，我查阅了很多资料都没有一个定论。

当然，我通过一些实践和猜测也得出了一些结论：

- 对于大文件来说，大概率是不存储在内存中的，反之优先
- 当前系统内存使用率高的话，文件优先存储进硬盘

##### Disk Cache
Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。

在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。

##### Push Cache
Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。

Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及，但是 HTTP/2 将会是日后的一个趋势。这里推荐阅读  [HTTP/2 push is tougher than I thought](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/) 这篇文章，但是内容是英文的，我翻译一下文章中的几个结论，有能力的同学还是推荐自己阅读

 - 所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好
 - 可以推送 no-cache 和 no-store 的资源
 - 一旦连接被关闭，Push Cache 就被释放
 - 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存
 - Push Cache 中的缓存只能被使用一次
 - 浏览器可以拒绝接受已经存在的资源推送
 - 你可以给其他域名推送资源
 
 
##### 网络请求
如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。

那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，接下来我们就来学习缓存策略这部分的内容。 
 

#### 缓存策略

通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。

##### 强缓存
强缓存可以通过设置两种 HTTP Header 实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，`state code` 为 200。

- Expires
```http
Expires: Wed, 22 Oct 2018 08:41:00 GMT
```
`Expires` 是 HTTP/1 的产物，表示资源会在 `Wed, 22 Oct 2018 08:41:00 GMT` 后过期，需要再次请求。并且 `Expires` **受限于本地时间**，如果修改了本地时间，可能会造成缓存失效。

- Cache-control
```http
Cache-control: max-age=30
```
`Cache-Control` 出现于 HTTP/1.1，**优先级高于** `Expires` 。该属性值表示资源会在 30 秒后过期，需要再次请求。

`Cache-Control` **可以在请求头或者响应头中设置**，并且可以组合使用多种指令

![](https://gitee.com/l544402029/res/raw/master/小书匠/1620460652836.png)



从图中我们可以看到，我们可以将**多个指令配合起来一起使用**，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。

接下来我们就来学习一些常见指令的作用

![](https://gitee.com/l544402029/res/raw/master/小书匠/1620460740234.png)



##### 协商缓存
如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：`Last-Modified` 和 `ETag` 。

当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 304 状态码，并且更新浏览器缓存有效期。

![](https://gitee.com/l544402029/res/raw/master/小书匠/1620460988968.png)


- Last-Modified 和 If-Modified-Since

`Last-Modified` 表示本地文件最后修改日期，`If-Modified-Since` 会将 `Last-Modified` 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。

但是 Last-Modified 存在一些弊端：

- 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 `Last-Modified` 被修改，服务端不能命中缓存导致发送相同的资源
- 因为 `Last-Modified` 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源
因为以上这些弊端，所以在 HTTP / 1.1 出现了 `ETag` 。

- ETag 和 If-None-Match
`ETag` 类似于文件指纹，`If-None-Match` 会将当前 `ETag` 发送给服务器，询问该资源 `ETag` 是否变动，有变动的话就将新的资源发送回来。并且 `ETag` 优先级比 `Last-Modified` 高。

以上就是缓存策略的所有内容了，看到这里，不知道你是否存在这样一个疑问。如果什么缓存策略都没设置，那么浏览器会怎么处理？

对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 `Date` 减去 `Last-Modified` 值的 10% 作为缓存时间。

##### 实际场景应用缓存策略

单纯了解理论而不付诸于实践是没有意义的，接下来我们来通过几个场景学习下如何使用这些理论。

- 频繁变动的资源
对于频繁变动的资源，首先需要使用 `Cache-Control: no-cache` 使浏览器每次都请求服务器，然后配合 `ETag` 或者 `Last-Modified` 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。

- 代码文件
这里特指除了 HTML 外的代码文件，因为 HTML 文件一般不缓存或者缓存时间很短。

一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 `Cache-Control: max-age=31536000`，这样只有当 HTML 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存。


### 前端监控

#### 前端监控一般分为哪几种？

前端监控一般分为三种，分别为页面埋点、性能监控以及异常监控。

#### 前端错误的分类

- 即时运行错误：代码错误
- 资源加载错误

#### 错误的捕获方式

- 即时运行错误：代码错误
  - try..catch
  - window.onerror
- 资源加载错误
  - object.onerror
  - performance.getEntries()
  - Error 事件**捕获**

#### 跨域的 js 运行错误可以捕获吗？错误提示什么？应该怎么处理

![错误捕获](https://gitee.com/l544402029/res/raw/master/小书匠/1587443059574.png)

1. 在 script 标签增加`crossorigin`属性 `<script src="..." crossorigin ></script>`
2. 设置 js 资源响应头 Access-Control-Allow-Origin:\*

#### 上报错误的基本原理

1. 采用 Ajax 通信的方式上报
2. 利用 Image 对象上报

```js
new Image().src = 'http://baidu.com/tesjk?r=tksjk';
```


### 浏览器内核

#### 能介绍一下你对浏览器内核的理解吗？

主要分成两部分：渲染引擎(`layout engineer或Rendering Engine`)和 JS 引擎

- 渲染引擎：

负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。

浏览器的内核的不同对于网页的语法解释会有不同，渲染的效果也会不相同。

- JS 引擎：

解析和执行 javascript 来实现网页的动态效果

### SEO

#### 前端需要注意哪些 SEO?

- 合理的`title`、`keywords` 。`title` 值强调重点即可，不同页面 title 要有所不同，重要关键词出现不要超过 2 次，而且要靠前
- **语义化**的 HTML 代码，符合 W3C 规范，让搜索引擎容易理解网页
- 重要内容 HTML 代码**放在最前**：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
- 重要内容**不要用 js 输出**， 爬虫不会执行 js 获取内容
- **少用`iframe`**，搜索引擎不会抓取 `iframe` 中的内容
- **非装饰性图片**必须加`alt`
- 提高**网站速度**：网站速度是搜索引擎排序的一个重要指标

---

## HTML 相关:

### W3C 标准

#### WEB 标准以及 W3C 标准是什么?

1. 标签闭合
2. 标签小写
3. 不乱嵌套
4. 使用外链 css 和 js
5. 结构行为表现的分离

### 语义化

#### 谈谈你对语义化的理解？

- 用**正确**的标签做正确的事情！

- 语义化就是让页面的**内容结构化**，便于对浏览器、搜索引擎解析。

- 在没有样式 CSS 情况下也以一种**文档格式显**示，并且是容易阅读的。

- **搜索引擎**的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。

- **源代码**更容易阅读、维护、理解。

### xhtml 和 html

- 一个是功能上的差别

  - 主要是 XHTML 可兼容各大浏览器、手机以及 PDA，并且浏览器也能快速正确地编译网页

- 另外是书写习惯的差别
  - XHTML 元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素

### global attribute

#### HTML 全局属性(global attribute)有哪些？

- `id`: 元素 id，文档内唯一
- `class`: 为元素设置类标识
- `style`: 行内 css 样式
- `title`: 元素相关的建议信息
- `lang`: 元素内容的的语言
- `data-*`: 为元素增加自定义属性
- `draggable`: 设置元素是否可拖拽

### HTML5

#### 什么是 DOCTYPE 及作用？

```html
<!DOCTYPE html>
```

- DTD: 定义文档类型，浏览器会根据它来决定用哪种协议来解析以及切换浏览器模式。

- DOCTYPE: 是用来声明文档类型和 DTD 规范的

HTML4.0 有传统模式和严格模式。

传统模式包含所有 HTML 元素和属性，包括展示性和弃用的元素。（如 `font`）

严格模式包含所有 HTML 元素和属性，但不包括展示性和弃用的元素。（如 `font`）

#### HTML5 为什么只需要写 <!DOCTYPE html>？

- HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要`DOCTYPE`来规范浏览器的行为

- 而 HTML4.01 基于 SGML，所以需要对 DTD 进行引用，才能告知浏览器所使用的文档类型

#### html5 有哪些新特性？

HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加

- 绘画 `canvas`
- 用于媒介回放的 `video` 和 `audio` 元素
- 本地离线存储 `localStorage` ,`sessionStorage`
- 语意化更好的内容元素，比如`article`、`footer`、`header`、`nav`、`section`
- 表单控件，`date`、`time`、`email`、`url`、`search`
- 新的技术`webworker`, `websocket`

#### html5 有移除的元素?

- 纯表现的元素：`basefont`，`font`, `big`，`center`，`s`
- 对可用性产生负面影响的元素：`frame`

### Canvas 和 SVG

#### Canvas 和 SVG 有什么区别？

- `svg`输出的图形是**矢量图形**，它绘制出来的每一个图形元素都是独立的 DOM 节点，能够方便的绑定事件或用来修改。,也可以修改参数来自由放大缩小，不会**失真和有锯齿**。
- 而`canvas`输出**标量画布**，就像一张图片一样，放大会失真或者锯齿

---

## CSS:

### css 单位

#### 解释一下 CSS 里的两个单位：em 和 rem，你一般怎么使用它们？

1em，等于本元素的字体大小，所以在不同的元素里1em的绝对大小是不一样的。

而1rem，等于根元素的字体大小，在一个页面中，无论在哪个元素上1rem都是一样的。

em 适合于用在需要大小需要跟随字体变化的属性上，比如padding、margin、height、width等等，元素继承了不同的字体大小，这些属性最好也能跟着变化；
大多数人可能会认为 em 相对于父元素的字体大小，但是实际上取决于应用在什么 CSS 属性上。对于 font-size 来说，em 相对于父元素的字体大小；line-height 中，em 却相对于自身字体的大小。

rem适用于字体，这样就可以通过改变根元素的字体大小来改变整个页面的字体大小。

#### px， em， rem 的区别？

- px是相对长度单位。像素px是相对于显示器屏幕分辨率而言的。
- em是相对长度单位。相对于当前对象内文本的字体尺寸;（参考物是父元素的font-size）。如当前父元素的字体尺寸未设置，则相对于浏览器的默认字体尺寸
- rem是相对于HTML根元素的字体大小（font-size）来计算的长度单位。


#### % 相对于谁

```css
.wp {
    position: relative;
}
.box {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
```

- 第一处 50% 是指 .wrap 相对定位元素宽度和高度的 50%，而 `transform` 中的 50% 是指自身元素的宽高的一半。
- 对于设置绝对定位 `position absolute` 的元素，我们可以使用 `left` `right` 表示其偏移量，我们把这个元素的祖先元素中第一个存在定位属性的元素成为参照物元素，其中的 % 是相对于参照物的，`left` 相对于参照物的 `width`，`top` 相对于这个参照物的 `height`。
- 对于设置相对定位 `position relative` 的元素，% 的数值是相对与自身的，left 相对于自己的 width，top 相对于自己的 height。
- 对于设置固定定位 `position fixed` 的元素，% 的数值是相对于视口的，left 相对于视口的 width，top 相对于视口的 height。
-  `margin` 和 `padding` 当中的 % 非常特殊，它是相对于父元素的宽度。没错，`margin-top: 30%`，相当于父元素宽度的 30%。
-  `font-size` 的 %相对于父元素的字体大小。
-  `line-height` 设置行高时，如果单位为 %，则相对于该元素的 `font-size` 数值。
-  `text-indent` 这个属性可以设置首行缩进，当使用 % 时，它是相对于父元素的 `width`。
-  `border-radius: 50%`得到一个圆形，因此不难发现这里的 % 也是相对于自身宽高的。
-  `background-size` 的百分比和 `border-radius` 一样，也是相对于自身的宽高。
-  `transform` 的 `translate` 属性 % 是相对于自身的宽高，这也是我们上述代码能够实现居中的原因。


### 布局方式

#### 什么是flex？写出常见属性，以及作用？

flex：弹性布局。

常见属性及作用：

- flex-direction属性决定主轴的方向（即项目的排列方向）。
- justify-content属性定义了项目在主轴上的对齐方式。
- align-items属性定义项目在交叉轴上如何对齐。
- align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

项目属性：
- order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
- flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。
- align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。


#### display 有哪些值？说明他们的作用？
- none：  元素不会被显示
- block： 此元素将显示为块级元素，此元素前后会带有换行符。
- inline： 默认。此元素会被显示为内联元素，元素前后没有换行符。
- inline-block： 像行内元素一样显示，但其内容像块类型元素一样显示。可以设置宽高，可以设置margin和padding。
- flex： 弹性盒子布局
- inline-flex：内联的弹性盒子布局
- table： 此元素会作为块级表格来显示（类似 `<table>`），表格前后带有换行符。
- inline-table：	此元素会作为内联表格来显示（类似 `<table>`），表格前后没有换行符。
- table-row： 此元素会作为一个表格行显示（类似 `<tr>`）。
- table-cell：此元素会作为一个表格单元格显示（类似 `<td>` 和 `<th>`）	
- grid： 网格布局
- inherit 规定应该从父元素继承 display 属性的值。


#### 隐藏一个元素有多少种方法？

1. `display:none;`
2. `opacity:0;`
3. `visibility：hidden;`
4. `position:absolute;clip(0,0,0,0);`  
5. `overflow:hidden;`
6. `width: 0px;height: 0px;`

#### `display: none` 与 `visibility: hidden`区别在哪？

联系：它们都能让元素不可见

区别：

1. `display:none`会让元素完全从渲染树中消失，渲染的时候**不占据任何空间**；`visibility: hidden`不会让元素从渲染树消失，渲染元素**继续占据空间**，只是内容不可见
2. `display: none`是**非继承属性**，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；`visibility: hidden`**是继承属性**，子孙节点消失由于继承了 hidden，通过设置`visibility: visible`可以让子孙节点显示
3. 修改常规流中元素的`display`通常会造成文档**回流**。修改`visibility`属性只会造成本元素的**重绘**。
4. **读屏器**不会读取`display: none`元素内容；会读取`visibility: hidden`元素内容


### 浮动

#### 行内元素`float:left`后是否变为块级元素？

浮动后，行内元素不会成为块状元素，但是可以设置宽高。行内元素要想变成块状元素，占一行，直接设置`display:block`。但如果元素设置了浮动后再设置`display:block`那就不会占一行

#### 为什么要清除浮动？

不清除浮动会发生高度塌陷：父元素不写高度时，子元素写了浮动后，父元素会发生高度塌陷。

#### 清除浮动有几种方式？

1. 添加空 div，在浮动元素下方添加空 div，并给该元素写 CSS 样式`clear:both`

   - 优点： 简单，代码少，浏览器支持好，不容易出现怪问题
   - 缺点： 页面浮动布局多，就要增加很多空 div

2. 父级设置高度

   - 优点：简单，代码少
   - 缺点： 只适合高度固定的布局

3. 父级同时浮动（需要给父级同级元素添加浮动）

   - 优点： 无
   - 缺点： 产生新的浮动问题

4. 给父级添加`overflow:hidden` 清除浮动方法

   - 优点： 简单，代码少，浏览器支持好
   - 缺点： 不能和 position 配合使用，因为超出的尺寸的会被隐藏

5. 父级元素定义 after 伪类 （现在主流方法，推荐使用）
   - 优点： 浏览器支持好，不容易出现怪问题
   - 缺点： 代码多

```css
.fix:after {
  content: '';
  display: table;
  clear: both;
}
//兼容ie6,7
.fix {
  *zoom: 1;
}
```


### CSS 盒模型

#### 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？

- 标准模型`width`不计算`padding`和`border`

- IE 模型`width`计算`padding`和`border`。

`box-sizing` : `content-box`(标准模型-默认)/`border-box`(IE 模型)

#### js 中如何获取盒模型宽高?

1. `dom.style.width`（只能取内联宽高)

2. `dom.currentStyle.width` (浏览器渲染之后的取值，只有 IE 支持)
3. `window.getComputedStyle(dom).width` (浏览器渲染之后的取值，兼容性更好)
4. `dom.getBoundingClientRect().width/height/left/top` (常用于计算位置)

### BFC

#### 什么是 BFC?(概念)

块级格式化上下文

#### 对 BFC 规范的理解？

它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用

#### BFC 的原理？

1. 同一BFC内块级元素之间的垂直方向边距会发生重叠。

2. 浮动元素区域不会与 BFC 重叠

3. BFC 在页面上是一个独立的容器，外面的元素不会影响里面的元素，里面的元素也不会影响外面的元素

4. 计算 BFC 高度时，浮动元素也会参与计算

#### 如何创建 BFC？

- `<html>` 根元素。
- `float` 的值不为 `none` 。
- `overflow` 值不为 `visible` 的块元素。
- 绝对定位元素（元素的 `position` 为 `absolute` 或 `fixed`）
- `display` 的值为 `table-cell`、 `table-caption` 和 `inline-block` 中的任何一个。



#### BFC 使用场景?

1. 解决垂直方向的边距重叠

2. 清除浮动


### 重绘（Repaint）和回流（Reflow）

重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。

#### 重绘与回流

- 重绘(Repaint)是当节点需要更改外观而不会影响布局的，比如改变 `color` 就叫称为重绘

- 回流(Reflow)是布局或者几何属性需要改变就称为回流。

回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

**以下几个动作可能会导致性能问题：**

- 改变 `window` 大小
- 改变字体
- 添加或删除样式
- 文字改变
- 定位或者浮动
- 盒模型

并且很多人不知道的是，重绘和回流其实也和 Eventloop 有关。

 1. 当 Eventloop 执行完 Microtasks（微任务） 后，会判断 `document` 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次。
 2. 然后判断是否有 `resize` 或者 `scroll` 事件，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 16ms 才会触发一次，并且自带节流功能。
 3. 判断是否触发了 media query(媒体查询)
 4. 更新动画并且发送事件
 5. 判断是否有全屏操作事件
 6. 执行 `requestAnimationFrame` 回调
 7. 执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
 8. 更新界面
 9. 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 `requestIdleCallback` 回调。
 
 以上内容来自于 [HTML 文档](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)。

#### 减少 重绘与回流

1. 使用 `transform` 替代 `top`
2. 使用 `visibility` 替换 `display: none` (前者只会引起重绘，后者会引发回流)
3. 不要把节点的属性值放在一个循环里当成循环里的变量

```js
for(let i = 0; i < 1000; i++) {
    // 获取 offsetTop 会导致回流，因为需要去获取正确的值
    console.log(document.querySelector('.test').style.offsetTop)
}
```

4. 不要使用 `table` 布局，可能很小的一个小改动会造成整个 `table` 的重新布局
5. 动画实现的速度的选择，动画速度越快，回流次数越多，可以选择使用 `requestAnimationFrame`
6. CSS 选择符**从右往左**匹配查找，避免节点层级过多
7. 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 `video` 标签来说，浏览器会自动将该节点变为图层;
   以下常用属性可以生成新图层:
   - `will-change`
   - `video、iframe` 标签
8. 不要重复添加 DOM， 如果有多个操作合并在一起添加到页面





### FOUC

#### 什么是 FOUC?如何避免?

`Flash Of Unstyled Content`：用户定义样式表加载之前浏览器使用默认样式显示文档，CSS 样式加载后再次渲染文档，造成页面闪烁。

解决方法：把样式表放到文档的 head

### css sprite

#### css sprite 是什么,有什么优缺点

概念：将多个小图片拼接到一个图片中。通过`background-position`和元素尺寸调节显示需要的背景图案。

优点：

- 减少 HTTP 请求数，提高页面加载速度
- 减少图片大小
- 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现

缺点：

- 图片合并麻烦
- 维护麻烦，修改一个图片可能需要从新布局整个图片，样式

#### CSS3

#### CSS3 有哪些新特性

- 新增各种 CSS 选择器
- 边框圆角 `border-radius`
- 多列布局
- 阴影和反射
- 文字特效`text-shadow`
- 线性渐变
- 旋转`transform`
- 过渡`transition`
- 动画`animation`

#### CSS3 新增伪类有那些？

```css
* p:first-of-type 选择属于其父元素的首个<p>元素的每个<p> 元素。
* p:last-of-type 选择属于其父元素的最后 <p> 元素的每个<p> 元素。
* p:only-of-type 选择属于其父元素唯一的 <p>元素的每个 <p> 元素。
* p:only-child 选择属于其父元素的唯一子元素的每个 <p> 元素。
* p:nth-child(2) 选择属于其父元素的第二个子元素的每个 <p> 元素。
* :before 在元素之前添加内容
* :after 在元素之后添加内容,也可以用来做清除浮动。
* :enabled 选择器匹配每个启用的的元素（主要用于表单元素）。
* :disabled 控制表单控件的禁用状态。
* :checked 单选框或复选框被选中
```


### 笔试题
#### 如何用 css 实现一行文字后面...的情况?
```css
overflow: hidden; //超出隐藏
white-space: nowrap; //不允许换行
text-overflow: ellipsis; //超出部分用...代替
//多行的情况请添加如下设置
display: -webkit-box;
-webkit-line-clamp: 1; //多行情况下可以设置哪一行多余部分用...代替。这里设置的是第一行
-webkit-box-orient: vertical;
```

#### css3 如何实现 0.5px 的细线?

```css
.line {
  position: relative;
}
.line:after {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 1px;
  background-color: #000000;
  -webkit-transform: scaleY(0.5);
  transform: scaleY(0.5); //在Y轴缩小一半
}
```

```html
<div class="line"></div>
```

#### css 如何实现三角形?

```css
span {
  border-top: 40px solid transparent;
  border-left: 40px solid transparent;
  border-right: 40px solid transparent;
  border-bottom: 40px solid #ff0000;
}
```

#### 宽高已知，如何实现 div 水平垂直居中? 

##### 第一种方案
```css
.box {
  width: 400px;
  height: 200px;
  position: relative;
  background: red;
}
.content {
  width: 200px;
  height: 100px;
  position: absolute;
  top: 50%;
  left: 50%;
  margin-left: -100px;
  margin-top: -50px;
  background: green;
}
```

##### 第二种方案

```css
.box {
  height: 200px;
  position: relative;
  background: red;
}
.box div {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100px;
  height: 100px;
  margin: auto;
  background: green;
}
```

```html
<div class="box">
  <div class="content">水平垂直居中</div>
</div>
```

#### 宽高未知，如何实现 div 水平垂直居中? 

##### 第一种方案
```css
.box {
  width: 400px;
  height: 200px;
  position: relative;
  background: red;
}
.content {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: green;
}
```

##### flex 解决方案:

```css
.box {
  width: 400px;
  height: 200px;
  background: red;
  display: flex;
  justify-content: center;
  align-items: center;
}
.content {
  width: 200px;
  height: 100px;
  background: green;
}
```

#### 假设高度已知，请写出三栏布局(圣杯布局)，其中左栏、右栏宽度各为 100px，中间自适应


以下布局如果条件是高度未知,依然适用的布局有 flex, table 布局。

- 浮动:

  - 缺点：脱离文档流，需清除浮动。处理不好会带来很多问题。

  - 优点：兼容性好。

```css
<style>
    .box1 div{
      min-height: 50px;
    }
    .box1 .left{
        float: left;
        width: 100px;
        background: red;
    }
    .box1 .right{
        float: right;
        width: 100px;
        background: green;
    }
    .box1 .center{
        background: yellow;
    }
</style>
<section class="box1">
    <div class="left"></div>
    <div class="right"></div>
    <div class="center">浮动自适应部分</div>
</section>
```

- 绝对定位:

  - 缺点：绝对定位脱离文档流，导致了其子元素都脱离了文档流，可使用性很差。

  - 优点：快捷！

```css
<style>
    .box2{
        min-height: 50px;
    }
    .box2 div{
        position: absolute;
        min-height: 50px;
    }
    .box2 .left{
        width: 100px;
        left: 0;
        background: red;
    }
    .box2 .center{
        left: 100px;
        right: 100px;
        background: yellow;
    }
    .box2 .right{
        right: 0;
        width: 100px;
        background: green;
    }
</style>
<section class="box2">
    <div class="left"> </div>
    <div class="center">绝对定位自适应部分</div>
    <div class="right"></div>
</section>
```

- flex:

  - 缺点：只兼容到 ie9。

  - 优点：比较完美的方案。

```css
<style>
    .box3{
        display: flex;
        min-height: 50px;
    }
    .box3 .left{
        width: 100px;
        background: red;
    }
    .box3 .center{
        flex: 1;
        background: yellow;
    }
    .box3 .right{
        width: 100px;
        background: green;
    }

</style>
<section class="box3">
    <div class="left"></div>
    <div class="center">flex自适应部分</div>
    <div class="right"></div>
</section>
```

- 表格:

  - 缺点：多栏布局时，某个单元格高度超出，会使其他单元格高度一起增加。操作繁琐，SEO 不友好。

  - 优点：兼容性好，兼容 ie8。

```css
<style>
    .box4 {
        display: table;
        width: 100%;
        min-height: 50px;
    }
    .box4 div{
        display: table-cell;
    }
    .box4 .left{
        width: 100px;
        min-height: 50px;
        background: red;
    }
    .box4 .center{
        min-height: 50px;
        background: yellow;
    }
    .box4 .right{
        width: 100px;
        min-height: 50px;
        background: green;
    }
</style>
<section class="box4">
    <div class="left"></div>
    <div class="center">表格自适应部分</div>
    <div class="right"></div>
</section>
```

- 网格布局:

  - 优点:新技术，代码量少

  - 缺点:兼容性不好， 不兼容 IE

```css
<style>
    .box5{
        display: grid;
        width: 100%;
        grid-template-rows:50px;
        grid-template-columns:100px auto  100px;
    }
    .box5 .left{
        background: red;
    }
    .box5 .center{
        background: yellow;
    }
    .box5 .right{
        background: green;
    }
</style>
<section class="box5">
    <div class="left"></div>
    <div class="center">网格自适应部分</div>
    <div class="right"></div>
</section>
```



#### 如何实现下图九宫格的效果?鼠标滑过边框显示红色?

![示例](https://gitee.com/l544402029/res/raw/master/小书匠/1587617549626.png)

```css
.wrap {
  display: flex;
  flex-wrap: wrap;
  width: 300px;
}

.wrap li {
  display: inline-flex;
  width: 100px;
  height: 100px;
  justify-content: center;
  align-items: center;
  border: 4px solid #ccc;
  box-sizing: border-box;
  margin-left: -4px;
  margin-top: -4px;
}

.wrap li:nth-child(3n + 1) {
  margin-left: 0;
}

.wrap li:nth-child(1),
.wrap li:nth-child(2),
.wrap li:nth-child(3) {
  margin-top: 0;
}

.wrap li:hover {
  border-color: red;
  z-index: 1;
}
```


---

## JS:

### JS 规范

#### 说几条写 JavaScript 的基本规范？

- 不要在同一行声明多个变量
- 请使用`===/!==`来比较`true/false`或者数值
- 使用对象字面量替代`new Array`这种形式
- 不要使用全局函数
- `Switch`语句必须带有`default`分支
- `If`语句必须使用大括号
- `for-in`循环中的变量 应该使用`let`关键字明确限定作用域，从而避免作用域污染

#### W3C 对 JS 的规定有哪些?

- DOM
- BOM
- 事件绑定
- ajax 请求(包括 http 协议)
- 存储

### 变量类型

#### 原始类型有哪些？

字符串（`String`）、数值（`Number`）、布尔值（`Boolean`）、`Undefined`、`Null`、 `symbol`

占用空间固定，保存在栈中，存储的是值。

原始类型存储的是值，是没有函数可以调用的。之所以 `'1'.toString()` 可以被调用，是因为它做了一层封装。被强制转换成了 `String` 类型，也就是对象类型,  所以可以调用`toString`函数。

`string` 类型是不可变的，无论你在 `string` 类型上调用何种方法，都不会对值有改变。

> 另外对于 `null` 来说，很多人会认为他是个对象类型，其实这是错误的。虽然 `typeof null` 会输出 `object`，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 `object` 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

#### 对象类型有哪些？

对象（`Object`）、数组（`Array`）、函数（`Function`）

占用空间不固定，地址存在栈内存，值保存在堆中, 复制的是地址, 指向同一块内存空间。 使用 `instanceof` 检测数据类型

#### 为什么值类型赋值是直接赋值， 而引用类型是直接赋值一个内存地址？

主要考虑到性能/存储问题，因为值类型占用空间比较少。它可以直接赋值， 不会对性能造成太大影响。而一般来说， 引用类型存储的空间占用较大，不好管理。如果我们直接复制会导致复制过程非常慢。所以说， 计算机所有的程序，所有的代码，所有的语言，都是采用这种方式。

#### 原始类型和对象类型区别?

1. 原始类型存储的是值,保留在栈内存(空间固定)，相等都要重新创建一份
2. 对象类型存储的是指针，保留在堆内存(空间不固定)，相等时引用的是同一份指针

#### typeof 都能识别哪些类型？

- 识别除了`null`之外的所有值类型
- 识别函数
- 判断是否是引用类型（不可再细分）

#### 类数组和数组的区别是什么？

类数组: 拥有 length 属性，不具有数组所具有的方法。

#### 类数组如何转换为数组？

```js
//第一种方法
Array.prototype.slice.call(arrayLike);
//第二种方法
[...arrayLike];
//第三种方法:
Array.from(arrayLike);
```

#### JS 内置函数是什么?

内置函数: `Object`, `Array` , `Function` , `Boolean` , `Number` , `String` , `Date` , `RegExp` , `Error` , `Json` .

作用: 作为构造器函数

#### 函数参数是对象会发生什么?

函数参数是对象指针的副本，当参数重新分配对象时，参数的指针会发生变化。两个变量的值也会不相同

#### null 和 undefined 的区别是什么?

- `null`表示空对象指针

  - 如果定义的变量准备用来保存对象，那么最好初始化为`null`

- `undefined`表示未赋值的变量

- 在使用`==`会发生类型转换.导致相等

#### null 是对象嘛？

null 并不是对象类型 。虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

#### instanceof 的原理:

沿着原型链一层一层向上找, 看是否能找到对应的`prototype`

#### 自己实现一个 instanceof

```js
function myInstanceof(left, right) {
  let prototype = right.prototype
  left = left.__proto__
  while (true) {
    if (left === null || left === undefined)
      return false
    if (prototype === left)
      return true
    left = left.__proto__
  }
}
```


#### 怎么实现浅拷贝？

浅拷贝是指只拷贝所有属性到新对象,如果属性值是对象,只拷贝地址.

浅拷贝通过`object.assign()`,扩展运算符`...`来解决

```js
var newObj = Object.assign({}, obj);
var newObj = { ...obj };
```

#### 怎么实现深拷贝？

- 通过 JSON.parse(JSON.stringify(object)) 来解决

```js
var newObj = JSON.parse(JSON.stringify(obj));
```

但是：会忽略 `undefined`、 `symbol`、不能序列化函数、不能解决循环引用的对象

### 类型转换

#### 哪些情况下会发生类型转换?

- ==
- 逻辑运算符
- if
- 字符串拼接


首先我们要知道，在 JS 中类型转换只有三种情况，分别是：

- 转换为布尔值
- 转换为数字
- 转换为字符串

**类型转换表格**

![类型转换表格](https://gitee.com/l544402029/res/raw/master/小书匠/1584178443591.png)

#### 转 Boolean

在条件判断时，除了 `undefined`，`null`， `false`，`NaN`， `''`， `0`， `-0`，其他所有值都转为 `true`，包括所有对象。

#### JavaScript 中如何进行隐式类型转换？

首先要介绍 `ToPrimitive` 方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：

```js
/**
* @obj 需要转换的对象
* @type 期望的结果类型
*/
ToPrimitive(obj,type)
```

##### `type` 的值为 `number` 或者 `string`。

当 `type` 为 `number` 时规则如下：

1. 调用 `obj` 的 `valueOf` 方法，如果为原始值，则返回，否则下一步；
2. 调用 `obj` 的 `toString` 方法，后续同上；
3. 抛出 `TypeError` 异常

##### 当 `type` 为 `string` 时规则如下：

1. 调用 `obj` 的 `toString` 方法，如果为原始值，则返回，否则下一步；
2. 调用 `obj` 的 `valueOf` 方法，后续同上；
3. 抛出 `TypeError` 异常。


可以看出两者的主要区别在于调用 `toString` 和 `valueOf` 的先后顺序。默认情况下：

1. 如果对象为 `Date` 对象，则 `type` 默认为 `string`；
2. 其他情况下，`type` 默认为 `number`。


而 JavaScript 中的隐式类型转换主要发生在 `+、-、*、/` 以及 `==、>、<` 这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用 `ToPrimitive` 转换成基本类型，再进行操作。

#### 四则运算符

加法运算符不同于其他几个运算符，它有以下几个特点：

- 运算中其中一方为字符串，那么就会把另一方也转换为字符串
- 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

```javascript
1 + '1'; // '11'
true + true; // 2
4 + [1, 2, 3]; // "41,2,3"
```

如果你对于答案有疑问的话，请看解析：

- 对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 '11'
- 对于第二行代码来说，触发特点二，所以将 true 转为数字 1
- 对于第三行代码来说，触发特点二，所以将数组通过 toString 转为字符串 1,2,3，得到结果 41,2,3

另外对于加法还需要注意这个表达式 'a' + + 'b'

`'a' + + 'b' // -> "aNaN"`

因为`+ 'b'` 等于 `NaN`，所以结果为 `"aNaN"`，你可能也会在一些代码中看到过 `+ '1'` 的形式来快速获取 number 类型。

除了加法运算，只要其中一方为数字，另一方必定转为数字。

```javascript
4 * '3'; // 12
4 * []; // 0
4 * [1, 2]; // NaN
```

#### 比较运算符

1. 如果是对象，就通过 toPrimitive 转换对象
2. 如果是字符串，就通过 unicode 字符索引来比较

```javascript
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return '1';
  },
};
a > -1; // true
```

在以上代码中，因为`a`是对象，所以会通过 `valueOf` 转换为原始类型再比较值。

#### == 和 === 有什么区别？

首先使用 `==` 是会发生隐式类型转换的。 一般只有判断一个变量是不是`null`和`undefined`时会使用`==`。其它地方一律用`===`。

`==`运算流程图

![==运算流程分析](https://gitee.com/l544402029/res/raw/master/小书匠/1584320285922.png)



### JSON

#### 怎么理解 json?

是内置的 js 对象,也是一种数据格式

它有两个方法:

```js
JSON.stringify({ a: 10, b: 11 }); //把对象变成字符串

JSON.parse('{a:10,b:11}'); //把字符串变成对象
```

#### XML 与 JSON 的区别?

JSON 数据体积小 , 传递快 , 与 JavaScript 交互更加方便 , 容易解析 。

但是数据描述性差 , 不如 XML

### DOM

#### DOM 的本质?

:::tip
DOM: Document Object Model 文档对象模型。

HTML 代码就是一个字符串，但是浏览器已经把字符串结构化成树形结构了。
:::

DOM 本质就是浏览器拿到 HTML 代码后，DOM 把 HTML 代码结构化成浏览器及 JS 可识别的模型 。

#### DOM 是哪种数据结构?

它是从 HTML 文件解译出来的一棵 DOM **树形结构**。

#### DOM 结构操作有哪些？

- 新增节点 `document.createElement(node)`
- 获取父元素 `childNode.parentElement`
- 获取子元素 `parentNode.childNodes`
- 删除节点 `parentNode.removeChild(childNode)`

#### childNodes 和 children 的区别?

`childNodes` 属性返回所有的节点，包括文本节点、注释节点；
`children` 属性只返回元素节点；

#### Attribute 和 property 有何区别?

- `attribute` (自定义)属性在 HTML 上设置修改， 会直接反应到 HTML 上， 两者同步。
- `porperty` (固有)属性可以看做是 DOM 对象的键值对， 用点操作符对他们进行操作。 实际编程中， 基本的 DOM 操作都是使用 `peoperty` 的点操作符。
- 对于 HTML 的标准属性来说，`attribute`和`property`是同步的，是会自动更新的
- 对于自定义的属性来说，它们是不同步的

#### offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别?

- `offsetWidth/offsetHeight`返回值包含`content` + `padding` + `border`
- `clientWidth/clientHeight`返回值只包含`content` + `padding`
- `scrollWidth/scrollHeight`返回值包含`content`+ `padding` + 溢出内容的尺寸

### 作用域和闭包

#### 作用域是什么？

::: danger 注意：
一个函数的父级作用域是在它定义的时候的作用域，而非它执行时候的作用域。
:::

作用域其实就是代表了一个变量合法的使用范围。如果超出了范围就会报错。

作用域分为局部作用域和全局作用域，处在局部作用域里面可以访问到全局作用域的变量，而在局部作用域外面就访问不到局部作用域里面所声明的变量。


![enter description here](https://gitee.com/l544402029/res/raw/master/小书匠/1582641721107.png)


#### 作用域链是什么?

在局部作用域访问变量 , 如果访问不到 , 自由变量会一直向父级作用域寻找，这样的链条称之为作用域链。

#### 自由变量是什么？

- 一个变量在当前作用域没有定义， 但被使用了。
- 向上级作用域， 一层一层依次寻找， 直到找到为止。
- 如果到全局作用域都没找到， 则报错 `xx is not defined`

#### 什么是闭包呢?

闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

```javascript
function A() {
  let a = 1;
  window.B = function () {
    console.log(a);
  };
}
A();
B(); // 1
```

在 JS 中，**闭包存在的意义就是让我们可以间接访问函数内部的变量。**

两道考题：

```js
function create() {
  const a = 100;
  return function () {
    console.log(a);
  };
}

const fn = create();
const a = 200;
fn(); //100
```

```js
function print(fn) {
  const a = 200;
  fn();
}
const a = 100;
function fn() {
  console.log(a);
}
print(fn); //100
```

无论出什么样的考题， 我们都一定要记住！

**所有的自由变量的查找， 是在函数定义的地方向上级作用域查找， 而不是在执行的地方！！！**

#### 闭包有哪些优点和缺点?

优点: 封装性强，使得变量始终保持在内存中。

缺点: 内存的消耗导致的性能问题（不用的闭包设置为`null`清除闭包）

#### 闭包使用场景?

使用场景: 
- 函数作为**返回值** 
- 函数作为**参数**传递

#### 循环中使用闭包解决 var 定义函数的问题?

- 闭包解决方案

```js
for (var i = 1; i <= 5; i++) {
  (function (j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```

- 使用 setTimeout 的第三个参数

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(
    function timer(j) {
      console.log(j);
    },
    i * 1000,
    i
  );
}
```

- let 解决方案（推荐）

```js
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

#### 实际开发中闭包的应用有哪些？

- 隐藏数据， 只提供 API
- 做一个简单的 cache 工具

```js
//闭包隐藏数据，只提供API
function createCache() {
  const data = {}; //闭包中的数据被隐藏， 不被外界访问
  return {
    set: function (key, val) {
      data[key] = val;
    },
    get: function (key) {
      return data[key];
    },
  };
}

const c = createCache();
c.set('a', 100);
console.log(c.get('a')); //100
```



### this全解析

:::tip
this 取值是在执行的时候确认的， 而不是在定义的时候。
:::

#### this 有哪几种调用方式？

- 作为普通函数
- 作为 `call, apply, bind`
- 作为对象方法调用
- 在 class 方法中调用
- 箭头函数


#### this 有哪些使用场景?

1. 作为对象属性执行
2. 作为构造函数执行
3. 作为普通函数执行
4. `call apply bind`

#### this 指向如何判断?

- 函数直接调用指向`window`
- 对象调用,`this`指向调用的对象
- `new`方式直接指向它的实例对象
- 箭头函数无`this`,取决于上下文的`this`
- `bind`的`this`永远指向第一次指定的对象

#### this 优先级

1. `new`优先级最高
2. `bind`次之
3. 然后是`obj.foo()`对象调用
4. 最后是`foo（）`直接调用，同时箭头函数 `this`一旦绑定，不会再改变


#### 以下代码this指向谁？

```js
<div class="table" onclick="callback()"></div>

function callback (){
  console.log(this);
}
```

这个调用场景适用于将函数用作独立函数调用，`callback` 中的 `this` 在非严格模式下指向 `windows`，严格模式下指向`undefined`。

如果想要打印当前元素,需要在调用 `callback(this)` 时添加上 `this` 参数。


#### 写出打印结果，并解释为什么？

```js
let length = 10;
function fn (){
  console.log(this.length);
}
var obj = {
  length:5,
  method:function (fn){
    fn()
    arguments[0]()
  }
}
obj.method(fn,'l')
```

第一次打印1， 此时 `this` 指向 `window` , `window.length` 指的是 `frame` `iframe`的窗口数量。

第二次打印2， 此时 `this` 指向 `arguments` 对象。 此时 `arguments` 参数长度是2。


### 原型与原型链

#### 原型与原型链的理解,它们有什么特点?

![原型图](https://gitee.com/l544402029/res/raw/master/小书匠/1587033507396.png)

**原型:**

每个函数都有一个`prototype`属性, 这个属性指向的就是原型。 每一个实例对象都有一个 `__proto__` （隐式原型）,它指向的就是构造函数的原型。

**原型链:**

- 当调用一个对象的属性时 , 如果自身对象未找到 , 会去对象的`__proto__`属性(隐式原型对象)里去找 。
- 然后原型本身也是一个对象 , 拥有`__proto__` 属性 , 所以会继续向上查找 。
- 一直找到`Object.prototype.proto===null`， 这样的链条称之为原型链。

**原型链的特点:**

原型对象上的方法是被不同实例共有的 . 当我们修改原型时，与之相关的对象也会继承这一改变。

#### new 的原理是什么？

- 新生成了一个对象
- 链接到原型
- 构造函数执行，绑定 `this`
- 如果构造函数返回了一个对象，那么会取代 new 出来的结果。
- 如果构造函数没有返回对象，那么返回新生成的对象。

对于对象来说，其实都是通过 `new` 产生的，无论是 `function Foo() 还是 let a = { b : 1 }`



#### 通过 new 的方式创建对象和通过字面量创建有什么区别?

区别:

更推荐使用字面量的方式创建对象（无论性能上还是可读性）。

因为你使用 `new Object()` 的方式创建对象需要通过作用域链一层层找到 `Object`，但是你使用字面量的方式就没这个问题。

### 面向对象

#### 面向对象编程思想？

使用**对象**，**类**，**继承**，**封装**等基本概念来进行程序设计





#### 什么是面向对象编程及面向过程编程？

- 面向过程就是分析出解决问题的步骤，然后用函数把这些步骤一步一步实现，使用的时候依次调用。
- 面向对象是以功能来划分问题，建立对象的目的不是为了完成一个步骤，而是把步骤统一封装在对象内，对外统一提供调用接口。

#### 面向对象的异同和优缺点

- 优点
  - 易维护
    - 采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，维护非常方便。
  - 易扩展
  - 复用性、继承性高.

#### 创建对象有几种方法?

```js
//字面量
var o1 = { name: 'o1' };
//类的实例化
var o1 = new Object({ name: 'o1' });

//构造函数
var O = function (name) {
  this.name = name;
};
var o2 = new O('o2');

//Obejct.create()
var o = { name: 'o3' };
var o3 = Object.create(o);
```


#### 如何声明一个类?

```js
function Animal(name) {
  this.name = name;
}
new Animal(); //实例化

//ES6
class Animal2 {
  constructor(name) {
    this.name = name;
  }
}
new Animal2(); //实例化
```

#### 如何实现继承?继承有哪几种方式?

- 构造函数实现继承:
  - 缺点: 无法继承父类原型对象上的属性方法

```js{5,8}
function Parent() {
  this.name = name;
}
//无法继承say方法
//Parent.prototype.say=function(){};

function Child() {
  Parent.call(this); //把父类的this指向新创建的实例
  this.type = 'child';
}

console.log(new Child());
```

- 原型链继承:
  - 缺点 : 原型链上的原型对象是共用的, 原型对象某个属性发生改变， 所有的实例也会随之改变

```js{9}
function Parent1() {
  this.name = 'parent1';
}

function Child1() {
  this.type = 'child1';
}

Child1.prototype = new Parent1();

console.log(new Child1());
```

- 组合继承:

```js
function Parent1() {
  this.name = 'parent1';
  this.play = [1, 2, 3];
}

function Child1() {
  Parent1.call(this);
  this.type = 'child1';
}
//父级的构造函数执行了两次,并把父类的constructor也继承了，浪费内存。(组合继承1)
//Child1.prototype=new Parent1();
//无法判断实例对象的直接构造函数是哪一个,此时constructor指向父类。(组合继承2)
//Child1.prototype=Parent1.prototype;
Child1.prototype = Object.create(Parent1.prototype);
Child1.prototype.constructor = Child1;
var c1 = new Child1('child1');
var c2 = new Child1('child2');
c1.play.push('4');
console.log(c1.play); //[1, 2, 3, "4"]
console.log(c2.play); // [1, 2, 3]
```

- ES6 (Class 类继承):

```js
class Parent {
  constructor(name) {
    this.name = name;
    this.type = ['parent'];
  }
  play() {
    console.log(this.name);
  }
}

class Child extends Parent {
  constructor(name) {
    super(name);
  }
}

var c1 = new Child('child1');
var c2 = new Child('child2');
c1.type.push('child');
console.log(c1.type); //["parent", "child"]
console.log(c2.type); //["parent"]
console.log(c1.play()); //child1
```

### 设计模式
#### 面向对象有哪几种设计模式？

基本特征：多态，继承，封包（完全参考 java）

- 工厂模式:

  - 在函数中创建一个对象，给对象添加属性或属性方法，然后在把这个对象用**return**返回出来

  - 优点: 解决重复实例化

  - 缺点: 没有解决对象识别的问题

```js
function createPerson(name, age) {
  var o = new Object();
  o.name = name;
  o.age = age;
  o.sayName = function () {
    alert(this.name);
  };
  return o;
}
var xm = createPerson('xm', '23');
var xh = createPerson('xh', '16');
xm == xh; //false
```

- 构造方式:

  - 构造函数使用`new`运算符，生成实例，并且`this`变量会绑定在实例对象上。

  - 优点：解决了重复实例化的问题 ，又解决了对象识别的问题

  - 缺点：每个方法都要在每个实例上重新创建一遍。

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayName = function () {
    alert(this.name);
  };
}

var xm = new Person('xm', '23');
var xh = new Person('xh', '16');
```

**构造方式与工厂模式的区别:**

1.  构造方式不会显示创建对象，只要将属性和方法赋值给`this`，不需要`return`语句

2.  工厂在方法内部创建`object`对象，最后返回`object`对象，属性和方法都是赋值 `object`对象

- 原型模式:

  - 函数本身声明为空内容，利用`prototype`定义一些属性及方法。

  - 优点：所有的实例共享`prototype`中的定义，节省了内存。

  - 缺点：不能通过传递参数来初始化属性的值。由于原型的属性被所有实例共享，实例在修改原型中的引用类型时，其它实例也会发生改变。

```js
function Person() {}
Person.prototype.name = 'xm';
Person.prototype.age = '23';
Person.prototype.sayName = function () {
  alert(this.name);
};

var xm = new Person();
xm.sayName();
```

**原型模式的第二种方式 : json 数据定义**

```js
// jSON数据定义
function Person() {}

Person.prototype = {
  name: 'xm',
  age: '23',
  sayName: function () {
    alert(this.name);
  },
};

var xm = new Person();
xm.sayName();
```

- 混合模式(构造+原型):

这种概念非常简单，即用构造函数定义**实例属性**，用原型方式定义**方法和共享的属性**。

结果是，每个实例都会有自己的**实例属性副本**，但同时又**共享着对方法的引用**，节省内存。

此外，组合模式还支持向构造函数传递参数，可谓是集两家之所长。

在所接触的 JS 库中，`jQuery`类型的封装就是使用组合模式来实例的！！！

```js
//混合模式
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.friends = ['xjin', 'xlv'];
}
Person.prototype = {
  constructor: Person,
  sayName: function () {
    alert(this.name);
  },
};

var xm = new Person('xm', '23');
var xh = new Person('xh', '16');
xm.friends.push('xheihei');
console.log(xm.friends); //["xjin", "xlv", "xheihei"]
console.log(xh.friends); //["xjin", "xlv"]
```

#### 工厂模式

```js
class Man {
  constructor(name) {
    this.name = name
  }
  alertName() {
    alert(this.name)
  }
}

class Factory {
  static create(name) {
    return new Man(name)
  }
}

Factory.create('yck').alertName()
```

可以想象一个场景。假设有一份很复杂的代码需要用户去调用，但是用户并不关心这些复杂的代码，只需要你提供给我一个接口去调用，用户只负责传递需要的参数，至于这些参数怎么使用，内部有什么逻辑是不关心的，只需要你最后返回我一个实例。这个构造过程就是工厂。

工厂起到的作用就是隐藏了创建实例的复杂度，只需要提供一个接口，简单清晰。

在 Vue 源码中，你也可以看到工厂模式的使用，比如创建异步组件

```js
export function createComponent (
  Ctor: Class<Component> | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag?: string
): VNode | Array<VNode> | void {
    
    // 逻辑处理...
  
  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data, undefined, undefined, undefined, context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  )

  return vnode
}
```

在上述代码中，我们可以看到我们只需要调用 `createComponent` 传入参数就能创建一个组件实例，但是创建这个实例是很复杂的一个过程，工厂帮助我们隐藏了这个复杂的过程，只需要一句代码调用就能实现功能。

#### 单例模式
单例模式很常用，比如全局缓存、全局状态管理等等这些只需要一个对象，就可以使用单例模式。

单例模式的核心就是保证全局只有一个对象可以访问。因为 JS 是门无类的语言，所以别的语言实现单例的方式并不能套入 JS 中，我们只需要用一个变量确保实例只创建一次就行，以下是如何实现单例模式的例子

```js
class Singleton {
  constructor() {}
}

Singleton.getInstance = (function() {
  let instance
  return function() {
    if (!instance) {
      instance = new Singleton()
    }
    return instance
  }
})()

let s1 = Singleton.getInstance()
let s2 = Singleton.getInstance()
console.log(s1 === s2) // true
```

在 Vuex 源码中，你也可以看到单例模式的使用，虽然它的实现方式不大一样，通过一个外部变量来控制只安装一次 Vuex

```js
let Vue // bind on install

export function install (_Vue) {
  if (Vue && _Vue === Vue) {
    // 如果发现 Vue 有值，就不重新创建实例了
    return
  }
  Vue = _Vue
  applyMixin(Vue)
}
```

#### 适配器模式
适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。

以下是如何实现适配器模式的例子

```js
class Plug {
  getName() {
    return '港版插头'
  }
}

class Target {
  constructor() {
    this.plug = new Plug()
  }
  getName() {
    return this.plug.getName() + ' 适配器转二脚插头'
  }
}

let target = new Target()
target.getName() // 港版插头 适配器转二脚插头
```

在 Vue 中，我们其实经常使用到适配器模式。比如父组件传递给子组件一个时间戳属性，组件内部需要将时间戳转为正常的日期显示，一般会使用 `computed` 来做转换这件事情，这个过程就使用到了适配器模式。

#### 装饰模式

装饰模式不需要改变已有的接口，作用是给对象添加功能。就像我们经常需要给手机戴个保护套防摔一样，不改变手机自身，给手机添加了保护套提供防摔功能。

以下是如何实现装饰模式的例子，使用了 ES7 中的装饰器语法

```js
function readonly(target, key, descriptor) {
  descriptor.writable = false
  return descriptor
}

class Test {
  @readonly
  name = 'yck'
}

let t = new Test()

t.yck = '111' // 不可修改
```

#### 代理模式

代理是为了控制对对象的访问，不让外部直接访问到对象。在现实生活中，也有很多代理的场景。比如你需要买一件国外的产品，这时候你可以通过代购来购买产品。

在实际代码中其实代理的场景很多，也就不举框架中的例子了，比如事件代理就用到了代理模式。

```js
<ul id="ul">
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
</ul>
<script>
    let ul = document.querySelector('#ul')
    ul.addEventListener('click', (event) => {
        console.log(event.target);
    })
</script>
```

因为存在太多的 `li`，不可能每个都去绑定事件。这时候可以通过给父节点绑定一个事件，让父节点作为代理去拿到真实点击的节点

#### 发布-订阅模式

发布-订阅模式也叫做观察者模式。通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会收到通知。在现实生活中，也有很多类似场景，比如我需要在购物网站上购买一个产品，但是发现该产品目前处于缺货状态，这时候我可以点击有货通知的按钮，让网站在产品有货的时候通过短信通知我。

在实际代码中其实发布-订阅模式也很常见，比如我们点击一个按钮触发了点击事件就是使用了该模式

```js
<ul id="ul"></ul>
<script>
    let ul = document.querySelector('#ul')
    ul.addEventListener('click', (event) => {
        console.log(event.target);
    })
</script>
```

在 Vue 中，如何实现响应式也是使用了该模式。对于需要实现响应式的对象来说，在 `get` 的时候会进行依赖收集，当改变了对象的属性时，就会触发派发更新。

#### 外观模式
外观模式提供了一个接口，隐藏了内部的逻辑，更加方便外部调用。

举个例子来说，我们现在需要实现一个兼容多种浏览器的添加事件方法

```js
function addEvent(elm, evType, fn, useCapture) {
  if (elm.addEventListener) {
    elm.addEventListener(evType, fn, useCapture)
    return true
  } else if (elm.attachEvent) {
    var r = elm.attachEvent("on" + evType, fn)
    return r
  } else {
    elm["on" + evType] = fn
  }
}
```

对于不同的浏览器，添加事件的方式可能会存在兼容问题。如果每次都需要去这样写一遍的话肯定是不能接受的，所以我们将这些判断逻辑统一封装在一个接口中，外部需要添加事件只需要调用 `addEvent` 即可。



#### 实现一个 Storage

实现Storage，使得该对象为单例，基于 localStorage 进行封装。实现方法 setItem(key,value) 和 getItem(key)。

:::tip 思路
首先要记起来getInstance方法和instance这个变量是干啥的。最好能把闭包的版本也写出来！
:::


- 实现：静态方法版

```js
// 定义Storage
class Storage {
    static getInstance() {
        // 判断是否已经new过1个实例
        if (!Storage.instance) {
            // 若这个唯一的实例不存在，那么先创建它
            Storage.instance = new Storage()
        }
        // 如果这个唯一的实例已经存在，则直接返回
        return Storage.instance
    }
    getItem (key) {
        return localStorage.getItem(key)
    }
    setItem (key, value) {
        return localStorage.setItem(key, value)
    }
}

const storage1 = Storage.getInstance()
const storage2 = Storage.getInstance()

storage1.setItem('name', '李雷')
// 李雷
storage1.getItem('name')
// 也是李雷
storage2.getItem('name')

// 返回true
storage1 === storage2
```

- 实现： 闭包版

```js
// 先实现一个基础的StorageBase类，把getItem和setItem方法放在它的原型链上
function StorageBase () {}
StorageBase.prototype.getItem = function (key){
    return localStorage.getItem(key)
}
StorageBase.prototype.setItem = function (key, value) {
    return localStorage.setItem(key, value)
}

// 以闭包的形式创建一个引用自由变量的构造函数
const Storage = (function(){
    let instance = null
    return function(){
        // 判断自由变量是否为null
        if(!instance) {
            // 如果为null则new出唯一实例
            instance = new StorageBase()
        }
        return instance
    }
})()

// 这里其实不用 new Storage 的形式调用，直接 Storage() 也会有一样的效果 
const storage1 = new Storage()
const storage2 = new Storage()

storage1.setItem('name', '李雷')
// 李雷
storage1.getItem('name')
// 也是李雷
storage2.getItem('name')

// 返回true
storage1 === storage2
```

#### 实现一个全局的模态框

实现一个全局唯一的Modal弹框

:::tip 思路
记住getInstance方法、记住instance变量、记住闭包和静态方法
:::

- ES6版本
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>单例模式弹框</title>
</head>
<style>
    #modal {
        height: 200px;
        width: 200px;
        line-height: 200px;
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        border: 1px solid black;
        text-align: center;
    }
</style>
<body>
	<button id='open'>打开弹框</button>
	<button id='close'>关闭弹框</button>
</body>
<script>
    // 核心逻辑，这里采用了闭包思路来实现单例模式
    class Modal{
      constructor(){
        this.dom = null
        if(!Modal.instance){
          this.dom = document.createElement('div')
          this.dom.innerHTML = '我是一个全局唯一的Modal'
          this.dom.id = 'modal'
          this.dom.style.display = 'none'
          document.body.appendChild(this.dom)
          this.dom.showModal = this.show.bind(this)
          this.dom.hideModal = this.hide.bind(this)
          Modal.instance = this.dom
        }
        return Modal.instance
      }
      show(){
        this.dom.style.display = 'block'
      }
      hide(){
        this.dom.style.display = 'none'
      }
    }
    
    // 点击打开按钮展示模态框
    document.getElementById('open').addEventListener('click', function() {
        // 未点击则不创建modal实例，避免不必要的内存占用;此处不用 new Modal 的形式调用也可以，和 Storage 同理
    	const modal = new Modal()
    	modal.showModal()
    })
    
    // 点击关闭按钮隐藏模态框
    document.getElementById('close').addEventListener('click', function() {
      const modal = new Modal()
    	if(modal) {
        modal.hideModal()
    	}
    })
</script>
</html>
```


- ES5版本
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>单例模式弹框</title>
</head>
<style>
    #modal {
        height: 200px;
        width: 200px;
        line-height: 200px;
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        border: 1px solid black;
        text-align: center;
    }
</style>
<body>
	<button id='open'>打开弹框</button>
	<button id='close'>关闭弹框</button>
</body>
<script>
    // 核心逻辑，这里采用了闭包思路来实现单例模式
    const Modal = (function() {
    	let modal = null
    	return function() {
            if(!modal) {
            	modal = document.createElement('div')
            	modal.innerHTML = '我是一个全局唯一的Modal'
            	modal.id = 'modal'
            	modal.style.display = 'none'
            	document.body.appendChild(modal)
            }
            return modal
    	}
    })()
    
    // 点击打开按钮展示模态框
    document.getElementById('open').addEventListener('click', function() {
        // 未点击则不创建modal实例，避免不必要的内存占用;此处不用 new Modal 的形式调用也可以，和 Storage 同理
    	const modal = new Modal()
    	modal.style.display = 'block'
    })
    
    // 点击关闭按钮隐藏模态框
    document.getElementById('close').addEventListener('click', function() {
    	const modal = new Modal()
    	if(modal) {
    	    modal.style.display = 'none'
    	}
    })
</script>
</html>
```



### 模块化

#### 为什么要使用模块化？

- 解决命名冲突
- 提供复用性
- 提高代码可维护性

**立即执行函数**

在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题

```javascript
(function (globalVariable) {
  globalVariable.test = function () {};
  // ... 声明各种变量、函数都不会污染全局作用域
})(globalVariable);
```

**AMD 和 CMD**

```javascript
// AMD
define(['./a', './b'], function (a, b) {
  // 加载模块完毕可以使用
  a.do();
  b.do();
});
// CMD
define(function (require, exports, module) {
  // 加载模块
  // 可以把 require 写在函数体的任意地方实现延迟加载
  var a = require('./a');
  a.doSomething();
});
```

**CommonJS**

CommonJS 最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中你就能见到它，当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了。

```javascript
// a.js
module.exports = {
  a: 1,
};
// or
exports.a = 1;

// b.js
var module = require('./a.js');
module.a; // -> log 1
```

因为 CommonJS 还是会使用到的，所以这里会对一些疑难点进行解析

先说 `require` 吧:

```javascript
var module = require('./a.js');
module.a;
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
  a: 1,
};
// module 基本实现
var module = {
  id: 'xxxx', // 我总得知道怎么去找到他吧
  exports: {}, // exports 就是个空对象
};
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports;
var load = function (module) {
  // 导出的东西
  var a = 1;
  module.exports = a;
  return module.exports;
};
// 然后当我 require 的时候去找到独特的
// id，然后将要使用的东西用立即执行函数包装下，over
```

另外虽然 `exports` 和 `module.exports` 用法相似，但是不能对 `exports` 直接赋值。因为 `var exports = module.exports` 这句代码表明了 `exports` 和 `module.exports` 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 `exports` 赋值就会导致两者不再指向同一个内存地址，修改并不会对 `module.exports` 起效。

**ES Module**

ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别：

- CommonJS 支持**动态导入**，也就是 `require(\${path}/xx.js)` ，后者目前不支持，但是已有提案
- CommonJS 是**同步导入**，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是**异步导入**，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响
- CommonJS 在导出时都是**值拷贝**，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化
- ES Module 会编译成 require/exports 来执行的

```js
// 引入模块 API
import XXX from './a.js';
import { XXX } from './a.js';
// 导出模块 API
export function a() {}
export default function () {}
```

### map, filter, reduce

#### map, filter, reduce 各自有什么作用？

**map**

`map` 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中。

```js
[1, 2, 3].map((v) => v + 1); // -> [2, 3, 4]
```

另外 `map` 的回调函数接受三个参数，分别是当前索引元素，索引，原数组

```js
['1', '2', '3'].map(parseInt);
```

- 第一轮遍历 `parseInt('1', 0) -> 1`
- 第二轮遍历 `parseInt('2', 1) -> NaN`
- 第三轮遍历 `parseInt('3', 2) -> NaN`

**filter**

filter 的作用也是生成一个新数组，在遍历数组的时候将返回值为 true 的元素放入新数组，我们可以利用这个函数删除一些不需要的元素

```js
let array = [1, 2, 4, 6];
let newArray = array.filter((item) => item !== 6);
console.log(newArray); // [1, 2, 4]
```

和 `map` 一样，`filter` 的回调函数也接受三个参数，用处也相同。

**reduce**

最后我们来讲解 `reduce` 这块的内容，同时也是最难理解的一块内容。`reduce` 可以将数组中的元素通过回调函数最终转换为一个值。

```js
const arr = [1, 2, 3];
const sum = arr.reduce((acc, current) => acc + current, 0);
console.log(sum);
```

对于 reduce 来说，它接受两个参数，分别是回调函数和初始值，接下来我们来分解上述代码中 `reduce` 的过程

- 首先初始值为 `0`，该值会在执行第一次回调函数时作为第一个参数传入
- 回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组，后三者想必大家都可以明白作用，这里着重分析第一个参数
- 在一次执行回调函数时，当前值和初始值相加得出结果 `1`，该结果会在第二次执行回调函数时当做第一个参数传入
- 所以在第二次执行回调函数时，相加的值就分别是 `1` 和 `2`，以此类推，循环结束后得到结果 `6`

### 事件机制

#### DOM 事件级别?

- DOM0 （缺点:后定义的事件会被覆盖之前定义的事件）

```js
element.onclick = function () {};
```

- DOM2

```js
element.addEventListener('click', function () {}, false);
```

- DOM3 相较于 DOM2 增加了一些鼠标，键盘事件

```js
element.addEventListener('keyup', function () {}, false);
```

为什么没有 DOM1 事件呢？ 因为 DOM1 没有设计事件方面的东西。

#### DOM 事件模型是什么?

捕获和冒泡

#### 什么是事件流?？

一个完整的事件流分三个阶段：捕获 > 目标元素 > 冒泡

#### 事件的触发过程是怎么样的？

事件触发过程:

从`window` 捕获 > `document` > `html`(`document.documentElement`) > `body` > ... > 目标元素 > 然后再依次冒泡到`window`

- window 往事件触发处传播，遇到注册的捕获事件会触发
- 传播到事件触发处时触发注册的事件
- 从事件触发处往 window 传播，遇到注册的冒泡事件会触发


**如果给一个 body 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。**

#### Event 对象的常见应用

1. `event.preventDefault()`：阻止默认事件；

2. `event.stopPropagation()`：阻止冒泡事件；(其实也可以阻止捕获)

3. `event.stoplmmediatePropagation()`：事件响应优先级 阻止相同事件类型监听函数执行。如先后定义 A,B 两个点击事件， a 使用此方法后 b 事件将不再执行。

4. `event.currentTarget`：当前绑定事件的元素；

5. `event.target`：当前被点击的元素；

#### 怎么模拟一个事件？

```js{2-4,7,12}
// 创建事件
let myEvent = new CustomEvent('pingan', {
  detail: { name: 'wangpingan' },
});

// 添加适当的事件监听器
window.addEventListener('pingan', function (e) {
  alert(`pingan事件触发，是 ${e.detail.name} 触发。`);
});
document.getElementById('leo2').addEventListener('click', function () {
  // 派发事件
  window.dispatchEvent(myEvent);
});
```

#### 怎么注册事件？

通常我们使用 `addEventListener` 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 `useCapture` 参数来说，该参数默认值为 `false` ，`useCapture` 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性

- `capture`：布尔值，和 `useCapture` 作用一样
- `once`：布尔值，值为 `true` 表示该回调只会调用一次，调用后会移除监听
- `passive`：布尔值，表示永远不会调用 `preventDefault`

一般来说，如果我们只希望事件只触发在目标上，这时候可以使用 `stopPropagation` 来阻止事件的进一步传播。通常我们认为 `stopPropagation` 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。`stopImmediatePropagation` 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。


#### 知道什么是事件代理吗？

把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是 DOM 元素的事件冒泡。

如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上

```js
<ul id="ul">
	<li>1</li>
    <li>2</li>
	<li>3</li>
	<li>4</li>
	<li>5</li>
</ul>
<script>
	let ul = document.querySelector('#ul')
	ul.addEventListener('click', (event) => {
		console.log(event.target);
	})
</script>
```

事件代理的方式相较于直接给目标注册事件来说，有以下优点：

- 节省内存
- 不需要给子节点注销事件
- 代码简洁

### 异步

#### 如何理解 js 单线程?

同一时间只能干一件事

#### 什么是任务队列?

有同步任务和异步任务

`seTimeout`是异步任务 , 执行到异步任务要挂起

同步任务执行完再执行异步任务

#### 什么是同步(对比异步)?举个例子?

同步：浏览器向服务器请求，用户看到页面，**重新发个请求** , 请求完，页面刷新，新内容才出现。

异步：浏览器向服务器请求，用户正常操作，浏览器**后端进行请求**。请求完，页面不刷新，新内容也会出现。

同步会阻塞代码运行,异步不会

`alert`同步,`seTimeout`异步

#### 什么时候需要异步?

在发生等待的情况下 , 程序仍然需要执行其他操作 , 不能阻塞程序运行

#### 异步使用场景有哪些?

1. 定时任务

2. 网络请求: `ajax` , `img`加载, 脚本等文件加载和下载

3. 事件绑定

#### 单线程和异步

- JS 是单线程语言， 只能同时做一件事
- JS 和 DOM 渲染共用同一个线程， 因为 JS 可修改 DOM 结构。
- 遇到等待（网络请求，定时任务）不能卡住
- 需要异步
- 回调 callback 函数形式


#### 什么是执行栈？

可以把执行栈认为是一个存储函数调用的**栈结构**，遵循先进后出的原则。

当我们使用递归的时候，因为栈可存放的函数是有**限制**的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题。


#### 解释一下什么是 Event Loop ？

- JS 是单线程语言， 只能同时做一件事。JS任务包含了同步任务和异步任务。
- 同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入 Event Table 并注册函数。
- 当指定的事情完成时，Event Table 会将这个函数移入 Event Queue
- 主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。(执行完所有微任务后，如有必要会渲染页面)
- 上述过程会不断重复，也就是常说的 Event Loop(事件循环)。

#### 事件循环执行顺序？

![执行栈](https://gitee.com/l544402029/res/raw/master/小书匠/1584321815238.png)

![执行步骤](https://gitee.com/l544402029/res/raw/master/小书匠/1584321844463.png)

Event Loop 执行顺序如下所示：

- 首先 JavaScript 引擎会执行一个宏任务，注意这个宏任务一般是指主干代码本身，也就是目前的同步代码
- 执行过程中如果遇到微任务，就把它添加到微任务任务队列中
- 宏任务执行完成后，立即执行当前微任务队列中的微任务，直到微任务队列被清空
- 微任务执行完成后，开始执行下一个宏任务
- 如此循环往复，直到宏任务和微任务被清空


宏任务（macro-task）: 同步 script (整体代码)，`setTimeout` 回调函数, `setInterval` 回调函数, `I/O`, `UI rendering`；

微任务（micro-task）: `process.nextTick`, `Promise` 回调函数，`Object.observe`，`MutationObserver`


#### 并发（concurrency）和并行（parallelism）区别？

这两个名词确实是很多人都常会混淆的知识点。其实混淆的原因可能只是两个名词在中文上的相似，在英文上来说完全是不同的单词。

并发是宏观概念，我分别有任务 A 和任务 B，**在一段时间内通过任务间的切换完成了这两个任务**，这种情况就可以称之为并发。

并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。**同时完成多个任务的情况就可以称之为并行**。

#### 什么是回调函数？

回调函数是一段可执行的代码，它作为参数传给其他代码，方便需要的时候复用这段代码。

以下代码就是一个回调函数的例子：

```js
ajax(url, () => {
  // 处理逻辑
});
```

但是回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，你可能就会写出如下代码：

```js
ajax(url, () => {
  // 处理逻辑
  ajax(url1, () => {
    // 处理逻辑
    ajax(url2, () => {
      // 处理逻辑
    });
  });
});
```

这样写起来不利于阅读和维护。

#### 回调函数有什么优缺点？

**优点:**

- 避免重复代码。

**缺点**

- 不能使用 `try catch` 捕获错误，
- 不能直接`return`。
- 容易写出回调地狱

##### 回调地狱的根本问题：

1. 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身
2. 嵌套函数一多，就很难处理错误

#### 回调的特点:

- 不会立刻执行
- 是闭包
- `this` 指向是调用它的上下文，并不是回调函数的上下文
- 允许传递多个回调
- 可以嵌套

#### 回调的应用场景

- 异步编程。
- 事件监听。
- `setTimeout`、`setInterval` 方法。

#### 如何解决回调地狱问题？

- Promise， 
- async/await

#### Promise 是什么?

Promise 是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。

#### Promise 的特点是什么？

:::tip
`Promise` 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复。
:::

特点: `Promise`有三种状态,一旦执行不可更改

1. 等待中（`pending`）
2. 完成了 （`resolved`）
3. 拒绝了（`rejected`）

#### Promise 分别有什么优缺点？

- 优点: 解决回调地狱。

- 缺点: 无法取消 promise, 错误需要回调函数捕获

#### 什么是 Promise 链？

`Promise` 每次调用 `then` 之后返回的都是一个全新的 `Promise`，如果你在 `then` 中 使用了 `return`，那么 `return` 的值会被 `Promise.resolve()` 包装。这样就实现了链式调用。

#### Promise 构造函数执行和 then 函数执行有什么区别？

当我们在构造 `Promise` 的时候，构造函数内部的代码是立即执行的。

```js
new Promise((resolve, reject) => {
  console.log('new Promise');
  resolve('success');
});
console.log('finifsh');
// new Promise -> finifsh
Promise.resolve(1)
  .then((res) => {
    console.log(res); // => 1
    return 2; // 包装成 Promise.resolve(2)
  })
  .then((res) => {
    console.log(res); // => 2
  });
```

#### async 及 await 的特点，它们的优点和缺点分别是什么？

**特点**

一个函数如果加上 `async` ，那么该函数就会返回一个 Promise

```js
async function test() {
  return '1';
}
console.log(test()); // -> Promise {<resolved>: "1"}
```

`async` 就是将函数返回值使用 `Promise.resolve()` 包裹了下，和 `then` 中处理返回值一样，并且 `await` 只能配套 `async` 使用

**优势：**

处理 `then` 的调用链，能够更清晰准确的写出代码，不用写一大堆 `then`。

**缺点：**

`await` 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 `await` 会导致性能上的降低。

#### await 原理是什么？

`async` 函数是 Generator 函数的语法糖。使用 关键字 `async` 来表示，在函数内部使用 `await` 来表示异步。

想较于 Generator，Async 函数的改进在于下面四点：

- 内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样
- 更好的语义。`async` 和 `await` 相较于 \* 和 `yield` 更加语义化
- 更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象。而 `async` 函数的 `await` 命令后面则可以是 `Promise` 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作）
- 返回值是 Promise。`async` 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 `then()` 方法进行调用


#### setTimeout、setInterval、requestAnimationFrame 各有什么特点？

异步编程当然少不了定时器了，常见的定时器函数有 `setTimeout`、`setInterval`、`requestAnimationFram`e。我们先来讲讲最常用的`setTimeout`，很多人认为 `setTimeout` 是延时多久，那就应该是多久后执行。

其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 `setTimeout` 不会按期执行。当然了，我们可以通过代码去修正 `setTimeout`，从而使定时器相对准确

```js
let period = 60 * 1000 * 60 * 2;
let startTime = new Date().getTime();
let count = 0;
let end = new Date().getTime() + period;
let interval = 1000;
let currentInterval = interval;

function loop() {
  count++;
  // 代码执行所消耗的时间
  let offset = new Date().getTime() - (startTime + count * interval);
  let diff = end - new Date().getTime();
  let h = Math.floor(diff / (60 * 1000 * 60));
  let hdiff = diff % (60 * 1000 * 60);
  let m = Math.floor(hdiff / (60 * 1000));
  let mdiff = hdiff % (60 * 1000);
  let s = mdiff / 1000;
  let sCeil = Math.ceil(s);
  let sFloor = Math.floor(s);
  // 得到下一次循环所消耗的时间
  currentInterval = interval - offset;
  console.log(
    '时：' + h,
    '分：' + m,
    '毫秒：' + s,
    '秒向上取整：' + sCeil,
    '代码执行时间：' + offset,
    '下次循环间隔' + currentInterval
  );

  setTimeout(loop, currentInterval);
}

setTimeout(loop, currentInterval);
```

`setInterval`，其实这个函数作用和 `setTimeout` 基本一致，只是该函数是每隔一段时间执行一次回调函数。

通常来说不建议使用 setInterval。
第一，它和 `setTimeout` 一样，不能保证在预期的时间执行任务。
第二，它存在执行累积的问题.

如果你有循环定时器的需求，其实完全可以通过 `requestAnimationFrame` 来实现

```js
function setInterval(callback, interval) {
  let timer;
  const now = Date.now;
  let startTime = now();
  let endTime = startTime;
  const loop = () => {
    timer = window.requestAnimationFrame(loop);
    endTime = now();
    if (endTime - startTime >= interval) {
      startTime = endTime = now();
      callback(timer);
    }
  };
  timer = window.requestAnimationFrame(loop);
  return timer;
}

let a = 0;
setInterval((timer) => {
  console.log(1);
  a++;
  if (a === 3) cancelAnimationFrame(timer);
}, 1000);
```

首先 `requestAnimationFrame` 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 setTimeout。

### 进程与线程

#### 进程与线程区别？JS 单线程带来的好处？

**区别**

进程相当于一个程序，线程是更小的单位，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。

当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。

**单线程带来的好处：**

JS 运行的时候可能会阻止 UI 渲染，这说明了两个线程是互斥的。因为 JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。

得益于 JS 是单线程运行的，可以达到**节省内存，节约上下文切换时间，没有锁的问题。**

当然前面两点在服务端中更容易体现，对于锁的问题，形象的来说就是当我读取一个数字 15 的时候，同时有两个操作对数字进行了加减，这时候结果就出现了错误。解决这个问题也不难，只需要在读取的时候加锁，直到读取完毕之前都不能进行写入操作。

### 变量提升

#### 什么是提升?

js 执行时会把`var`声明，函数声明 , `argument` 提到作用域顶部。

函数声明优于`var`变量声明。

提升是为了解决函数之间相互调用的问题。

#### 什么是暂时性死区?

`let`，`const`在声明前使用会报错，这个行为称之为暂时性死区。

#### var,let,const 有什么区别?

1. `let`，`const`声明不会挂载在`window`上。var 声明会挂载到`window`上。
2. `let`，`const`不能重复声明, var 可以重复声明。
3. `let`，`const`不存在变量提升, var 存在变量提升。
4. `let`，`const`只在块级作用域有效。
5. `const`常量一旦声明时必须赋值 , 且不能修改 。`let` `var`是变量， 可以进行修改。

### Class

#### class 本质？

- 本质是函数, js 中并不存在类，`class`只是语法糖， 使用`prototype`

#### Class 与普通的构造函数有什么区别?

- 在**语法**上更贴合面向对象的写法

- 在**继承**上更容易阅读理解


#### class 如何实现继承？

`class` 实现继承的核心在于使用 `extends` 表明继承自哪个父类。

子类构造函数中必须调用`super`才能传参数

### Es6 常用方法

#### Es6 常用的方法有哪些?

- let 和 const

- 解构赋值

- 扩展运算

- promise

- 模板字符串

- 箭头函数

- symbol

- set 和 map

- class

- Proxy 和 Reflect

- Module(模块化)

### Proxy
#### Proxy 可以实现什么功能？
在 Vue3.0 中将会通过 Proxy 来替换原本的 `Object.defineProperty` 来实现数据响应式。 `Proxy` 是 ES6 中新增的功能，它可以用来自定义对象中的操作。

之所以 Vue3.0 要使用 `Proxy` 替换原本的 API 原因在于 `Proxy` 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 `Proxy` 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。

### 箭头函数

#### 箭头函数与普通函数有什么区别?

箭头函数比普通函数更加简洁，没有`this`，不存在`arguments`对象，没有原型属性，不能当作构造函数，不能用作`Generator`函数 (不能使用`yield`命令)

### 综合考察题

#### 为什么 0.1 + 0.2 != 0.3
先说原因，因为 JS 采用 **IEEE 754 双精度版本（64位）**，并且只要采用 IEEE 754 的语言都有该问题。

 JS 采用的浮点数标准却会裁剪掉我们的数字。会造成精度丢失。

 解决方案：
 ```js
 parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true
 ```

#### 请写出以下代码的打印顺序

```js
function Foo() {
  getName = function () {
    console.log(1);
  };
  return this;
}
Foo.getName = function () {
  console.log(2);
};
Foo.prototype.getName = function () {
  console.log(3);
};
var getName = function () {
  console.log(4);
};
function getName() {
  console.log(5);
}

Foo.getName(); //2

getName(); //4
//考察了变量提升，输出4是由于函数和var被提升到最顶部，但函数是直接把函数体全部提升，而var只是声明，未赋值。执行下来赋值时已经将函数覆盖

Foo().getName(); //1
//考察作用域：首先执行Foo()，getName由于是全局声明，重新赋值getName，Foo返回this(即window)。然后执行的就是this.getName();结果为1
getName(); //1 同上

new Foo.getName(); //2
//考察运算符优先级 .是19  new在.之后   先执行Foo.getName()在执行new
new Foo().getName(); //3
//先计算. , .把前后分割，开始执行new Foo() , 然后找getName方法
new new Foo().getName(); //3
//先计算. , .把前后分割，new.foo()带参数优先级19，new是18，执行new Foo.getName()
```


## 笔试题

#### 创建 10 个`<a>`标签， 点击的时候弹出对应的序号

```js
const frag = document.createDocumentFragment();
const Max = 10;
for (let i = 0; i < Max; i++) {
  let a = document.createElement('a');
  a.innerHTML = i + '<br/>';
  a.addEventListener('click', function (e) {
    alert(e.target.innerText);
  });
  frag.appendChild(a);
}

document.body.appendChild(frag);
```

#### 用 js 实现一个 99 乘法表

```js
for (let i = 1; i <= 9; i++) {
  document.write('<br/>');
  for (let j = 1; j <= i; j++) {
    var result = i * j;
    document.write(i + 'x' + j + '=' + result + '&nbsp;&nbsp;&nbsp;');
  }
}
```

#### 自己实现一个实现一个`new`操作符:

```js
function create() {
  let obj = {}; //创建一个空对象
  let Con = [].shift.call(arguments); //获取第一个传进来的参数，也就是构造函数
  obj.__proto__ = Con.prototype; //链接到构造函数原型
  let result = Con.apply(obj, arguments); //绑定 this 并执行构造函数
  return result instanceof Object ? result : obj; //确保返回值为对象
}
```


#### 手写深拷贝

```js
function deepClone(obj = {}) {
  if (typeof obj !== 'object' || obj == null) {
    //obj是null， 或者不是对象和数组， 直接返回
    return obj;
  }
  //初始化结果
  let result;
  if (obj instanceof Array) {
    result = [];
  } else {
    result = {};
  }

  for (let key in obj) {
    // 保证key不是原型的属性
    if (obj.hasOwnProperty(key)) {
      result[key] = deepClone(obj[key]);
    }
  }
  // 返回结果
  return result;
}

var obj = {
  name: '小白',
  info: {
    money: [5],
  },
};

var cloneObj = deepClone(obj);
cloneObj.name = '小黑';
cloneObj.info.money = [88];
console.info(obj, cloneObj);
```


#### 写一个 clone 函数,可以复制原始类型的值.

```js
function clone(obj) {
  var o;
  switch (typeof obj) {
    case 'undefined':
      break;
    case 'string':
      o = obj + '';
      break;
    case 'number':
      o = obj - 0;
      break;
    case 'boolean':
      o = obj;
      break;
    case 'object':
      if (obj === null) {
        o = null;
      } else if (Object.prototype.toString.call(obj).slice(8, -1) === 'Array') {
        o = [];
        for (var i = 0; i < obj.length; i++) {
          o.push(clone(obj[i])); //深拷贝
        }
      } else {
        o = {};
        for (var k in obj) {
          o[k] = clone(obj[k]); //深拷贝
        }
      }
      break;
    default:
      o = obj;
      break;
  }
  return o;
}

//测试
var a = [12.3];
console.log(clone(a));
```

#### 以下代码如何实现点击列表显示相应的 index 值?

```js
<ul id="test">
    <li>1</li>
    <li>2</li>
    <li>3</li>
</ul>　　


//js
var ul = document.getElementById('test');
var lis = Array.from(ul.getElementsByTagName("li"));
ul.addEventListener("click",function(e){
console.log(lis.indexOf(e.target))
})


//使用jq:
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js"></script>
<script>
$('#test').on('click','li',function(e){
        alert($(this).index());
});
```

#### 手写 call 函数

```js
Function.prototype.myCall = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error');//调用`myCall`的对象必须是函数，如果是非函数会报错
  }
  context = context || window; //如果不传参，默认为window  此时context为o
  context.fn = this; //在o对象增加fn方法，指向需要调用的函数。此时调用myCall的就是a函数，this为a，也就是说调用的方法a变成了绑定对象下的方法a
  const args = [...arguments].slice(1); //从第一个参数后面进行复制
  const result = context.fn(...args); //截取后的name，age作为参数传入了a函数，执行a函数
  delete context.fn; //删除o对象的fn属性
  return result; //返回调用函数
};

function a(name, age, sex) {
  console.log(this.name, this.age);
  console.info(name, age, sex);
}
var name = 'xh',
  age = '23',
  sex = '女';
let o = {
  name: 'xz',
  age: '13',
  sex: '男',
};
a(name, age); //xh 23            /xh 23 undefined  这个this是指向window
a.myCall(o, name, age); //xz 13    /xh 23 undefined   这个this执行o
```

#### 手写 apply 函数

和`call`类似，区别在于处理参数，判断是否有第二个参数，如果有将作为数组传入调用函数

```js
Function.prototype.myApply = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error');
  }
  context = context || window;
  context.fn = this;
  let result;
  // 处理参数和 call 有区别
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }
  delete context.fn;
  return result;
};
```

#### 手写 bind 函数

```js
Function.prototype.myBind = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error');
  }
  const _this = this;
  const args = [...arguments].slice(1);
  // 返回一个函数
  return function F() {
    // 因为返回了一个函数，我们可以 new F()，所以需要判断
    if (this instanceof F) {
      return new _this(...args, ...arguments);
    }
    return _this.apply(context, args.concat(...arguments));
  };
};
```

#### 给定一段 URL 和参数的名称，获取此参数的值

```js
function getQuery(url,name){
  let strs
  let index = url.indexOf('?')
  if(index!==-1){
    strs = url.slice(index+1).split('&')
  }
  for(let k = 0; k < strs.length;k++ ){
    splitItem  = strs[k].split('=')
    if(splitItem [0]===name){
      return splitItem [1]
    }
  }
}
const url = 'https://www.baidu.com/s?id=123&name=why&phone=13876769797'
console.log(getQuery(url,'name'))//why
```

#### 写一个方法 , 去除掉重复元素...

```js
{//第一种
  let arr = [1, 3, 2, 1, 1, 2, 3, 1, 2]
  let nArr = []
  for (let i = 0; i < arr.length; i++) {
    if (nArr.indexOf(arr[i])===-1) {
      nArr.push(arr[i])
    }
  }
  console.log(nArr);
}

{//第二种
  let arr = [1, 3, 2, 1, 1, 2, 3, 1, 2]
  let nArr = arr.filter((current, index, self) => {
    return self.indexOf(current) === index
  })
  console.log(nArr);
}

{//第三种
  let arr = [1, 3, 2, 1, 1, 2, 3, 1, 2]
  let obj = {}
  let nArr = []
  for (let i = 0; i < arr.length; i++) {
    if (!obj[arr[i]]) {
      nArr.push(arr[i])
      obj[arr[i]] = true
    }
  }
  console.log(nArr);
}

// 利用 集合 来简化实现 ( ES6 Set )
{
  let _set = {};
  let _newarr = [];
  arr.forEach( v => _set[ v ] || ( _set[ v ] = true, _newarr.push( v ) ) ) // 减少赋值行为
}

{//第四种
  let arr = [1, 3, 2, 1, 1, 2, 3, 1, 2]
  let nArr = new Set(arr)
  console.log(Array.from(nArr));
}
```


#### 如何判断一个对象是否为数组

- 使用 `Array.isArray` 判断，如果返回 true, 说明是数组
- 使用 `instanceof Array` 判断，如果返回 true, 说明是数组

##### 自己实现一个 isArray
```js
function isArray(arg) {
  if (typeof arg === 'object') {
    return Object.prototype.toString.call(arg) === '[object Array]';
  }
  return false;
}
```

理解： `Object`对象和它的原型链上各自有一个`toString()`方法，第一个返回的是一个函数，第二个返回的是值类型。

通过`call`将`Array`的`this`上下文切换到`Object`，从而调用了`Object.prototype.toString()`，因此返回`[object Array]`。

##### 为什么不直接 `Array.prototype.toString.call([arg])`?

因为`Array`，`Function`,虽然是基于`Object` 进行创建的，但是他们继承的是`Object.toString()`，而不是`Object.prototype.toString()`。

#### 冒泡排序

每次比较相邻的两个数，如果后一个比前一个小，换位置

```js
var arr = [3, 1, 4, 6, 5, 7, 2];
function bubbleSort(arr) {
  for (var i = 0; i < arr.length - 1; i++) {
    for (var j = 0; j < arr.length - 1; j++) {
      if (arr[j + 1] < arr[j]) {
        var temp;
        temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}
console.log(bubbleSort(arr));
```

#### 快速排序

采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边

```js
var arr = [3, 1, 4, 6, 5, 7, 2];
function quickSort(arr) {
  if (arr.length == 0) {
    return []; // 返回空数组
  }
  var cIndex = Math.floor(arr.length / 2);
  var c = arr.splice(cIndex, 1);
  var l = [];
  var r = [];
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] < c) {
      l.push(arr[i]);
    } else {
      r.push(arr[i]);
    }
  }
  return quickSort(l).concat(c, quickSort(r));
}
console.log(quickSort(arr));
```

#### 求一个字符出现的次数

```js
function queryStr(str) {
  let json = {};
  let max = 0;
  let msg = '';
  //循环字符串，获取每个字符
  for (let i = 0; i < str.length; i++) {
    if (!json[str.charAt(i)]) {
      //判断json对象内是否有当前字符串内字符，如果没有将此字符作为键,值为1
      json[str.charAt(i)] = 1;
    } else {
      //如果json已经有当前字符传内字符，将值+1
      json[str.charAt(i)]++;
    }
  }
  
  //循环json对象
  for (let i in json) {
    if (json[i] > max) {
      //如果json对象内有值大于max，max就设置为此对象值，msg设置为此键
      max = json[i];
      msg = i;
    }
  }
  return {
    max,
    msg
  }
}

console.log('出现次数最多的字符是：',queryStr('hello').msg,'出现次数为：',queryStr('hello').max);
```

#### 编写一个方法 求一个字符串的字节长度

假设：一个英文字符占用一个字节，一个中文字符占用两个字节

```js {5}
function GetBytes(str) {
  var len = str.length;
  var bytes = len;
  for (var i = 0; i < len; i++) {
    if (str.charCodeAt(i) > 255) bytes++;
  }
  return bytes;
}
alert(GetBytes('你好,as'));
```



#### 写一个遍历对象和数组的 forEach 函数

```js
function myForEach(obj, fn) {
  if (Array.isArray(obj)) {//准确判断是不是数组
    obj.forEach((elem, index)=>{
      fn(elem, index)
    })
  } else {//不是数组就是对象
    for (let k in obj) {
      fn(obj[k], k)
    }
  }
}

var arr = [1, 2, 3];
myForEach(arr, function (item, index) {
  console.log(item, index);
});

var obj = { x: 100, y: 200 };
myForEach(obj, function (key, value) {
  console.log(key, value);
});
```

#### 手写promise

```js
function Promise(excutor) {
	this.status = 'pending'
	this.value = null
	this.reason = null
	this.onFulfilledArray = []
	this.onRejectedArray = []


	const resolve = (value) => {
		if (value instanceof Promise) {
			return value.then(resolve, reject)
		}

		setTimeout(() => {
			if (this.status === 'pending') {
				this.value = value
				this.status = 'fulfilled'

				this.onFulfilledArray.forEach(func => {
					func(value)
				})
			}
		});
	}

	const reject = (reason) => {
		setTimeout(() => {
			if (this.status === 'pending') {
				this.reason = reason
				this.status = 'rejected'

				this.onRejectedArray.forEach(func => {
					func(reason)
				})
			}
		})
	}
	try{
		excutor(resolve, reject)
	}catch(e){
		//TODO handle the exception
		reject(e)
	}
	
}
Promise.prototype.then = function(onfulfilled = Function.prototype, onrejected = Function.prototype) {
	onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : data => data
	onrejected = typeof onrejected === 'function' ? onrejected : error => {
		throw error
	}

	if (this.status === 'fulfilled') {
		onfulfilled(this.value)
	}
	if (this.status === 'rejected') {
		onrejected(this.reason)
	}
	if (this.status === 'pending') {
		this.onFulfilledArray.push(onfulfilled)
		this.onRejectedArray.push(onrejected)
	}
}


let promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('data')
  }, 2000)
})

promise.then(data => {
  console.log(`1: ${data}`)
})
promise.then(data => {
  console.log(`2: ${data}`)
})
```

#### 手写简易 jQuery 考虑插件和扩展性

```javascript
class jQuery {
  constructor(selector) {
    const result = document.querySelectorAll(selector);
    const length = result.length;
    for (let i = 0; i < length; i++) {
      this[i] = result[i];
    }
    this.length = length;
    this.selector = selector;
  }
  get(index) {
    return this[index];
  }
  each(fn) {
    for (let i = 0; i < this.length; i++) {
      const elem = this[i];
      fn(elem);
    }
  }
  //扩展更多 DOM API
}

//插件
jQuery.prototype.dialog = function (info) {
  alert(info);
};

//造轮子
class myJquery extends jQuery {
  constructor(selector) {
    super(selector);
  }
  on(type, fn) {
    return this.each((elem) => {
      elem.addEventListener(type, fn, false);
    });
  }
}

const $p = new myJquery('p');
console.log($p);
console.log($p.get(1));
$p.each((elem) => {
  console.log(elem.innerText);
});
$p.on('click', () => {
  alert(1);
});

$p.dialog('abc');
```

#### 编写一个通用的事件监听函数

```js
function on(elem, type, selector, fn) {
  if (fn == null) {
    fn = selector;
    selector = null;
  }
  elem.addEventListener(type, function (e) {
    const target = e.target;
    if (selector) {
      //代理绑定
      if (target.matches(selector)) {
        fn.call(target, e);
      }
    } else {
      //普通绑定
      fn(e);
    }
  });
}
```

#### 手写一个简易的 ajax

```js
function ajax(url) {
  const p = new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          resolve(JSON.parse(xhr.responseText));
        } else if (xhr.status === 404) {
          reject(new Error('404 not found'));
        }
      }
    };
    xhr.send(null);
  });
  return p;
}

const url = '/data/test.json';
ajax(url)
  .then((res) => console.log(res))
  .catch((err) => console.error(err));
```

#### 用ES5写一个能够生成迭代器对象的迭代器生成函数

```js
// 定义生成器函数，入参是任意集合
function iteratorGenerator(list) {
    // idx记录当前访问的索引
    var idx = 0
    // len记录传入集合的长度
    var len = list.length
    return {
        // 自定义next方法
        next: function() {
            // 如果索引还没有超出集合长度，done为false
            var done = idx >= len
            // 如果done为false，则可以继续取值
            var value = !done ? list[idx++] : undefined
            
            // 将当前值与遍历是否完毕（done）返回
            return {
                done: done,
                value: value
            }
        }
    }
}

var iterator = iteratorGenerator(['1号选手', '2号选手', '3号选手'])
iterator.next()
iterator.next()
iterator.next()
```


## Git

#### git和svn的区别?

- 中央版本控制系统

`SVN` 是中央版本控制系统，必须存在两个端，服务端和客户端。

客户端都是把数据推送服务器当中去，拉取的时候代码也都是从服务器中获取，是非常典型的 C/S 机制；所有客户端的交互都必须通过中央服务器，不能私下直接访问。

![SVN](https://gitee.com/l544402029/res/raw/master/小书匠/1588082088250.png)

- 分布式版本控制系统

`Git` 是分布式版本控制系统。是将备份的代码以及记录完全独立在本地存储。当你想将代码恢复到某一个版本的时候，本地版本控制器，不需要依赖网络便可以完成此操作。

![git](https://gitee.com/l544402029/res/raw/master/小书匠/1589192077169.png)


**区别：**
- `Git`可以在客户端自由创建分支，`SVN` 必须由服务器创建。
- `Git`没有网络依然可以提交代码， `SVN` 必须连接服务器才可以提交。


## Webpack

关于 webpack 面试题可参考 [webpack 面试题部分](http://l544402029.gitee.io/blog/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/webpack/#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93)


---

## 项目流程

#### 项目角色

- PM 产品经理
- UE 视觉设计师
- FE 前端开发
- RD 后端开发
- CRD 移动端开发
- QA 测试人员

#### 项目流程

![项目流程](https://gitee.com/l544402029/res/raw/master/小书匠/1586443524013.png)

#### 评审项目需求时需要注意哪些事项？

- 了解背景
- 质疑需求是否合理
- 需求是否闭环

如常见的点赞功能，我们要开发这个功能。我们要考虑点完赞之后呢？这个点赞功能怎么用起来呢？ 如点赞高低进行排序

- 开发难度如何
- 是否需要其他支持
- 不要急于给排期

如何反馈排期？

1. 大概预留比自己预估时间多 1/4 的时间。 如预估时间为 4 天。 排期 5 天。预估 1 个月， 排期 35 天左右。

2. 另外要考虑是否有并行的工作。如果有并行的任务， 应适当延长排期。
3. 要考虑 UE（视觉设计师）的排期。如果还依赖 RD（后端开发）或者 CRD （移动端开发）， 应先确定他们的排期再安排自己的排期。  
   如果大家的排期没确定，可以给一个工作量。要花几天能够做完。如 3 天做完。至于 2 号到 4 号，还是 4 号到 6 号。 什么时候能确定完成， 要看“上游”什么时候完成工作。

#### 如何做好技术方案设计？

- 求简， 不过度设计
- 产出文档
- 找准设计重点
- 组内评审
- 和 RD CRD 沟通
- 发出会议总结

#### 如何保证代码质量？

- 符合开发规范
  1. git
  2. 注释规范
  3. 命名规范
- 写出开发文档
- 单元测试
- MOCK API
- Code Review

#### 项目过程中 PM 加需求怎么办？

**联调**

- 和 RD CRD 技术联调
- 让 UE 确定视觉效果
- 让 PM 确定产品功能

要尽早的让 UE， PM 介入， review 这些功能。 尽早把问题暴露出来。 而不是等上线后再暴露问题。

**加需求怎么办？**

- 不能拒绝， 走需求变更流程即可
- 如果公司有规定，则按规定走
- 否则， 发起项目组和 leader 的评审， 重新评估排期

如果需求变动过小， 不至于再次发起评审。 可发邮件， 微信群等方式通知项目相关人员。

#### 测试

- 提测发邮件， 抄送项目组
- 测试问题要详细记录
- 有问题及时沟通
- 如需特定设备才能复现问题， 让 QA 提供设备

#### 上线

- 上线之后及时通知 QA 回归测试
- 上线之后及时同步给 PM 和 项目组
- 如有问题，及时回滚。先止损，再排查问题。

#### 项目沟通

- 每日进行沟通，有事说事， 无事报平安。
- 及时识别风险，及时汇报

## 通用问题

#### 说说你写过最复杂的 js 代码...

#### 说说你做过最复杂的项目

#### 做一下自我介绍

:::tip 思路
我平时喜欢一些网站，喜欢去看它们的技术原理和技术好玩的点。然后呢我自己喜欢思考，我也愿意去尝试是否有更好的实现方式。
此时谨记要收住不要继续往下说， 后半句等面试官发问， 你都喜欢哪些网站？比如喜欢微信读书，艺龙。。。
:::

您好， 我叫 \*\*\*。有一年的前端开发工作经验。之前主要负责过电商，图片处理等方面的开发工作。 现在比较擅长技术栈有 VUE, jQuery, 平时的话也会写写自己的博客之类的。今天应聘这个岗位主要是对咱们公司的这个业务很感兴趣，这个岗位的职业发展跟我自身规划比较吻合。 希望能够加入进来一起工作。


#### 说说你的职业规划

今年的目标是打算研究 Vue 源码 以及 webpack。然后是读两本书 《CSS世界》《你不知道的JavaScript》，并把自己所理解出来的东西输出到博客。

明年打算研究前端算法，Node.js 。

希望能够在三年内能够成为一名比较成熟的全栈开发工程师，能够多参加一些开源作品。

#### 你的五年内的职业目标是什么？

我希望自己能成为团队里重要的一份子，多多承担责任，并培养自己的技术能力和沟通技巧，五年内成长为一名成熟的技术主管。

#### 为什么要跳槽？

主要是之前公司的技术栈比较老旧，代码书写，部署流程不规范， 能够成长的空间很有限。

#### 你的缺点？

主要还是对服务端/Node 方面的知识知道的太少， 对知识的掌握不够全面。

#### 你有什么想问的吗？

- 现在公司团队有多少人？怎么分工？
- 公司常用的技术栈是什么？
- 公司是否有技术分享交流活动？有的话，多久一次呢？
- 公司试用期多长时间呢？试用期工资多少呢？
- 公司是否交五险一金？缴纳比例？
- 公司休息时间是怎么安排呢？大小周？双休？单休？
- 你觉得我有什么需要改进的地方吗？
- 有公司级别的学习资源吗？比如电子书订阅或者在线课程？
- 你们认为和竞品相比有什么优势？


#### 你对当前待遇的期望...

我希望按照咱们公司正常的薪资标准来就可以 , 我更看重能够在咱们公司学习到更多东西.

#### 如果达不到期望,你会如何选择?

- 我相信公司不会让我失望的。

- 如果达不到期望 , 说明我自身技术水平还达不到咱们公司的要求 , 我会更加努力学习的。

