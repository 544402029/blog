import{_ as o,c as t,o as a,a3 as r}from"./chunks/framework.47i9LX9H.js";const T=JSON.parse('{"title":"计算机网络通关 29 讲","description":"","frontmatter":{},"headers":[],"relativePath":"前端笔记/计算机网络通关29讲.md","filePath":"前端笔记/计算机网络通关29讲.md"}'),s={name:"前端笔记/计算机网络通关29讲.md"},n=r('<h1 id="计算机网络通关-29-讲" tabindex="-1">计算机网络通关 29 讲 <a class="header-anchor" href="#计算机网络通关-29-讲" aria-label="Permalink to &quot;计算机网络通关 29 讲&quot;">​</a></h1><blockquote><p>本文由阅读《<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=837#/detail/pc?id=7267" target="_blank" rel="noreferrer">计算机网络通关 29 讲)</a>)》记录笔记，有兴趣可阅读原版教程。</p></blockquote><h2 id="传输层协议-tcp" tabindex="-1">传输层协议 TCP <a class="header-anchor" href="#传输层协议-tcp" aria-label="Permalink to &quot;传输层协议 TCP&quot;">​</a></h2><h3 id="tcp-协议" tabindex="-1">TCP 协议 <a class="header-anchor" href="#tcp-协议" aria-label="Permalink to &quot;TCP 协议&quot;">​</a></h3><p><strong>TCP（Transport Control Protocol）是一个传输层协议，提供 Host-To-Host 数据的可靠传输，支持全双工，是一个连接导向的协议。</strong></p><h3 id="主机到主机-host-to-host" tabindex="-1">主机到主机（Host-To-Host） <a class="header-anchor" href="#主机到主机-host-to-host" aria-label="Permalink to &quot;主机到主机（Host-To-Host）&quot;">​</a></h3><p><strong>TCP 提供的是 Host-To-Host 传输，一台主机通过 TCP 发送数据给另一台主机</strong>。这里的主机（Host）是一个抽象的概念，可以是手机、平板、手表等。收发数据的设备都是主机，所以双方是平等的。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20220818144749540.png" alt="image-20220818144749540"></p><p>**TCP 协议往上是应用到应用（Application-To-Application）的协议。**什么是应用到应用的协议呢？比如你用微信发信息给张三，你的微信客户端、微信聊天服务都是应用。微信有自己的聊天协议，微信的聊天协议是应用到应用的协议；如果微信的聊天协议想要工作，就需要一个主机到主机的协议帮助它实现通信。</p><p>而 TCP 上层有太多的应用，不仅仅有微信，还有原神、抖音、网易云音乐……因此 TCP 上层的应用层协议使用 TCP 能力的时候，需要告知 TCP 是哪个应用——这就是**==端口号。端口号用于区分应用==**，下文中我们还会详细讨论。</p><p>TCP 要实现主机到主机通信，就需要知道主机们的<strong>网络地址（IP 地址）</strong>，但是 TCP 不负责实际地址到地址（Address-To-Address）的传输，因此 TCP 协议把 IP 地址给底层的互联网层处理。</p><p><strong>互联网层，也叫网络层（Network Layer），提供地址到地址的通信</strong>，IP 协议就在这一层工作。<strong>互联网层解决地址到地址的通信，但是不负责信号在具体两个设备间传递</strong>。因此，<strong>网络层会调用下方的==链路层==在两个相邻设备间传递信息</strong>。当信号在两个设备间传递的时候，科学家又设计出了<strong>物理层封装最底层的物理设备、传输介质</strong>等，由最下方的<strong>物理层提供最底层的传输能力</strong>。</p><p>以上的 5 层架构，我们称为<strong>互联网协议群</strong>，也称作 <strong>TCP/IP 协议群</strong>。总结下，<strong>主机到主机（Host-To-Host）为应用提供应用间通信的能力。</strong></p><h3 id="什么是连接和会话" tabindex="-1">什么是连接和会话？ <a class="header-anchor" href="#什么是连接和会话" aria-label="Permalink to &quot;什么是连接和会话？&quot;">​</a></h3><p>连接是通信双方的一个约定，目标是让两个在通信的程序之间产生一个默契，保证两个程序都在线，而且尽快地响应对方的请求，这就是<strong>连接（Connection）</strong>。</p><p>设计上，连接是一种传输数据的行为。传输之前，建立一个连接。具体来说，数据收发双方的内存中都建立一个用于维护数据传输状态的对象，比如双方 IP 和端口是多少？现在发送了多少数据了？状态健康吗？传输速度如何？等。所以，<strong>连接是网络行为状态的记录。</strong></p><p>和连接关联的还有一个名词，叫作会话（Session），<strong>会话是应用的行为</strong>。比如微信里张三和你聊天，那么张三和你建立一个会话。你要和张三聊天，你们创建一个聊天窗口，这个就是会话。</p><p><strong>会话是应用层的概念，连接是传输层的概念。</strong></p><h3 id="双工-单工问题" tabindex="-1">双工/单工问题 <a class="header-anchor" href="#双工-单工问题" aria-label="Permalink to &quot;双工/单工问题&quot;">​</a></h3><p>在任何一个时刻，如果数据只能单向发送，就是<strong>单工</strong>，所以单工需要至少一条线路。如果在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行，叫作<strong>半双工</strong>；半双工需要至少 1 条线路。最后，如果任何时刻数据都可以双向收发，这就是<strong>全双工</strong>，全双工需要大于 1 条线路。当然这里的线路，是一个抽象概念，你可以并发地处理信号，达到模拟双工的目的。</p><p><strong>TCP 是一个双工协议，数据任何时候都可以双向传输</strong>。这就意味着客户端和服务端可以平等地发送、接收信息。正因为如此，客户端和服务端在 TCP 协议中有一个平等的名词——<strong>Host（主机）</strong>。</p><h3 id="什么是可靠性" tabindex="-1">什么是可靠性？ <a class="header-anchor" href="#什么是可靠性" aria-label="Permalink to &quot;什么是可靠性？&quot;">​</a></h3><p>**可靠性指数据保证无损传输。**如果发送方按照顺序发送，然后数据无序地在网络间传递，就必须有一种算法在接收方将数据恢复原有的顺序。</p><h3 id="建立连接的过程-三次握手" tabindex="-1">建立连接的过程（三次握手） <a class="header-anchor" href="#建立连接的过程-三次握手" aria-label="Permalink to &quot;建立连接的过程（三次握手）&quot;">​</a></h3><p>因为要保持连接和可靠性约束，TCP 协议要保证每一条发出的数据必须给返回，返回数据叫作 ACK（也就是响应）。</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20221205112501035.png" alt="image-20221205112501035"></p><h3 id="断开连接的过程-4-次挥手" tabindex="-1">断开连接的过程（4 次挥手） <a class="header-anchor" href="#断开连接的过程-4-次挥手" aria-label="Permalink to &quot;断开连接的过程（4 次挥手）&quot;">​</a></h3><ol><li><p>端要求断开连接，发送一个断开的请求，这个叫作（FIN）。</p></li><li><p>服务端收到请求，然后给客户端一个 ACK，作为 FIN 的响应。</p></li><li><p>这里你需要思考一个问题，可不可以像握手那样马上传 FIN 回去？ 其实这个时候服务端不能马上传 FIN，因为断开连接要处理的问题比较多，比如说服务端可能还有发送出去的消息没有得到 ACK；也有可能服务端自己有资源要释放。因此断开连接不能像握手那样操作——将两条消息合并。所以，服务端经过一个等待，确定可以关闭连接了，再发一条 FIN 给客户端。</p></li><li><p>客户端收到服务端的 FIN，同时客户端也可能有自己的事情需要处理完，比如客户端有发送给服务端没有收到 ACK 的请求，客户端自己处理完成后，再给服务端发送一个 ACK。</p></li></ol><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20221205115252561.png" alt="image-20221205115252561"></p><h2 id="tcp-的封包格式" tabindex="-1">TCP 的封包格式 <a class="header-anchor" href="#tcp-的封包格式" aria-label="Permalink to &quot;TCP 的封包格式&quot;">​</a></h2><h3 id="tcp-的拆包和粘包" tabindex="-1">TCP 的拆包和粘包 <a class="header-anchor" href="#tcp-的拆包和粘包" aria-label="Permalink to &quot;TCP 的拆包和粘包&quot;">​</a></h3><p>TCP 是一个传输层协议。TCP 发送数据的时候，往往不会将数据一次性发送，像下图这样：</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20221205141107908.png" alt="image-20221205141107908"></p><p>而是将数据拆分成很多个部分，然后再逐个发送。像下图这样：</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20221205141125366.png" alt="image-20221205141125366"></p><p>同样的，在目的地，TCP 协议又需要逐个接收数据。请你思考，<strong>TCP 为什么不一次发送完所有的数据？</strong></p><p>这里有很多原因，比如为了稳定性，一次发送的数据越多，出错的概率越大。再比如说为了效率，网络中有时候存在着并行的路径，拆分数据包就能更好地利用这些并行的路径。再有，比如发送和接收数据的时候，都存在着缓冲区。如下图所示：</p><p><img src="https://blog-picgo-typora.oss-cn-hangzhou.aliyuncs.com/image-20221205141554015.png" alt="image-20221205141554015"></p><p>缓冲区是在内存中开辟的一块区域，目的是缓冲。因为大量的应用频繁地通过网卡收发数据，这个时候，网卡只能一个一个处理应用的请求。当网卡忙不过来的时候，数据就需要排队，也就是将数据放入缓冲区。如果每个应用都随意发送很大的数据，可能导致其他应用实时性遭到破坏。</p><p>总之，方方面面的原因：<strong>在传输层封包不能太大</strong>。这种限制，往往是以缓冲区大小为单位的。也就是 TCP 协议，会将数据拆分成不超过缓冲区大小的一个个部分。每个部分有一个独特的名词，叫作 <strong>TCP 段（TCP Segment）</strong>。</p><p>在接收数据的时候，一个个 TCP 段又被重组成原来的数据。</p><p>像这样，数据经过拆分，然后传输，然后在目的地重组，俗称<strong>拆包</strong>。所以拆包是将数据拆分成多个 TCP 段传输。</p><p>那么粘包是什么呢？有时候，如果发往一个目的地的多个数据太小了，为了防止多次发送占用资源，TCP 协议有可能将它们合并成一个 TCP 段发送，在目的地再还原成多个数据，这个过程俗称<strong>粘包</strong>。所以粘包是将多个数据合并成一个 TCP 段发送。</p>',43),e=[n];function p(i,g,l,c,h,P){return a(),t("div",null,e)}const m=o(s,[["render",p]]);export{T as __pageData,m as default};
